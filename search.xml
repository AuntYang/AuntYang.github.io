<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>zigbee课程设计</title>
      <link href="/2023/03/23/zigbee-ke-cheng-she-ji/"/>
      <url>/2023/03/23/zigbee-ke-cheng-she-ji/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2023/03/23/content/post/ce-shi/"/>
      <url>/2023/03/23/content/post/ce-shi/</url>
      
        <content type="html"><![CDATA[<p>这是一篇测试文章</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代理服务器搭建</title>
      <link href="/2022/04/27/xiao-wai-fang-wen-xiao-nei-wang/"/>
      <url>/2022/04/27/xiao-wai-fang-wen-xiao-nei-wang/</url>
      
        <content type="html"><![CDATA[<h1 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h1><p>硬件：</p><ul><li>具备公网IP的主机（此处使用阿里云服务器）</li><li>连接校内网的主机（此处使用运行Ubunt系统的虚拟机）</li></ul><p>软件：</p><ul><li>frp（内网穿透工具）</li><li>squid（代理服务器工具，UNIX/linux主要采用Squid实现代理服务器功能）</li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><img src="https://s2.loli.net/2022/04/27/Tn6Y9EFy5crkueb.png" alt="代理拓扑图"></p><ul><li>为什么要云服务器？</li></ul><p>​    校园网（校内网）是一个具备严格防火墙的局域网，公网上的设备并不能够直接访问校内网的各种资源，为了实现外网能够访问校园网，我们有两种思路，一在具备公网IP地址的云服务器和校内主机上都安装frp软件，实现内网穿透功能。二是在校内主机上架设VPN服务器，校外设备通过VPN连接校内网访问校内资源。本文采用第一种方式。</p><ul><li>为什么要代理服务器？</li></ul><p>​    代理服务器能够监听设备上的端口，一旦端口接受到访问请求，代理程序会按照预先设定的配置将端口中接收到的访问请求转发并返回请求内容，在校内主机上安装<a href="https://so.csdn.net/so/search?q=Squid&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">Squid</a>软件，从而将校内主机变为代理服务器，能够转发来自校外设备的浏览器请求。</p><h1 id="实现内网穿透"><a href="#实现内网穿透" class="headerlink" title="实现内网穿透"></a>实现内网穿透</h1><h2 id="云服务器安装frp-server"><a href="#云服务器安装frp-server" class="headerlink" title="云服务器安装frp-server"></a>云服务器安装frp-server</h2><h3 id="获取frp软件"><a href="#获取frp软件" class="headerlink" title="获取frp软件"></a>获取frp软件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src  <span class="token comment" spellcheck="true">#进入此目录</span><span class="token function">wget</span> https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz <span class="token comment" spellcheck="true">#下载frp</span><span class="token function">tar</span> -xvf frp_0.38.0_linux_amd64.tar.gz <span class="token comment" spellcheck="true">#解压；frp文件</span><span class="token function">cd</span> frp_0.38.0_linux_amd64/ <span class="token comment" spellcheck="true">#进入解压后的frp文件夹</span><span class="token function">ls</span> <span class="token comment" spellcheck="true">#浏览文件夹</span></code></pre><p><img src="https://s2.loli.net/2022/04/27/AB7lXHTYsqaDzWd.png" alt="ls命令结果"></p><p>可见frp文件夹中包含了frpc和frps两个可执行文件，frpc即frp-client（客户端），frps即frp-server（服务端）</p><h3 id="配置frp服务器端配置文件frps-ini"><a href="#配置frp服务器端配置文件frps-ini" class="headerlink" title="配置frp服务器端配置文件frps.ini"></a>配置frp服务器端配置文件frps.ini</h3><p>用vim命令打开frps.ini文件</p><pre><code>[common]bind_port = 7000   #frp使用的端口dashboard_user = admin    #流量监控的账户  自己设置dashboard_pwd = 123456    #流量监控的密码   自己设置dashboard_port = 6440     #流量监控程序的端口，搭建完成之后用 云服务器IP:6440 就可以打开流量监控网页程序</code></pre><h3 id="启动frp服务端"><a href="#启动frp服务端" class="headerlink" title="启动frp服务端"></a>启动frp服务端</h3><pre><code>nohup ./frps -c ./frps.ini &amp;</code></pre><p>注：nohup的作用是让我在关闭Xshell远程连接时，frp服务端不会跟ssh进程一起关闭。<br>参考文档：<br><a href="https://blog.csdn.net/gatieme/article/details/52777721" target="_blank" rel="noopener">解决Linux关闭终端(关闭SSH等)后运行的程序自动停止</a><br><a href="https://blog.csdn.net/davidhzq/article/details/102766881" target="_blank" rel="noopener">在linux后台运行脚本命令和程序的方法大全</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><img src="https://s2.loli.net/2022/04/27/uKyGrtOgTzNWQin.png" alt="在这里插入图片描述">注意事项</h3><p>国内云服务器大多都要配置安全组的，以阿里云为例，配置规则里更改访问规则，从而打开需要用到的端口。</p><h2 id="在校内主机安装frp-client"><a href="#在校内主机安装frp-client" class="headerlink" title="在校内主机安装frp-client"></a>在校内主机安装frp-client</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src  <span class="token comment" spellcheck="true">#进入此目录</span><span class="token function">wget</span> https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz      <span class="token comment" spellcheck="true">#笔者这里用的版本和云服务器的一样，读者在Github选择自己合适的版本</span><span class="token function">tar</span> -xvf frp_0.38.0_linux_amd64.tar.gz <span class="token comment" spellcheck="true">#解压文件</span><span class="token function">cd</span> frp_0.31.1_linux_amd64/<span class="token function">ls</span></code></pre><p><img src="https://s2.loli.net/2022/04/27/R4n5vMAlhk8BUzL.png" alt="ls命令结果"></p><h3 id="配置frp客户端配置文件frpc-ini"><a href="#配置frp客户端配置文件frpc-ini" class="headerlink" title="配置frp客户端配置文件frpc.ini"></a>配置frp客户端配置文件frpc.ini</h3><p>用vim命令打开frpc.ini文件。</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[common]</span><span class="token constant">server_addr</span> <span class="token attr-value"><span class="token punctuation">=</span> &lt;你的云服务器IP地址></span><span class="token constant">server_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 7000</span><span class="token selector">[ssh]</span><span class="token constant">type</span> <span class="token attr-value"><span class="token punctuation">=</span> tcp</span><span class="token constant">local_ip</span> <span class="token attr-value"><span class="token punctuation">=</span> 127.0.0.1</span><span class="token constant">local_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 22        #local_port端口是校内主机的ssh端口号</span><span class="token constant">remote_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 6001     #remote_port端口是云服务器的端口号。此端口自己设置，实现当你用Xshell连接 云服务器IP地址:6001即是在连接你校内主机的SSH端口</span></code></pre><p>启动frp客户端</p><pre class=" language-bash"><code class="language-bash">./frpc -c ./frpc.ini <span class="token comment" spellcheck="true">#若需要关闭终端后仍继续运行，参考上文云服务器端命令</span></code></pre><h2 id="测试frp是否搭建成功"><a href="#测试frp是否搭建成功" class="headerlink" title="测试frp是否搭建成功"></a>测试frp是否搭建成功</h2><p>用Xshell连接，连接地址填 云服务器IP地址:6001，用户名和密码填校内主机的。如果ssh能够成功连接，则成功实现内网穿透。<br>frp官方提供的教程：<a href="https://gofrp.org/docs/examples/ssh/" target="_blank" rel="noopener">通过SSH访问内网机器</a></p><h1 id="校内主机实现代理服务器功能"><a href="#校内主机实现代理服务器功能" class="headerlink" title="校内主机实现代理服务器功能"></a>校内主机实现代理服务器功能</h1><h2 id="校内主机安装Squid软件"><a href="#校内主机安装Squid软件" class="headerlink" title="校内主机安装Squid软件"></a>校内主机安装Squid软件</h2><p>安装软件</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> squid -yyum <span class="token function">install</span> httpd-tools -y  <span class="token comment" spellcheck="true">#以上两命令适用于centos</span>apt <span class="token function">install</span> squid -yapt <span class="token function">install</span> apache2-utils -y<span class="token comment" spellcheck="true">#以上两条命令适用于Ubuntu</span></code></pre><p>生成密码文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /etc/squid3/<span class="token comment" spellcheck="true">#ikaros 是用户名</span>htpasswd -cd /etc/squid3/passwords ikaros<span class="token comment" spellcheck="true">#提示输入密码，比如输入123456</span></code></pre><p><img src="https://s2.loli.net/2022/04/27/Cb5KoEj6Nk2Flim.png" alt="生成密码文件执行结果"></p><p>测试密码文件</p><pre class=" language-bash"><code class="language-bash">/usr/lib64/squid/basic_ncsa_auth /etc/squid3/passwords<span class="token comment" spellcheck="true">#输入用户名 密码</span>ikaros  123456<span class="token comment" spellcheck="true">#提示ok说明成功</span>ok<span class="token comment" spellcheck="true">#ctrl+c退出</span></code></pre><p><img src="https://s2.loli.net/2022/04/27/lyeFmL3x5dg9W6U.png" alt="测试密码文件执行结果"></p><p>配置squid.conf文件</p><pre class=" language-ini"><code class="language-ini">vim /etc/squid/squid.conf#在最后添加auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid3/passwordsauth_param basic realm proxyacl authenticated proxy_auth REQUIREDhttp_access allow authenticated# And finally deny all other access to this proxyhttp_access allow all# Deny CONNECT to other than secure SSL portshttp_access allow CONNECT !SSL_ports#这里是端口号，可以按需修改#http_port 3128 这样写会同时监听ipv6和ipv4的端口，推荐适应下面的配置方法。http_port 0.0.0.0:3128</code></pre><p>squid软件相关命令</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#启动start</span>systemctl start squid.service<span class="token comment" spellcheck="true">#停止stop</span>systemctl stop squid.service<span class="token comment" spellcheck="true">#重启stop</span>systemctl restart squid.service<span class="token comment" spellcheck="true">#配置开机自启动</span>systemctl <span class="token function">enable</span> squid.service<span class="token comment" spellcheck="true">#关闭开机自启动</span>systemctl disable squid.service<span class="token comment" spellcheck="true">#查看运行状态</span>systemctl status squid.service</code></pre><p><img src="https://s2.loli.net/2022/04/27/dXsaZYW2DNJzjw4.png" alt="执行启动命令结果"></p><p>参考教程：<a href="https://zhuanlan.zhihu.com/p/123048354" target="_blank" rel="noopener">Centos7搭建Squid代理服务器</a></p><h2 id="修改校内主机frp客户端配置文件frpc-ini"><a href="#修改校内主机frp客户端配置文件frpc-ini" class="headerlink" title="修改校内主机frp客户端配置文件frpc.ini"></a>修改校内主机frp客户端配置文件frpc.ini</h2><p>我们在4.1步骤里添加了校内主机3128端口为代理服务器的端口，所有到此端口的浏览器请求都会被此端口转发出去。<br>此时我们还得更改校内主机frp客户端配置文件frpc.ini，从而使云服务器所收到的浏览器请求转发到校内主机的3128端口。</p><p>Xshell以root身份连接校内主机</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src/frp_0.38.0_linux_amd64/    <span class="token comment" spellcheck="true">#进入校内服务器的存放frp文件的目录</span>vim frpc.ini<span class="token comment" spellcheck="true">#在最后添加</span><span class="token comment" spellcheck="true">#[proxy-http]</span><span class="token comment" spellcheck="true">#local_ip = 127.0.0.1</span><span class="token comment" spellcheck="true">#local_port = 3128</span><span class="token comment" spellcheck="true">#remote_port = 8000    此端口自己设置，步骤五会用到。</span></code></pre><p>重启frp客户端</p><pre class=" language-bash"><code class="language-bash"><span class="token function">nohup</span> ./frpc -c ./frpc.ini <span class="token operator">&amp;</span> </code></pre><p>如果报以下错误，说明之前的frp客户端还没关闭。关闭方法可kill此进程，具体方法百度如何重启frp客户端。</p><p><img src="https://s2.loli.net/2022/04/27/oQBaIVYXvGqSfg1.png" alt="错误"></p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>到了这一步，校园网代理就算搭建完毕，可以直接使用windows连接我们的代理。看校外的笔记本电脑是否呢能够免费下载知网，以及顶会期刊论文。</p><p>打开windows菜单-&gt;设置-&gt;网络与Internet-&gt;代理</p><p><img src="https://s2.loli.net/2022/04/27/dgYZ3nb6hq4jlxR.png" alt="win10设置代理"></p><p>在地址一栏填上你的云服务器IP地址，端口填8000（在4.2这一步设置的），然后打开使用代理服务器的开关</p><p>然后打开浏览器，就可以成功访问校园网资源</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代理服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxy </tag>
            
            <tag> 代理服务器 </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语翻译-唐静</title>
      <link href="/2021/08/23/kao-yan-ying-yu-fan-yi-tang-jing/"/>
      <url>/2021/08/23/kao-yan-ying-yu-fan-yi-tang-jing/</url>
      
        <content type="html"><![CDATA[<p>在考研翻译中，碰到代词：</p><p>1.可以尝试直接对应为汉语代词，前提是译文要通顺。</p><p>2.如果不通顺，则需要指代明确，尽可能地用指代到的名词翻译。这时，需要往前看，根据“就近和一致原则”来确定。</p><p>3.万不得已，可以直接用“这、这种情况、这种说法、这种观点”等来翻译</p><p>通顺——是最大的控制原则：</p><p>1.直接对应——适合第一、二人称</p><p>2.指代明确——第三人称代词，要小心（they,their,them,it,this,that）</p><p>3.用“这、这种情况/观点/看法”——It,This,That</p><p>常考词：</p><p>those有“那些人”的意思</p><p>assume假定；猜想；认为</p><p>believe相信；认为</p><p>believe…in信仰</p><p>assert断言</p><p>claim要求；主张；声称；索取；申领；夺取</p><p>maintain维持；保持；主张</p><p>accept接受</p><p>contend坚持说</p><p>argue辩论说；争论说</p><p>prove证明</p><p>validate证明；验证</p><p>demonstrate证明; 证实; 论证; 说明; 表达; 表露; 表现;</p><p>state陈述；说明</p><p>point out指出</p><p>be convinced that坚信；认为</p><p>There be句型：</p><p>人们（我们、大家）对……有……</p><p><img src="https://i.loli.net/2021/08/17/oKmGMqkduflxhFQ.png" alt="image-20210817112839446"></p><p><img src="https://i.loli.net/2021/08/17/CrPtgJoB9EbWVxp.png" alt=" "></p><p><img src="https://i.loli.net/2021/08/17/qG1spc2feE3tawP.png" alt="image-20210817095728409"></p><p><img src="https://i.loli.net/2021/08/17/QfT2kIrmweVYA7u.png" alt="image-20210817095854382"></p><p><img src="https://i.loli.net/2021/08/23/OTxECsBScdMHQ6i.png" alt="image-20210823145022585"></p><p><img src="https://i.loli.net/2021/08/17/FnQr7XMUDdEohHu.png" alt="image-20210817100234121"></p><p><img src="https://i.loli.net/2021/08/17/7bt2Ie8VmN3GTyL.png" alt="image-20210817100453132"></p><p><img src="https://i.loli.net/2021/08/23/oVMRWeHnjvBiQts.png" alt="image-20210823144947655"></p><p><img src="https://i.loli.net/2021/08/17/FkMHaIshBt16L2u.png" alt="image-20210817124132516"></p><p><img src="https://i.loli.net/2021/08/17/5WYBRwQCAFiJSX1.png" alt="image-20210817124448067"></p><p><img src="https://i.loli.net/2021/08/17/myFVkjlzWo9Qqaf.png" alt="image-20210817124522371"></p><p><img src="https://i.loli.net/2021/08/17/AdFNT2hZKYLugvj.png" alt="image-20210817125833283"></p><p><img src="https://i.loli.net/2021/08/17/bctQNhBHfzeZjSu.png" alt="image-20210817125856517"></p><p><img src="https://i.loli.net/2021/08/17/Xdn1QlZiRNFBe92.png" alt="image-20210817130015387"></p><p><img src="https://i.loli.net/2021/08/17/EkxyoOfraPKtVCL.png" alt="image-20210817151023282"></p><p><img src="https://i.loli.net/2021/08/17/2i4q8EwjXzWOJaS.png" alt="image-20210817151538185"></p><p><img src="https://i.loli.net/2021/08/17/gws5vyhdDlAVHME.png" alt="image-20210817151653872"></p><p><img src="https://i.loli.net/2021/08/17/GiaCysjM12fpD3c.png" alt="image-20210817151920134"></p><p><img src="https://i.loli.net/2021/08/17/FwCWvUabtzoi235.png" alt="image-20210817152053701"></p><p><img src="https://i.loli.net/2021/08/17/lRNWFgMXn8DGbhA.png" alt="image-20210817152317923"></p><p><img src="https://i.loli.net/2021/08/17/wZkbRajOPAflVGD.png" alt="image-20210817152514503"></p><p><img src="https://i.loli.net/2021/08/19/5kFy8Q3T2ASRv6E.png" alt="image-20210819101129843"></p><p><img src="https://i.loli.net/2021/08/19/3THSrn4ieAjZ9bw.png" alt="image-20210819101220088"></p><p>taken 人们认为</p><p><img src="https://i.loli.net/2021/08/19/SMvBZzK2dQ4Aqbf.png" alt="image-20210819101238022"></p><p><img src="https://i.loli.net/2021/08/21/ZJtHFw2lQjA9GYR.png" alt="image-20210821183807484"></p><p><img src="https://i.loli.net/2021/08/21/pFE1KNOhSTaBe6Q.png" alt="image-20210821183732049"></p><p><img src="https://i.loli.net/2021/08/19/QB2cH9xlZLirmJ4.png" alt="image-20210819110124297"></p><p><img src="https://i.loli.net/2021/08/19/HzI2iveLUOM6rtZ.png" alt="image-20210819111452246"></p><p><img src="https://i.loli.net/2021/08/19/kumdYiJpq62BfoR.png" alt="image-20210819112001453">取决于</p><p><img src="https://i.loli.net/2021/08/19/t841zPu6NbyaoHC.png" alt="image-20210819173012098"></p><p><img src="https://i.loli.net/2021/08/19/2i4cR1KzPQAJkLS.png" alt="image-20210819173214426"></p><p>-ing出现在句子开头，可能是表原因/伴随</p><p><img src="https://i.loli.net/2021/08/19/AO3c256BprweyWF.png" alt="image-20210819175123955"></p><p><img src="https://i.loli.net/2021/08/20/YSWj4m1OEet6xQ9.png" alt="image-20210820094858454"></p><p><img src="https://i.loli.net/2021/08/20/JXnB4TUGWuvKFC1.png" alt="image-20210820095018377"></p><p><img src="https://i.loli.net/2021/08/20/tCqoXOfLYacbiAD.png" alt="image-20210820112211016"></p><p><img src="https://i.loli.net/2021/08/20/ztswAONDpQfu9l6.png" alt="image-20210820102521124"></p><p><img src="https://i.loli.net/2021/08/20/tCqoXOfLYacbiAD.png" alt=""></p><p><img src="https://i.loli.net/2021/08/20/RaY4OEjkGPhfwdK.png" alt="image-20210820114447576"></p><p><img src="https://i.loli.net/2021/08/20/l8EOTXZwrDdKN4J.png" alt="image-20210820114658369"></p><p><img src="https://i.loli.net/2021/08/20/2n5cm84AlrxbKBI.png" alt="image-20210820114938932"></p><p><img src="https://i.loli.net/2021/08/20/bmg64ItlS8zOMuk.png" alt="image-20210820115054928"></p><p><img src="https://i.loli.net/2021/08/20/IZwqt1BN64vOfm7.png" alt="image-20210820115119600"></p><p><img src="https://i.loli.net/2021/08/20/9Nrtz6SUFnhRKoV.png" alt="image-20210820115330598"></p><p><img src="https://i.loli.net/2021/08/20/1OvF8aErdybK2iP.png" alt="image-20210820115340842"></p><p>take root深入人心；根深蒂固</p><p><img src="https://i.loli.net/2021/08/21/bB1VtXk94MnRZwQ.png" alt="image-20210821170135509"></p><p><img src="https://i.loli.net/2021/08/21/uoJIDtz1sWHYPve.png" alt="image-20210821170223722"></p><p>in view of the fact that = because</p><p><img src="https://i.loli.net/2021/08/21/TPvAIbGH76sxC9j.png" alt="image-20210821170541115"></p><p><img src="https://i.loli.net/2021/08/21/2XxqRnlEaUWpdut.png" alt="image-20210821172055226"></p><p>行为科学之所以发展缓慢，</p><p>三个微小错误（中文错别字）-&gt;0.5分</p><p>item物品；商品；项目；条款；依据；细节</p><p><img src="https://i.loli.net/2021/08/21/hevzO4EHXGaRgsn.png" alt="image-20210821174011433"></p><p>my answer :</p><p>因为我们对于他们的首要任务是让他们能够分享在日常生活中我们没能考虑到的问题，我们是否正在形成安全能力的权力。</p><p>revision:</p><p>既然我们对年轻人的主要任务是是他们在日常生活中懂得分享，那么我们禁不住得会去思考，我们是否具备确保他们获得这种能力的力量</p><p>business不能翻译为与商业、交易、业务相关的意思，要和them指代的内容搭配<br>business-&gt;&gt;行业、领域、责任、业务、生意、贸易</p><p>share in a common life：</p><p><img src="https://i.loli.net/2021/08/21/2MxoSf3hIRvKPTs.png" alt="image-20210821174828440"></p><p>can not help doing 禁不住做某事、情不自禁做某事</p><p><img src="https://i.loli.net/2021/08/21/yYGFd8iwcx4DrJo.png" alt="image-20210821175046567"></p><p>we在句子中一定是做主语，断句点</p><p><img src="https://i.loli.net/2021/08/21/akuZroEUzReOH5T.png" alt="image-20210821175630091"></p><p><img src="https://i.loli.net/2021/08/21/3Gw2fHeV7FU6PSy.png" alt="image-20210821175639679"></p><p><img src="https://i.loli.net/2021/08/21/vGD7iqgXLNuO52V.png" alt="image-20210821175729418"></p><p>through：通过；因为，由于；经历</p><p><img src="https://i.loli.net/2021/08/21/T1uIXZhzn3BmrQ8.png" alt="image-20210821175856401"></p><p>my translation：</p><p>因为<strong>群聊</strong>的显著发展，各地的人们正在感受新的<strong>想法</strong>，接触新的风俗和思想，而由于以上原因，政府通常被迫开始进一步的变革。</p><p>revision：</p><p>mass communication 大众传媒、大众通讯</p><p>wants 想要-&gt;需求，需要</p><p>be exposed to 接触；接受；面对</p><p>ideas 观点</p><p>be forced to 不得不….</p><p>still在比较级前，加强语气，可以不翻译</p><p>考研翻译原则：直译优先，本意优先</p><p>correct translation：</p><p>由于大众通讯的显著发展，各地的人们正感受到新的需求，接触到新的习俗和观点，然而，由于上述原因，政府通常不得不采取更进一步的革新</p><p><img src="https://i.loli.net/2021/08/21/VOSnLXR2hFEWPCJ.png" alt="image-20210821182152370"></p><p><img src="https://i.loli.net/2021/08/21/e3w4niqXEONZcb7.png" alt="image-20210821182355598"></p><p><img src="https://i.loli.net/2021/08/21/eWj5rcaygNBYJGz.png" alt="image-20210821182516066"></p><p><img src="https://i.loli.net/2021/08/21/f3lj1VSxJdLZUoa.png" alt="image-20210821182539499"></p><p><img src="https://i.loli.net/2021/08/21/6ExwpWsAm7LbHaU.png" alt="image-20210821182633534"></p><p>=although</p><p>以上这些词：前用表“虽然”，后用表“但是”，从句一般翻译到主句前面。</p><p><img src="https://i.loli.net/2021/08/21/oh8iP2SGEJOBslL.png" alt="image-20210821182723468"></p><p><img src="https://i.loli.net/2021/08/21/bf1iujKSpaYQlhV.png" alt="image-20210821182743404"></p><p>my translation：</p><p>尽管律师的意见和反应可能会影响报道，但记者们最好依靠自己的关键想法并做出自己的判断。</p><p>revision：</p><p>notion 认识；观念</p><p>notion of …  -&gt; 对…的认识</p><p>correct translation：</p><p>尽管来自律师的意见和反馈可能会加强报道的质量，但对于记者而言，更可取的是，依靠自己的价值观（对重要性的认识）并做出自己的判断。</p><p><img src="https://i.loli.net/2021/08/21/BVx6PQSzKLgO5ov.png" alt="image-20210821184450378"></p><p><img src="https://i.loli.net/2021/08/21/o9zRGOqkxE3neBF.png" alt="image-20210821184540357"></p><p>上面这些没考过</p><p><img src="https://i.loli.net/2021/08/21/Z53BcqzDvx4ypVo.png" alt="image-20210821184650687"></p><p><img src="https://i.loli.net/2021/08/21/jViSkboG13rCEYP.png" alt="image-20210821184717594"></p><p><img src="https://i.loli.net/2021/08/21/IJLBqpks5eaMj6T.png" alt="image-20210821184747774"></p><p><img src="https://i.loli.net/2021/08/21/ehbi4vxLR8aDAgt.png" alt="image-20210821184848519"></p><p><img src="https://i.loli.net/2021/08/21/YJCz6F78uLOgrc5.png" alt="image-20210821184906566"></p><p>my translation：</p><p>如果<strong>这个</strong>小热点像期望的那样，那将是<strong>另一个</strong>科学<strong>思想</strong>的胜利，是被称为宇宙膨胀理论的大爆炸的改进/提升。</p><p>revision：</p><p>yet another 中yet表强调</p><p>hot pot-&gt;火锅</p><p>correct translation：</p><p>如果这些小热点看上去如预期那样，那将是又一科学理论的胜利及更完美的大爆炸理论，称之为宇宙膨胀理论。</p><p><img src="https://i.loli.net/2021/08/21/NAhJyOFkxjw5KM7.png" alt="image-20210821190117457"></p><p><img src="https://i.loli.net/2021/08/21/xBI4jgDqWcifOa8.png" alt="image-20210821190205447"></p><p><img src="https://i.loli.net/2021/08/21/gjOCwDdrFJ2eNzk.png" alt="image-20210821190334563"></p><p>acquisitive贪婪的</p><p>vulgar庸俗的; 粗俗的</p><p><img src="https://i.loli.net/2021/08/21/TojEsrVAhkgzXqY.png" alt="image-20210821190832259"></p><p><img src="https://i.loli.net/2021/08/21/xkb5orIXNByJfTm.png" alt="image-20210821190905791"></p><p><img src="https://i.loli.net/2021/08/21/hoUKTqJYpRmnaIf.png" alt="image-20210821191109500"></p><p>to the effect 大意是说(口语常见)</p><p><img src="https://i.loli.net/2021/08/21/dafERJUlZwAYWnS.png" alt="image-20210821191544703"></p><p>home appliance-&gt;家电</p><p>appliance-&gt;家电，器具</p><p>disorder-&gt;紊乱，失调，疾病</p><p>rage的心理学翻译——狂躁症</p><p>kitchen rage 厨房狂躁症</p><p><img src="https://i.loli.net/2021/08/23/p5mhwPJiVeFUz2D.png" alt="image-20210823144730405"></p><p>少用“被”字</p><p><img src="https://i.loli.net/2021/08/23/wAbxomRTgyjv5D8.png" alt="image-20210823145145737"></p><p><img src="https://i.loli.net/2021/08/23/xJ8cLtBo3q4ihZE.png" alt="image-20210823145209028"></p><p><img src="https://i.loli.net/2021/08/23/w5yzASsPEq9rt1Q.png" alt="image-20210823145524619"></p><p>my translation：</p><p>在转移时，传统的历史方法由额外的方法论扩大了，它用来解释历史研究中的新型证据</p><p>revision：</p><p>methodology ≈ historical method</p><p>designed to-&gt;旨在</p><p>correct translation：</p><p>在这种转化过程中，传统的历史研究方法上增加了新的历史研究方法，旨在解释历史研究中新的证据形式</p><p><img src="https://i.loli.net/2021/08/23/OrpMnPICwDhfyoB.png" alt="image-20210823151745872"></p><p><img src="https://i.loli.net/2021/08/23/SE2KYJleWLO4yTi.png" alt="image-20210823151758876"></p><p>my translation：</p><p>在一开始，它就导致讨论走向极端，它让你认为，动物应该被对待，从有着人类思维的一部分扩展到其他人类，甚至没有思维的</p><p>revision：</p><p>lead to-&gt;导致</p><p>lead ……to -&gt;把…引导向</p><p>either…or…-&gt;</p><p>consideration-&gt;关心</p><p>not…at all 一点也不</p><p><img src="https://i.loli.net/2021/08/23/gQDPt6UKpfirlCb.png" alt="image-20210823154808931"></p><p>correct translation：</p><p>这种观点从一开始就把讨论引向了极端，它让你（人们）认为，应该这样对待动物，要么像人类对待自己一样关心，要么一点也不关心。</p><p><img src="https://i.loli.net/2021/08/23/z2kwPfVxASHuB9t.png" alt="image-20210823155008808"></p><p>my translation：</p><p>一般来说，法律学习被看作律师特定知识储备的习惯，而非受教育人群知识储备的必要部分</p><p>传统上，人们将法律学习看作律师特定的知识储备，而非受教育人群知识储备所必须的一部分</p><p>revision：</p><p>institution-&gt;学院</p><p>correct translation：</p><p>传统上，这些学院把法律学习看作是律师的专长，而不是一个受过教育的人的知识储备的必要部分</p><p><img src="https://i.loli.net/2021/08/23/T7LBFiDxSv5qKol.png" alt="把...看作、认为"></p><p><img src="https://i.loli.net/2021/08/23/qDGpQrbsOcM694S.png" alt="image-20210823160523636"></p><p><img src="https://i.loli.net/2021/08/23/USjCuJ7mqxIWQBT.png" alt="image-20210823160557884"></p><p>my translation：</p><p>蘑菇云的存在事实上是需要大爆炸的，19世纪20年代的第一次投放，是为了维持其作为宇宙权威解释的统治地位</p><p>revision：</p><p>the giant clouds-&gt;巨大星云</p><p>be required for something to do对某人来说做某事是必要的</p><p>first put forward-&gt;首次提出</p><p>correct translation：</p><p>巨大宇宙云的存在实际上是20世纪20年代首次提出的大爆炸理论保持其作为对宇宙的主流解释所必须的</p><p><img src="https://i.loli.net/2021/08/23/mul4tKJhMQfpiPN.png" alt="image-20210823161835382"></p><p><img src="https://i.loli.net/2021/08/23/pWOgqkUG8xz7I3a.png" alt="image-20210823161915076"></p><p>my translation：</p><p>因此，在我们经过仔细考虑的广泛的教育过程中，它引导我们去辨别，一种更正式的教育—直接指导或者学校教育。</p><p>revision：</p><p>so far 迄今为止</p><p>correct translation：</p><p>因此，在我们迄今为止考虑到的更为宽泛的教育过程中，这使得我们去区别出，一种更为正式的教育形式，即直接教导或学校教育。</p><p><img src="https://i.loli.net/2021/08/23/Rni3Vuf8jNPdhvc.png" alt="image-20210823163623223"></p><p><img src="https://i.loli.net/2021/08/23/zbtajISeNudLT6i.png" alt="image-20210823172141550"></p><p>my translation：</p><p>仅在一百多年前，自然选择在进化中的作用就被确定，环境在形成和维持个体行为方面的选择性作用正开始被认识和研究</p><p>revisions：</p><p>formulate、articulate-&gt;阐明；阐述</p><p>correct translation：</p><p>自然选择在进化中的作用仅仅在一百多年前才得以阐明，在塑造和保持个体行为中环境的选择作用才刚刚加以认识和研究。</p><p><img src="https://i.loli.net/2021/08/23/2YjSkXmbJ5f9grH.png" alt="image-20210823173529840"></p><p>my translation：</p><p>这种情况发生时，这并没有错：这是人对行为道德推理的本能，这种本能应该得到鼓励而非嘲笑</p><p>revisions：</p><p>in action-&gt;起作用</p><p>correct translation：</p><p>当这种情况发生时，这不是一种错误：这是人类道德推理的本能在起作用，这种本能应该得到鼓励而不是遭到嘲笑</p><p><img src="https://i.loli.net/2021/08/23/x4iMGEjyC3cUWQD.png" alt="image-20210823180215200"></p><p>英语二：</p><p>先做英语一（2000-2010）的翻译题，每天一句翻译</p><p>2010-2021翻译题留到后面做模拟题</p><p><img src="https://i.loli.net/2021/08/23/7V8MowexIBSCJri.png" alt="image-20210823181533119"></p><p>additional 新的</p><p>就近修饰和一致原则（意思、逻辑一致）</p><p> <img src="https://i.loli.net/2021/08/23/Upcf4CPTjh29GZ5.png" alt="image-20210823181958135"></p><p>arise from 由……引起</p><p>取决于：</p><p><img src="https://i.loli.net/2021/08/23/epOdKgtNynsVIB2.png" alt="image-20210823182032387"></p><p><img src="https://i.loli.net/2021/08/23/KGUao6mZhRdrTQl.png" alt="image-20210823182334612"></p><p>断句、划线、拆分</p><p><img src="https://i.loli.net/2021/08/23/dlki2EquIwxHBgm.png" alt="image-20210823182737819"></p><p>my translation：</p><p>在南堡罗用地基探测器和球状仪器的天文学家正在研究这样的结构，并且可能在不久之后发表他们的发现</p><p>revision：</p><p><img src="https://i.loli.net/2021/08/23/PLMciqZvzb52AJp.png" alt="image-20210823183552655"></p><p>astrophysicist-&gt;天体物理学家</p><p>close in on-&gt;靠近、逼近-&gt;研究</p><p>south pole-&gt;南极</p><p>detective-&gt;警察；侦探</p><p>用多重并列定于修饰</p><p><img src="https://i.loli.net/2021/08/23/7zYwSv5WjpXnuEx.png" alt="image-20210823184219762"></p><p><img src="https://i.loli.net/2021/08/23/IDO3QNjRprKsZyV.png" alt="image-20210823184757596"></p><p><img src="https://i.loli.net/2021/08/23/uPLlp6RTdihSWYF.png" alt="image-20210823185019283"></p><p>correct translation：</p><p>用位于南极的陆基探测器和球载仪器的天体物理学家，他们正在研究这样的结构，并且不久就会报告他们的报告结果。 </p><p><img src="https://i.loli.net/2021/08/24/4e8kP5c2xHgVqdT.png" alt="image-20210824093625553"></p><p>my translation：</p><p>伽利略最大的成就是在1609年他是第一个将新发明望远镜转向天空证明行星围绕太阳而不是地球的人。</p><p>correct translation：</p><p>伽利略最伟大的成就在于，在1609年他是第一个用新发明的望远镜观察天空的人，以证明行星围绕太阳而不是地球旋转。</p><p><img src="https://i.loli.net/2021/08/24/zjKTHCYNEVey2gf.png" alt="image-20210824095510110"></p><p>my translation：</p><p>指向普遍历史工作或者研究技术的独特概念的方法论是否适合各种不同的历史研究分支，这个问题没有一致的答案。</p><p>revisions：</p><p>refer to-&gt;参考，引用-&gt;指</p><p>perculiar to</p><p><img src="https://i.loli.net/2021/08/24/SuYdO2vc9hoCbVe.png" alt="image-20210824101321097"></p><p><img src="https://i.loli.net/2021/08/24/y1sDHmCIxePuJad.png" alt="image-20210824101514800"></p><p>correct translation：</p><p>方法论是指一般历史研究所特有的概念，还是指适用于各种历史研究分支的研究方法，人们没有达成共识。</p><p><img src="https://i.loli.net/2021/08/24/MS5wHC2KYNP1rxT.png" alt="image-20210824102032470"></p><p>my translation：</p><p>他的作用与法官类似，必须接受在尽可能明显行为的推理课程中</p><p>revisions：</p><p><img src="https://i.loli.net/2021/08/24/cO5pW3rg2RKQXN8.png" alt="image-20210824102909936"></p><p>in manner 以…方式</p><p>correct translation：</p><p>（of短语太长了，拆分翻译）</p><p>他的作用类似于一个法官，他必须承担这样的责任：以尽可能明显的方式揭示导致他做决定的推理过程。</p><p><img src="https://i.loli.net/2021/08/24/tJiVCQDxIBraAsM.png" alt="image-20210824103603276"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 英语 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机程序设计大纲</title>
      <link href="/2021/07/11/ji-suan-ji-cheng-xu-she-ji/"/>
      <url>/2021/07/11/ji-suan-ji-cheng-xu-she-ji/</url>
      
        <content type="html"><![CDATA[<p>829 计算机程序设计</p><p>【考查目标】</p><ol><li><p>理解面向过程和面向对象程序设计的基本概念和方法，熟练掌握C++的基本语法和编程方法；理解和掌握C++语言的数据类型、运算符、控制语句及程序结构的基本概念和应用方法，能运用结构化程序设计思想正确地阅读程序、分析程序和编写程序；</p></li><li><p>具备基础算法实现能力和初步的面向对象分析和设计能力，能综合运用所学知识独立分析问题和解决问题，针对特定场景和上下文条件下中的应用问题，能设计合理算法并编制C/C++程序解决问题。</p></li></ol><p>【考查内容】</p><p>一、数据的定义</p><p>（一）基本类型</p><p>  1.常量</p><p>熟练掌握各种表示形式的整数、实数、字符(串)常量和符号常量的定义和使用。包括整数的十进制、八进制和十六进制的表示形式、长整型常量的表示形式、实数的浮点表示法和科学记数法、字符的转义序列以及常用符号常量的含义。</p><p>2.变量</p><p>熟练掌握变量的定义和初始化。</p><p>（二）构造类型</p><p>1.数组</p><p>熟练掌握一维和二维数组的定义和初始化，数组元素的引用。包括一维字符数组和字符串，二维字符数组和字符串数组。</p><p>2.结构</p><p>熟练掌握结构类型的定义，结构变量的定义和初始化，结构变量成员的引用及结构体数组和结构体指针的使用。</p><p>3.类</p><p>理解类和对象基本概念，掌握构造函数、类的继承和多态等典型应用。</p><p>（三）指针</p><p>1.熟练掌握指针和地址的概念</p><p>2.熟练掌握指针变量的定义和初始化</p><p>3.熟练掌握通过指针引用指向实体</p><p>（四）构造类型和指针类型的混合定义及应用</p><p>1.熟练掌握指针、数组和地址间的关系</p><p>2.熟练掌握指针数组</p><p>3.链表：掌握链表的建立和遍历、结点的插入和删除</p><p>（四）变量的存储类别、作用域和生存期</p><p>1.静态存储变量</p><p>2.掌握全局变量和局部变量</p><p>二、运算及流程控制</p><p>（一）基本运算</p><p>1.熟练掌握运算符的功能</p><p>2.熟练掌握运算符的优先级、结合性和目数</p><p>3.熟练掌握关系运算、逻辑运算以及逻辑表达式</p><p>（二）表达式</p><p>熟练掌握各类表达式的组成规则和计算过程</p><p>（三）语句</p><p>1.熟练掌握表达式语句、空语句、复合语句；</p><p>2.熟练掌握简单控制语句（break、continue、return）；</p><p>3.熟练掌握选择控制语句(if switch)</p><p>4.熟练掌握循环结构的设计以及for、while和do…while语句的使用。</p><p>三、程序结构和函数</p><p>（一）程序结构</p><p>1.熟练掌握main函数与其他函数之间的关系</p><p>2.包括标准库函数和自定义函数<br>（二）函数的定义</p><p>1.熟练掌握函数定义的ANSI C格式</p><p>2.熟练掌握函数的参数及参数传递，包括指针作为函数的参数</p><p>3.熟练掌握函数的返回值，包括指针作为函数的返回值</p><p>（三）函数的调用</p><p>1.函数调用的一般格式，掌握通过函数名调用函数，了解通过函数指针调用函数</p><p>2.掌握函数的嵌套调用和递归调用</p><p>3.熟练掌握标准库函数的调用</p><p>常用数学函数：cos、sqrt、pow、exp、fabs、log等</p><p>常用字符函数：isalnum、isalpha、isdigit、islower、toupper等</p><p>常用字符串函数：strcpy、strcmp、strcat、strlen等</p><p>四、数据的输入和输出</p><p>（一）文件：熟练掌握文件流的基本概念</p><p>（二）标准文件的输入和输出</p><p>（三）文件流操作 </p><p>1.熟练掌握文件的打开和关闭</p><p>2.熟练掌握文件的基本读写操作</p><p>3.熟练掌握文件的状态检测</p><p>五、类与面向对象</p><p>（一）类与对象基本概念</p><p>1.掌握类的定义方法,掌握类的数据成员和成员函数的定义方法；</p><p>2.掌握类的构造函数和析构函数的作用及使用方法；</p><p>3.掌握结构体和联合体的定义及使用；</p><p>4.熟悉类图的基本画法</p><p>（二）数据的共享与保护</p><p>1.熟悉标识符的作用域与可见性；</p><p>2.掌握类的静态成员和静态成员函数的定义方法；</p><p>3.熟悉类的友元作用及使用方法；</p><p>（三）继承与派生</p><p>1.理解继承的基本概念；</p><p>2.掌握如何通过继承建立类的层次结构；</p><p>六、常用算法</p><p>（一）分类（排序）算法</p><p>冒泡、选择、插入</p><p>（二）检索（查找）算法</p><p>1.无序数据序列的查找（见遍历算法）</p><p>2.有序数据序列的查找：二分法</p><p>（三）遍历算法</p><p>1.一维数组和二维数组的遍历</p><p>2.链表的遍历</p><p>3.文件的遍历</p><p>（四）字符串处理基本算法</p><p>1.比较</p><p>2.查找</p><p>3.插入、删除、截取</p><p>（五）穷举法、递归法、迭代法等算法</p><p>参考教材</p><p>1．谭浩强编著，C++程序设计(第三版)，北京：清华大学出版社，2015年</p><ol start="2"><li><p>郑莉，董渊，何江舟.C++语言程序设计(第4版), 北京：清华大学出版社，2010年</p></li><li><p>Bjarne Stroustrup，C++程序设计语言(特别版)，北京：机械工业出版社, 2010年</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 专业课 </tag>
            
            <tag> 829 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业实习-智能家居控制系统全记录</title>
      <link href="/2021/06/11/zhi-neng-jia-ju-kong-zhi-xi-tong-xiang-mu-zong-jie/"/>
      <url>/2021/06/11/zhi-neng-jia-ju-kong-zhi-xi-tong-xiang-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h2><p>段错误： C/C++<br>    segmentation  fault</p><p>内存的非法访问。　&lt;= 　段错误<br>    不能读的内存，你去读<br>    不能写的内存，你去写<br>    不是你的内存，你去访问</p><p>指针(数组)有误</p><p>​    int a[10];<br>​    int i = 11;</p><p>​        a[i] ;</p><p>​    int *p = NULL;</p><p>​    a = *p;<br>​    *p = 250;</p><p>​    int *p1;  //p1野指针<br>​        *p1;  =&gt; 内存的非法访问</p><p>一个进程运行过程中，出现段错误啦，操作系统是如何处理的呢？<br>    把这个进程给kill掉。</p><p>找段错误，比较容易：<br>    加打印。</p><p>​    printf(“abc\n”);   =&gt; abc</p><p>​    xxxx();</p><p>​    printf(“123\n”);</p><p>printf(“%s L_%d\n”, __FUNCTION__, __LINE__ );</p><p>​        __FUNCTION__  字符串，函数名<br>​        __LINE__     int, 当前行号<br>​        __FILE__    字符串，文件名</p><h1 id="Linux交叉开发环境搭建"><a href="#Linux交叉开发环境搭建" class="headerlink" title="Linux交叉开发环境搭建"></a>Linux交叉开发环境搭建</h1><h2 id="项目开发规范"><a href="#项目开发规范" class="headerlink" title="项目开发规范"></a>项目开发规范</h2><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>缩进问题</p><p>对齐问题</p><h3 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h3><p>模块化思想开发</p><p>文件夹规范</p><p>smart_home/ &lt;&lt;&lt;&lt;&lt; 包含项目的所有资料<br>                src/ &lt; —-包含工程源代码<br>                    main.c/main.h<br>                    lcd.c/lcd.h<br>                    ts.c/ts.h<br>                    ….</p><h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><p>GCC:GNU C Compiler</p><p>编译器：xxx-yyy-gcc均为跨平台的交叉编译器，如arm-Linux-gcc为目标平台为arm，编译平台为Linux，编译语言为c语言的编译器。</p><p>如何解决各平台，如Windows、Linux、arm平台之间的文件传输问题？<br>A：Windows与Linux：共享文件夹功能<br>        Windows与arm：串口的xModern协议传输文件</p><p>下载程序<br>        rx : receive xModern<br>            用串口的xModern协议来接收文件<br>如:<br>        rx  smart_home</p><p>​    改变可执行文件的权限<br>​    chmod +x  smart_home</p><p>​        eXcute</p><p>运行可执行程序</p><p>​    ./可执行程序</p><p>什么是终端(terminal) ?<br>        A 硬件  B 软件<br>        终端是介于用户和OS内核之间的桥梁软件。它接收用户输入的命令，<br>        并解析命令，提交给OS执行，并把OS执行命令的结果反馈给用户。</p><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p>几条基本的常用的linux命令：<br>    （1）linux文件系统<br>        linux文件系统是“树”的形式结构的。<br>            绝对路径:<br>                指根目录“/”开始的路径。<br>                如：<br>                    /home/gec/1.txt</p><p>​            系统认识文件是以 绝对路径 来识别的。<br>​        相对路径：<br>​            不以根目录”/“开始的路径。</p><p>​            working directory 工作目录/当前目录<br>​            在linux下每个进程都会有一个“当前目录”</p><p>​            如：<br>​                假设你的当前目录 为 /home<br>​                此时，你可以用目录：<br>​                    gec/1.txt  –&gt; /home/gec/1.txt</p><p>​                当前目录+相对路径 ＝〉 绝对路径</p><p>​            操作系统会自动为每个目录创建两个子目录<br>​                ./  代表的是当前路径<br>​                ../  代表的是上一级路径</p><p>（2）cd<br>     change directory 改变目录</p><p>​     语法：<br>​         cd  目录名<br>​             目录名代表的是你要切换到的那个目录<br>​             目录名指定可以用 绝对路径，也可以用相对路径</p><p>（3） ls<br>      list  列举。列举一个目录或文件的信息</p><p>​      ls  目录<br>​      ls<br>​          列举当前目录的文件信息</p><p> (4) pwd<br>      print  working directory<br>      输出当前工作目录的完整的路径名</p><p> (5) 创建目录mkdir<br>               make  directory创建目录的</p><pre><code>   mkdir  要创建的目录名           目录名可以用绝对路径指定，也可以用相对路径   mkdir   -p   要创建的目录名           -p parent 双亲           如果要创建的目录的父目录(父目录的父目录,...)没有，则一并创建。</code></pre><p> (6) 删除文件或目录<br>       rm  remove</p><pre><code>   rm  -rf   要删除的文件名或目录</code></pre><p> （7） 创建新的空的普通文件<br>       touch</p><pre><code>   语法：       touch  要创建的普通文件的文件名(可以多个，多个的话以空格隔开)   例子：        touch main.c  main.h  lcd.c lcd.h ts.c  ts.h  detect.c detect.h</code></pre><p> （8） 工程编译命令<br>      make<br>          但是make的正确运行离不开一个配置文件 Makefile/makefile</p><pre><code>  用法：      make clean 清除中间文件和可执行文件      make  自动进行编译工作              这一步如果没有语法错误，则会最终生成可执行文件  如：       －〉 smart_home</code></pre><h1 id="LCD屏幕的使用"><a href="#LCD屏幕的使用" class="headerlink" title="LCD屏幕的使用"></a>LCD屏幕的使用</h1><p>Linux下一切皆文件，屏幕的使用同样是操作文件的过程。</p><h2 id="LCD屏幕原理"><a href="#LCD屏幕原理" class="headerlink" title="LCD屏幕原理"></a>LCD屏幕原理</h2><p>分辨率：800*480 480P<br>             1920*1080 1080P<br>             1080*720 720P<br>             2K<br>             4K<br>         由480行 每行有800个像素点来组成</p><pre><code> 像素点（piexl）是什么？ 像素点就是能显示某种颜色的店  在屏幕上显示图像 是不是就是给每个像素点一个颜色 颜色如何描述的 红色 RED .... 如何统一 各种颜色其实由三基色组成 red green blue  red的程度不一样 怎么来描述呢？ 量化：数量化 read  * ** read  green blue  255   0      0     耀世红  0    255      0    原谅绿  0     0     255    天空蓝 RGB：占3个字节 0xff0000 “透明度” 一个像素点由4个字节来描述的 ARGB： A 透明度 0~255 ARGB:0x00 00 00 00 ==&gt; int  </code></pre><h2 id="Linux层次"><a href="#Linux层次" class="headerlink" title="Linux层次"></a>Linux层次</h2><p>中间层OS<br>        对上应用层提供操作硬件的接口函数，并且屏蔽实现的细节<br>于是我们就有人提出在内存上开辟一段缓冲区，用来保存屏幕上的每一个像素点的颜色值，然后应用程序直接把要显示的图像的颜色值直接写入到这块内存上即可。<br>    buffer至少要多大：480*800*4<br>    这种缓冲区，我们在Linux下面称之为：帧缓冲 fram buffer === fb<br>帧缓冲设备是对图像设备的一种抽象，它让上层应用不必关心具体的实现的细节，上层应用只需要在帧缓冲中填上合适的颜色值即可。<br>然后帧缓冲的驱动按一定的刷新频率，把颜色值在屏幕上正确的显示即可。以上就是帧缓冲的原理。</p><p>​    6818开发板上：屏幕 /dev/fb0 </p><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p>​        系统IO<br>​        标准IO<br>​        命令man<br>​            查看帮助文档，linux提供了API函数的帮助文档（说明文档）<br>​            eg：<br>​                man printf<br>​            可选项-f 显示所有的相关的页<br>​            查看具体那一页：直接man + 页数<br>​            eg:<br>​                man 3 printf<br>​        操作文件<br>​            打开、关闭、读、写<br>​        a.open close<br>​        open–打开文件<br>​        NAME<br>​        open, openat, creat - open and possibly create a file</p><p>​    SYNOPSIS<br>​           #include &lt;sys/types.h&gt;<br>​           #include &lt;sys/stat.h&gt;<br>​           #include &lt;fcntl.h&gt;</p><p>​           int open(const char *pathname, int flags);<br>​      函数功能：打开文件<br>​      函数参数：<br>​          pathname:文件路径名，可以是绝对路径也可以是相对路径<br>​          flags:标志位，文件以什么权限打开<br>​              O_RDONLY：只读 open_read_only<br>​              O_WRONLY：只写<br>​              O_RDWR：可读可写<br>​          三个标志只能选其一<br>​      返回值：<br>​          成功，返回一个文件描述符(&gt;0)<br>​          失败，返回-1，并且errno被设备。<br>​          同学    槟榔<br>​         0     买到了<br>​         -1    没买到<br>​         -2    被抓到了<br>​         -3    槟榔被吃光了<br>​         ….<br>​         errno<br>​         可以由perror来解释<br>​         NAME<br>   perror - print a system error message</p><p>​    SYNOPSIS<br>​           #include &lt;stdio.h&gt;</p><p>​           void perror(const char *s);<br>​           eg:<br>​               perror(“binglang:”);<br>​           在屏幕打印：<br>​               槟榔：错误信息\n<br>​    代码举例：<br>​        int fd = open(“1.txt”,O_RDWR);//以可读可写打开文件<br>​        if(fd&lt;0)<br>​        {<br>​            perror(“open fail”);<br>​            return ;<br>​        }</p><p>​    b.close<br>​    NAME<br>       close - close a file descriptor</p><p>​    SYNOPSIS<br>​           #include &lt;unistd.h&gt;</p><p>​           int close(int fd);<br>​           fd:文件描述符是open的返回值</p><p>​    c.read<br>​    NAME<br>​    read - read from a file descriptor</p><p>​    SYNOPSIS<br>​           #include &lt;unistd.h&gt;</p><p>​           ssize_t read(int fd, void *buf, size_t count);</p><p>​    函数功能：<br>​        从一个已经打开的文件中读 count个字节，放到buf所指向的空间中去。<br>​    函数参数：<br>​        fd:<br>​        buf:<br>​        count:<br>​      PS:void* 空指针<br>​      PS:const C语言关键字，所修饰的变量，告诉系统不能轻易的去改变。为了提升程序健壮性。<br>​     函数返回值：<br>​         成功，返回成功读取到字节数，文件偏移量（光标）会随之增加<br>​         失败，返回-1，并且errno被设置</p><p>​    d.write<br>​        NAME<br>   write - write to a file descriptor</p><p>​    SYNOPSIS<br>   #include &lt;unistd.h&gt;</p><p>   ssize_t write(int fd, const void *buf, size_t count);<br>   函数功能：<br>   从buf所指向的空间里面取count个字节写到fd中去<br>   函数参数：<br>           fd:<br>           buf:<br>           count:<br>   函数返回值：<br>       成功，返回成功写入的字节数，文件偏移量（光标）会随之增加<br>       失败，返回-1，并且errno被设置</p><pre><code>   e.lseek   NAME   lseek - reposition read/write file offset</code></pre><p>​    SYNOPSIS<br>​           #include &lt;sys/types.h&gt;<br>​           #include &lt;unistd.h&gt;</p><p>​           off_t lseek(int fd, off_t offset, int whence);<br>​          函数功能：重定位光标<br>​          函数参数：<br>​              fd:<br>​              offset:要设置的偏移量<br>​              whence:定位光标<br>​          SEEK_SET：以文件的开头定位  offset&gt;0<br>​              The file offset is set to offset bytes.</p><p>​           SEEK_CUR：以当前光标位置进行定位 offset可正可负<br>​                  The file offset is set to its current location plus offset bytes.</p><p>​           SEEK_END：以文件末尾进行定位 offset可正可负<br>​                  The file offset is set to the size of the file plus offset bytes.<br>​        返回值：<br>​            成功返回新的光标位置相对于文件开头的偏移量（单位字节）<br>​            失败，返回-1，并且errno被设置<br>​       作业一：<br>​               使用lseek来求文件大小。</p><p>​       作业二：<br>​               在开发板屏幕上显示德国国旗。</p><p>​       作业三：<br>​               在开发板屏幕上显示太极图案</p><h1 id="BMP图片显示"><a href="#BMP图片显示" class="headerlink" title="BMP图片显示"></a>BMP图片显示</h1><h2 id="Linux帧缓存驱动"><a href="#Linux帧缓存驱动" class="headerlink" title="Linux帧缓存驱动"></a>Linux帧缓存驱动</h2><p>物理屏幕分辨率:<br>        800*480</p><p>​    屏幕由480行，且每行有800个像素点组成。<br>​    每个像素点可以颜色一个标准的颜色:<br>​        ARGB8888<br>但是每个不同的屏幕，显示时序、接口等等都不一样，<br>那如果这样，我应用程序如果要显示一个颜色，还要根据不同<br>的屏幕，去组织不同的代码，这个是不是就很麻烦。</p><p>​    从应用角度来说：<br>​        “我（应用工程师）认为，所以的显示屏都应该是一样的，<br>​        因为我用它就是用来显示某个颜色”</p><p>为了实现这个：<br>    Linux内核特地引入 “帧缓冲”</p><p>​    在内核开辟了一个 Frame Buffer,用来保存显示屏上每一个像素<br>​    点的颜色(从上至下，从左至右)    </p><p>​    应用程序只需要把准备好的颜色值数据，拷贝到frame buffer,<br>​    然后　帧缓冲驱动，会按照一定的刷新频率、按照特定的屏幕显示<br>​    的要求、接口、时序……把颜色值正确地显示到屏幕上去。</p><p>​    对上（应用）屏蔽了具体的硬件实现细节。</p><p>－－－－－－－－－－－－－－－－<br>    frame buffer本质就是一块内存<br>    显示任何图像都是直接去操作这块内存<br>－－－－－－－－－－－－－－－－－－－－－</p><p>可以通过指针去操作这个frame buffer,进而就可以通过指针去显示图像！！！</p><p>int *plcd; //假设　让plcd指向linux内核帧缓冲的首地址</p><p>​    *plcd = 0xff0000; //屏幕上第０行的第０点显示红色</p><p>​    *(plcd + 1) = 0xff0000;//屏幕上第０行的第1个点显示红色<br>​    *(plcd + 2) = 0xff0000;//屏幕上第０行的第２个点显示红色<br>​    …</p><p>​    如果是任意的一个点(x,y)如何通过　plcd来显示颜色呢?</p><p>​        (0,0)——————————-&gt;x<br>​        |<br>​        |<br>​        |<br>​        |        (x,y)<br>​        |<br>​        |</p><p>​        y</p><p>​        *(plcd + 800*y + x) = 0xff0000;</p><p>​    void lcd_draw_point(int x, int y, int color)<br>​    {<br>​        if (x &gt;= 0 &amp;&amp;　x &lt; 800 &amp;&amp;　y &gt;= 0 &amp;&amp; y &lt; 480)<br>​        {<br>​            *(plcd + 800*y + x) = color;<br>​        }</p><p>​    }</p><p>​    ….<br>​    关键点：<br>​        如何获取linux内核帧缓冲的首地址呢？</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存函数：</p><p>mmap: memory map</p><p>NAME<br>   mmap, munmap - map or unmap files or devices into memory</p><p>SYNOPSIS<br>       #include &lt;sys/mman.h&gt;</p><pre><code>       mmap用来把内核和文件的内存，映射到应用程序空间。       目的是让应用程序通过指针直接去访问内核、驱动、文件的内容。</code></pre><p>   void* mmap(void *addr, size_t length, int prot,<br>               int flags,   int fd, off_t offset);<br>　　　<br>           addr: 地址，表示您要映射到哪个位置上去。<br>               有人说，我怎么知道映射到哪个位置上去。<br>               一般的人不知道，所以此处可以填　NULL,表示让<br>               操作系统自动分配。<br>           length:<br>               要映射的内存区的长度，如:    800*480*4<br>           prot: 映射区的权限，如下:<br>                   PROT_READ<br>                   PROT_WRITE: 可读可写<br>                   PROT_EXEC : excute,可执行<br>                   PROT_NONE<br>           flags: 映射标志。<br>                   MAP_SHARED  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>                   MAP_PRIVATE</p><pre><code>       fd :文件描述符，表示您要映射哪个文件。       offset:偏移量，表示您要从文件的哪个位置开始映射   返回值：       成功，返回映射区的首地址。       失败，返回MAP_FAILED</code></pre><p>​       munmap解映射。<br>   int munmap(void *addr, size_t length);<br>           addr:要解映射的地址<br>           length:长度<br>           返回值：<br>               成功返回０<br>               失败返回其他值</p><h2 id="BMP图片解析及显示"><a href="#BMP图片解析及显示" class="headerlink" title="BMP图片解析及显示"></a>BMP图片解析及显示</h2><p>bitmap ，位图文件, microsoft。<br>    是一种无压缩的图片格式　。</p><p>每一张ＢＭＰ图片文件　，可以分为如下四个部分:</p><p>BITMAP文件头<br>        14bytes</p><p>DIB文件头<br>        40bytes<br>        0x12处的４个字节</p><p>width:<br>        int width;<br>        lseek(fd, 0X12, SEEK_SET);<br>        read(fd, &amp;width, 4);</p><p>​        width &gt; 0<br>​            每一行的像素点的数据是从左至右保存的</p><p>​        width &lt; 0<br>​            每一行的像素点的数据是从右至左保存的</p><p>height:<br>        0x16处的４个字节<br>        int height;<br>        lseek(fd, 0x16,SEEK_SET);<br>        read(fd, &amp;height, 4);</p><p>​        height &gt; 0<br>​            先保存了是最底下一行的数据，　从下至上保存每一行<br>​        height &lt; 0<br>​            先保存了最上面一行的数据，从上至下保存每一行</p><p>depth:<br>        色深。指的是每个像素点数据所占的bits位数。<br>            １，　２，　４，　８，　……。</p><p>​        depth = 24<br>​            RGB888</p><p>​        depth = 32<br>​            ARGB8888</p><p>调色板<br>        标准的图片(depth=24 or 32)，这一部分没有</p><p>像素数组<br>        保存了每一个像素点的颜色值。</p><p>​        如：<br>​            width &gt; 0<br>​            height &gt; 0<br>​            depth ＝　24</p><p>​            B G R (图片最左下角的那个点的颜色值)</p><p>思考:<br>    (1) 图片缩放功能</p><p>​    (2) 图片显示的动画功能</p><h1 id="字模"><a href="#字模" class="headerlink" title="字模"></a>字模</h1><p><img src="https://i.loli.net/2021/06/10/nyLq859cMCDaxHJ.png" alt="横向取模"></p><p><img src="https://i.loli.net/2021/06/10/KXglUh7IukFTo5M.png" alt="纵向取模"></p><p><img src="https://i.loli.net/2021/06/10/SqersaMNCzwLnBu.png" alt="纵向取模_多个字"></p><p><img src="https://i.loli.net/2021/06/10/1HMhlaYmOvifZXE.png" alt="字模图片"></p><h1 id="实现图片的动画显示效果"><a href="#实现图片的动画显示效果" class="headerlink" title="实现图片的动画显示效果"></a>实现图片的动画显示效果</h1><h1 id="线程和音乐播放"><a href="#线程和音乐播放" class="headerlink" title="线程和音乐播放"></a>线程和音乐播放</h1><h2 id="程序的运行方式"><a href="#程序的运行方式" class="headerlink" title="程序的运行方式"></a>程序的运行方式</h2><p>串行方式:<br>        先把程序１执行完毕，然后再执行程序２，……。</p><p>​    缺点:<br>​        CPU利用率非常低。</p><p>​        程序<br>​            S1 输入数据<br>​            S2 运算<br>​            S3 写回结果</p><p>​    为了提高ＣＰＵ利用率</p><p>并发方式　<br>    允许多个程序同时运行。</p><p>​    为了提高ＣＰＵ利用率，程序的运行采用并发的方式。<br>​    现代操作系统为了实现程序的并发方式，特地引入进程。</p><p>​    引入进程的目的是为了实现并发，让多个程序同时运行，<br>​    请问操作系统是如何达到这个目的呢？</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>程序：静态的概念<br>进程：动态的概念。<br>    进程就一个程序的执行过程。</p><p>​    Ready<br>​    Running<br>​    Blocking</p><p>​    进程是粗粒度的并发，<br>​    线程是细粒度的并发。线程是进程内部一条指令执行路径。<br>​            一个进程可以有多个线程，一个进程内部的多个线程<br>​            共享整个进程地址空间的。<br>​            一个进程内的线程通信　效率　要比　多个进程通信效率高。</p><h2 id="Linux线程创建"><a href="#Linux线程创建" class="headerlink" title="Linux线程创建"></a>Linux线程创建</h2><p>pthread: posix thread</p><p>NAME<br>       pthread_create - create a new thread</p><p>SYNOPSIS<br>       #include &lt;pthread.h&gt;</p><p>​       pthread_t　类型是用来描述一个线程信息，如：线程id,…<br>​                   　pthread_t的实例是用来　唯一标识一个线程的。</p><p>​       int pthread_create(pthread_t <em>thread,<br>​                               const pthread_attr_t *attr,<br>​                          void *(</em>start_routine) (void *),<br>​                          void *arg);</p><p>​                         thread:　指向的空间，用来保存线程id,<br>​                         attr: 用来指定线程的属性，一般此处填ＮＵＬＬ,<br>​                                 采用默认的线程属性。</p><p>​                         start_routine: 函数指针，指向“线程函数”<br>​                         arg:　将作为“线程函数”参数<br>​                  返回值：<br>​                      成功返回　０<br>​                      失败返回　-1,</p><p>​       Compile and link with -pthread.</p><pre class=" language-c"><code class="language-c">     例子<span class="token punctuation">:</span>         <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span>                  <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">task1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//while (1)</span>             <span class="token comment" spellcheck="true">//{</span>                      <span class="token comment" spellcheck="true">//    }</span>         <span class="token comment" spellcheck="true">//    system("madplay  xxx.mp3");</span>             <span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token function">sprintf</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> <span class="token string">"madplay %s"</span><span class="token punctuation">,</span> mp3_file_name<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">system</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>                  pthread_t tid<span class="token punctuation">;</span>         <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>             ret <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> task1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token punctuation">{</span>             <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">//...</span>         <span class="token punctuation">}</span></code></pre><h1 id="获取传感器数据"><a href="#获取传感器数据" class="headerlink" title="获取传感器数据"></a>获取传感器数据</h1><h2 id="上位机和下位机"><a href="#上位机和下位机" class="headerlink" title="上位机和下位机"></a>上位机和下位机</h2><p>在项目中，经常需要与其他的外部模块进行通信。<br>    通信双方，其中一方为上位机，另外一方为下位机。<br>    上位机：<br>            把性能比较强，大部分数据处理在上位机完成。</p><p>​    下位机：<br>​            功能比较单一，一般只负责数据采集的那一端。</p><h2 id="GY-39通信接口及协议"><a href="#GY-39通信接口及协议" class="headerlink" title="GY-39通信接口及协议"></a>GY-39通信接口及协议</h2><p>ＵＡＲＴ</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//串口所对应的文件名</span>    <span class="token macro property">#<span class="token directive keyword">define</span> COM2 "/dev/ttySAC1"</span>    <span class="token macro property">#<span class="token directive keyword">define</span> COM3 "/dev/ttySAC2"</span>    <span class="token macro property">#<span class="token directive keyword">define</span> COM4 "/dev/ttySAC3"</span></code></pre><p> (1)　open<br>      (2) 配置串口参数</p><pre class=" language-c"><code class="language-c">  <span class="token comment" spellcheck="true">//初始化串口</span>        <span class="token comment" spellcheck="true">//file: 串口所对应的文件名</span>        <span class="token comment" spellcheck="true">//baudrate：波特率</span>        <span class="token keyword">int</span> <span class="token function">init_serial</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> baudrate<span class="token punctuation">)</span>        <span class="token punctuation">{</span>             <span class="token keyword">int</span> fd<span class="token punctuation">;</span>            fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open device error:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">struct</span> termios myserial<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//清空结构体</span>            <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>myserial<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//O_RDWR               </span>            myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>CLOCAL <span class="token operator">|</span> CREAD<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置控制模式状态，本地连接，接受使能</span>            <span class="token comment" spellcheck="true">//设置 数据位</span>            myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CSIZE<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//清空数据位</span>            myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CRTSCTS<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//无硬件流控制</span>            myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">|</span><span class="token operator">=</span> CS8<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//数据位:8</span>            myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>CSTOPB<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//   //1位停止位</span>            myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>PARENB<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//不要校验</span>            <span class="token comment" spellcheck="true">//myserial.c_iflag |= IGNPAR;   //不要校验</span>            <span class="token comment" spellcheck="true">//myserial.c_oflag = 0;  //输入模式</span>            <span class="token comment" spellcheck="true">//myserial.c_lflag = 0;  //不激活终端模式</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>baudrate<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token number">9600</span><span class="token punctuation">:</span>                    <span class="token function">cfsetospeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B9600<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//设置波特率</span>                    <span class="token function">cfsetispeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B9600<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">115200</span><span class="token punctuation">:</span>                    <span class="token function">cfsetospeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B115200<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//设置波特率</span>                    <span class="token function">cfsetispeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B115200<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token number">19200</span><span class="token punctuation">:</span>                    <span class="token function">cfsetospeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B19200<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//设置波特率</span>                    <span class="token function">cfsetispeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B19200<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/* 刷新输出队列,清除正接受的数据 */</span>            <span class="token function">tcflush</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> TCIFLUSH<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 改变配置 */</span>            <span class="token function">tcsetattr</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> TCSANOW<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myserial<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> fd<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>  (3)read/write</p><p>  (4)close</p><p>－－－－－－－－－－－</p><p>​    上位机                             GY39<br>​            ———————-&gt;<br>​            cmd(0xA5, 0x83, 0x28)</p><p>​    GY39数据输出格式:</p><p>​        帧头　帧头　类型    　长度                         校验和<br>​        0xA5 0XA5　type     len  data1 data2 … dataN  checksu</p><h1 id="触摸屏输入事件获取"><a href="#触摸屏输入事件获取" class="headerlink" title="触摸屏输入事件获取"></a>触摸屏输入事件获取</h1><h2 id="Linux输入子系统的层次"><a href="#Linux输入子系统的层次" class="headerlink" title="Linux输入子系统的层次"></a>Linux输入子系统的层次</h2><p>模块化是一个系统的属性，把一个系统分为　高内聚、低耦合的模块。<br>        高内聚：把逻辑上相关的对象(概念)划分在一起<br>        低耦合：减少模块间的依赖</p><p>模块化不是结构化分析方法特有的，面向对象的分析方法也有。<br>        结构化分析方法　模块化是以子程序(子系统)为主<br>        面向对象分析方法　模块化是　类和对象　划分为主。</p><p>linux下所有系统识别的“输入设备”，都会生成一个标准的文件接口:</p><p>​        /dev/input/eventX(X=0,1,2,…)</p><p>我的输入设备对应的到底是哪个文件　？<br>    /proc/bus/input/devices<br>    上面这个文件里，把每个输入设备的信息保存起来.</p><p>读取事件的流程:</p><p>​    (1) open<br>​    (2) read  事件结构体 struct input_event<br>​    (3) 解析<br>​    (4) close</p><h2 id="事件结构体"><a href="#事件结构体" class="headerlink" title="事件结构体"></a>事件结构体</h2><p>struct input_event</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> input_event <span class="token punctuation">{</span>            <span class="token keyword">struct</span> timeval time<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//事件发生的时间</span>             __u16 type<span class="token punctuation">;</span>                     type代表事件的类型<span class="token punctuation">,</span>                         EV_KEY   按键类型                         EV_REL  relative 相对事件，如：　鼠标                                 相对于上一个点的位移<span class="token punctuation">(</span>x轴和y轴<span class="token punctuation">)</span>                         EV_ABS  absolute 绝对事件，如：　触摸屏事件                                 当前点的绝对坐标            __u16 code<span class="token punctuation">;</span>                    根据type的不同，code含义也不同。                    <span class="token keyword">if</span> type <span class="token operator">==</span> EV_KEY<span class="token punctuation">,</span>                         code就是相应按键的键值                             KEY_A                             KEY_B                             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             BTN_TOUCH                     <span class="token keyword">if</span> type <span class="token operator">==</span> EV_ABS<span class="token punctuation">,</span>                         code就是相应的绝对坐标                            ABS_X  x轴事件                            ABS_Y  y轴事件                            ABS_PRESSURE  压力事件            __s32 value<span class="token punctuation">;</span>                 根据type的不同，value含义也不同                     <span class="token keyword">if</span> type <span class="token operator">==</span> EV_KEY                         value  <span class="token number">1</span>  按下                         value  <span class="token number">0</span> 　弹起                     <span class="token keyword">if</span>  type <span class="token operator">==</span> EV_ABS                         <span class="token keyword">if</span> code <span class="token operator">==</span> ABS_X                              value　Ｘ轴的坐标值                         <span class="token keyword">if</span> code <span class="token operator">==</span> ABS_Y                             value  Y轴的坐标值                         <span class="token keyword">if</span> code <span class="token operator">==</span> ABS_PRESSSURE                             value  压力值                                 <span class="token operator">></span><span class="token number">0</span>  触摸屏按下                                 <span class="token operator">=</span><span class="token number">0</span>  弹起        <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h1 id="Linux灯光驱动调用"><a href="#Linux灯光驱动调用" class="headerlink" title="Linux灯光驱动调用"></a>Linux灯光驱动调用</h1><h2 id="驱动是什么？"><a href="#驱动是什么？" class="headerlink" title="驱动是什么？"></a>驱动是什么？</h2><p>Ａ　硬件　　　Ｂ　软件<br>　<br>　　应用程序是也是软件。</p><p>驱动是操作硬件的代码。驱动层次位于应用与硬件之间。<br>驱动对上提供操作硬件的接口，并且需要向应用屏蔽硬件<br>实现的细节。　驱动对下（硬件）检测/监测硬件上的改变或<br>状态的变化，并向上报告其状态。</p><p>驱动与应用程序有什么区别？</p><p>裸机驱动<br>ＢＳＰ驱动<br>linux驱动<br>windows驱动<br>……<br>    在不同的平台下写驱动，框架及方法有不一样的。</p><p>​    裸机驱动：<br>​        不跑操作系统。<br>​        你想怎么操作硬件，想提供什么接口给应用，都由你来写。</p><p>​    linux/widows驱动：<br>​        你必须按照linux/windows定义的框架，定义好的接口，去实现。</p><h2 id="驱动控制灯光"><a href="#驱动控制灯光" class="headerlink" title="驱动控制灯光"></a>驱动控制灯光</h2><p>open<br>    read/write/ioctl/….<br>    close</p><p>加载驱动:<br>    insmod   kobject_led.ko</p><p>卸载驱动：<br>    rmmod   kobject_led.ko</p><p>一旦加载成功，在开发板目录<br>    /sys/kernel/gec_ctrl/<br>生成<br>    led_d7<br>    led_d8<br>    led_d9<br>    led_d10<br>    led_all<br>    beep</p><p>​    控制 led_d7<br>​        open(“/sys/kernel/gec_ctrl/led_d7”, O_RDWR)</p><p>​        int on = 1; //写1到文件表示 写<br>​        write(fd, &amp;on,  4);</p><p>​        on = 0; //写0到文件表示 关<br>​        write(fd, &amp;on, 4);</p><pre><code>[root@GEC6818 /mnt]# mount -t nfs 192.168.3.16:/mnt/hgfs /mnt -o nolock //要注意虚拟机文件的权限问题</code></pre><p><img src="https://img2020.cnblogs.com/blog/2228564/202012/2228564-20201203204525247-456551250.png" alt="img"></p><p> 挂载成功，现在主机，虚拟机，开发板共享了同一个目录。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> 毕业实习 </tag>
            
            <tag> 实习 </tag>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业实习-Linux智能家居项目</title>
      <link href="/2021/06/01/bi-ye-shi-xi-linux-zhi-neng-jia-ju-xiang-mu/"/>
      <url>/2021/06/01/bi-ye-shi-xi-linux-zhi-neng-jia-ju-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>2021年6月1日，于长沙市学士桥粤嵌众创作毕业实习项目，项目为基于Linux的智能家居应用。</p><h2 id="Linux交叉编译环境搭建"><a href="#Linux交叉编译环境搭建" class="headerlink" title="Linux交叉编译环境搭建"></a>Linux交叉编译环境搭建</h2><h3 id="什么是Linux交叉编译环境？"><a href="#什么是Linux交叉编译环境？" class="headerlink" title="什么是Linux交叉编译环境？"></a>什么是Linux交叉编译环境？</h3><h3 id="为什么需要搭建Linux交叉编译环境？"><a href="#为什么需要搭建Linux交叉编译环境？" class="headerlink" title="为什么需要搭建Linux交叉编译环境？"></a>为什么需要搭建Linux交叉编译环境？</h3><h3 id="如何在Windows搭建Linux交叉编译环境？"><a href="#如何在Windows搭建Linux交叉编译环境？" class="headerlink" title="如何在Windows搭建Linux交叉编译环境？"></a>如何在Windows搭建Linux交叉编译环境？</h3><h3 id="搭建过程中的问题"><a href="#搭建过程中的问题" class="headerlink" title="搭建过程中的问题"></a>搭建过程中的问题</h3><p><a href="https://blog.csdn.net/luckysign/article/details/101915064" target="_blank" rel="noopener">https://blog.csdn.net/luckysign/article/details/101915064</a></p><h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p>Linux系统的文件系统是树的形式，Windows系统的文件系统是森林的形式。</p><p>绝对路径：以根目录为起始的路径地址，系统寻找文件是以绝对路径来识别的。</p><p>相对路径：working directory（工作目录、当前目录），在Linux下每个进程都有一个“当前目录”。</p><p>当前目录+相对路径 =》相对路径</p><p>操作系统会自动为每个目录创建两个子目录</p><p>./ =====》当前目录</p><p>../ ====》上一级目录</p><p>依此类推</p><h2 id="Linux根目录"><a href="#Linux根目录" class="headerlink" title="Linux根目录"></a>Linux根目录</h2><p>此部分见：Linux根目录详解-<a href="https://auntyang.tk/2020/05/17/linux-gen-mu-lu-xiang-jie/">https://auntyang.tk/2020/05/17/linux-gen-mu-lu-xiang-jie/</a></p><h2 id="Ubuntu-Terminal命令"><a href="#Ubuntu-Terminal命令" class="headerlink" title="Ubuntu-Terminal命令"></a>Ubuntu-Terminal命令</h2><p>这部分老师主要讲了cd ls pwd mkdir touch rm make等命令，讲的太细了，不列举，随便搜都能搜到。</p><p><img src="https://i.loli.net/2021/06/01/qhpW3HmeYKcurlR.png" alt="根目录文件结构"></p><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>Linux设计哲学：Linux下一切皆文件，同样LCD屏幕也是文件。</p><h2 id="操作LCD屏幕"><a href="#操作LCD屏幕" class="headerlink" title="操作LCD屏幕"></a>操作LCD屏幕</h2><h3 id="LCD显示原理"><a href="#LCD显示原理" class="headerlink" title="LCD显示原理"></a>LCD显示原理</h3><p>以实习使用的粤嵌6818实验开发板上的LCD为例：</p><p>分辨率：800*480    480P</p><p>由480行，每行800个像素点组成</p><p>像素点（piexl）：显示某种颜色的点，图像即为众多像素点显示的颜色构成。</p><p>如何描述颜色？</p><p>通过三基色（RGB）来描述各种颜色，颜色也有深浅明暗，通过RGB数值量化来描述。</p><p>RGB——》Red    Green    Bule</p><p>​                    255        0            0    极品红</p><p>​                        0        255        0    原谅绿</p><p>​                        0            0        255    蓝</p><p>RGB：占3个字节    0xff0000</p><p>颜色的透明度，一个像素点由4个字节描述：</p><p>ARGB：A为透明度，取值0~255</p><p>ARGB：0x00 00 00 00 ==&gt; int  </p><h3 id="LCD与Linux层次"><a href="#LCD与Linux层次" class="headerlink" title="LCD与Linux层次"></a>LCD与Linux层次</h3><p>中间层OS<br>        对上应用层提供操作硬件的接口函数，并且屏蔽实现的细节</p><p>​    于是我们就有人提出在内存上开辟一段缓冲区，用来保存屏幕上的每一个像素点的颜色值<br>​    ，然后应用程序直接把要显示的图像的颜色值直接写入到这块内存上即可。<br>​    buffer至少要多大：480*800*4</p><p>​    这种缓冲区，我们在Linux下面称之为：帧缓冲 fram buffer === fb </p><p>​    帧缓冲设备是对图像设备的一种抽象，它让上层应用不必关心具体的实现的细节<br>​    上层应用只需要在帧缓冲中填上合适的颜色值即可。</p><p>​    然后帧缓冲的驱动按一定的刷新频率，把颜色值在屏幕上正确的显示即可，</p><p>​    以上就是帧缓冲的原理。</p><p>​    6818开发板上：屏幕 /dev/fb0 </p><h2 id="Linux文件IO"><a href="#Linux文件IO" class="headerlink" title="Linux文件IO"></a>Linux文件IO</h2><p>文件IO分为：        系统IO、标准IO<br>man命令：查看帮助文档，linux提供了API函数的帮助文档（说明文档）<br>            eg：<br>                man printf<br>            可选项-f 显示所有的相关的页<br>            查看具体那一页：直接man + 页数<br>            eg:<br>                man 3 printf</p><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>基本的文件操作：打开、关闭、读、写</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>​        a.open close<br>​        open–打开文件</p><p>​        NAME<br>​        open, openat, creat - open and possibly create a file</p><p>​    SYNOPSIS<br>​           #include &lt;sys/types.h&gt;<br>​           #include &lt;sys/stat.h&gt;<br>​           #include &lt;fcntl.h&gt;</p><p>​           int open(const char *pathname, int flags);</p><p>​      函数功能：打开文件<br>​      函数参数：<br>​          pathname:文件路径名，可以是绝对路径也可以是相对路径<br>​          flags:标志位，文件以什么权限打开<br>​              O_RDONLY：只读 open_read_only<br>​              O_WRONLY：只写<br>​              O_RDWR：可读可写<br>​          三个标志只能选其一<br>​      返回值：<br>​          成功，返回一个文件描述符(&gt;0)<br>​          失败，返回-1，并且errno被设备。<br>​<br>​         errno<br>​         可以由perror来解释<br>​         NAME<br>   perror - print a system error message</p><p>​    SYNOPSIS<br>​           #include &lt;stdio.h&gt;</p><p>​           void perror(const char *s);<br>​           eg:<br>​               perror(“binglang:”);<br>​           在屏幕打印：<br>​               槟榔：错误信息\n<br>​    代码举例：<br>​        int fd = open(“1.txt”,O_RDWR);//以可读可写打开文件<br>​        if(fd&lt;0)<br>​        {<br>​            perror(“open fail”);<br>​            return ;<br>​        }</p><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>b.close<br>    NAME<br>       close - close a file descriptor</p><p>​    SYNOPSIS<br>​           #include &lt;unistd.h&gt;</p><p>​           int close(int fd);<br>​           fd:文件描述符是open的返回值</p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>c.read<br>    NAME<br>    read - read from a file descriptor</p><p>​    SYNOPSIS<br>​           #include &lt;unistd.h&gt;</p><p>​           ssize_t read(int fd, void *buf, size_t count);</p><p>​    函数功能：<br>​        从一个已经打开的文件中读 count个字节，放到buf所指向的空间中去。<br>​    函数参数：<br>​        fd:<br>​        buf:<br>​        count:<br>​      PS:void* 空指针<br>​      PS:const C语言关键字，所修饰的变量，告诉系统不能轻易的去改变。为了提升程序健壮性。<br>​     函数返回值：<br>​         成功，返回成功读取到字节数，文件偏移量（光标）会随之增加<br>​         失败，返回-1，并且errno被设置</p><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>d.write<br>        NAME<br>   write - write to a file descriptor</p><p>​    SYNOPSIS<br>   #include &lt;unistd.h&gt;</p><p>   ssize_t write(int fd, const void *buf, size_t count);<br>   函数功能：<br>   从buf所指向的空间里面取count个字节写到fd中去<br>   函数参数：<br>           fd:<br>           buf:<br>           count:<br>   函数返回值：<br>       成功，返回成功写入的字节数，文件偏移量（光标）会随之增加<br>       失败，返回-1，并且errno被设置</p><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><pre><code>   e.lseek   NAME   lseek - reposition read/write file offset</code></pre><p>​    SYNOPSIS<br>​           #include &lt;sys/types.h&gt;<br>​           #include &lt;unistd.h&gt;</p><p>​           off_t lseek(int fd, off_t offset, int whence);<br>​          函数功能：重定位光标<br>​          函数参数：<br>​              fd:<br>​              offset:要设置的偏移量<br>​              whence:定位光标<br>​          SEEK_SET：以文件的开头定位  offset&gt;0<br>​              The file offset is set to offset bytes.</p><p>​           SEEK_CUR：以当前光标位置进行定位 offset可正可负<br>​                  The file offset is set to its current location plus offset bytes.</p><p>​           SEEK_END：以文件末尾进行定位 offset可正可负<br>​                  The file offset is set to the size of the file plus offset bytes.<br>​        返回值：<br>​            成功返回新的光标位置相对于文件开头的偏移量（单位字节）<br>​            失败，返回-1，并且errno被设置<br>​       作业一：<br>​               使用lseek来求文件大小。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  fd<span class="token operator">=</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"1.txt"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token operator">=</span><span class="token string">"hello World"</span><span class="token punctuation">;</span>  <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>SEEK_END<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>SEEK_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>  <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num = %d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​       作业二：<br>​               在开发板屏幕上显示德国国旗。</p><p>​       作业三：<br>​               在开发板屏幕上显示太极图案</p><h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>每个不同的屏幕</p><h2 id="Frame-Buffer驱动显示"><a href="#Frame-Buffer驱动显示" class="headerlink" title="Frame Buffer驱动显示"></a>Frame Buffer驱动显示</h2><p>framebuffer本质就是一块内存，显示任何图像都是直接去操作该内存。</p><h2 id="BMP位图解析"><a href="#BMP位图解析" class="headerlink" title="BMP位图解析"></a>BMP位图解析</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>尝试Gec6818开发板的SSH连接，将开发板网口连入局域网后，需要知道ip地址，从路由器查看不显示（设备太多），想到用ipconfig命令，但ipconfig未得到响应，并且提示没有找到命令，实际上Gec6818使用的是busybox编译的命令集，与常规的Linux命令并不相同。</p><p>gec6818开发板上外网：<br>直接在终端输入 route add default gw 192.168.22.x dev eth0 ，(192.168.22.x是网关)回车可实现开发板临时上外网，开发板重启要重新输入并回车</p><p>查了一下，Linux中命令为ifconfig，查看网络信息</p><p>ifconfig命令执行后显示网卡eth0检测时没有IP地址，如何自行配置静态IP？<br>自己动手配置命令:  ifconfig eth0 IP地址 netmask 子网掩码<br>自动获取ip地址:  dhclient</p><p>之后需要输入passwd命令设置密码</p><p>关于-/bin/sh:xx(命令) not found  的几种原因：</p><p>1./bin/目录下没有这个命令；</p><p>2.bin/目录有这个命令，只是执行权限不够，或者程序执行权限不够；</p><p>3.程序需要的静态库或者动态库没有；</p><p>gec6818开发板-刷机教程v1.1<br><a href="https://wenku.baidu.com/view/27a29cf7ec630b1c59eef8c75fbfc77da3699775.html?rec_flag=default&amp;fr=pc_newview_relate-1001_1-1-wk_rec_doc-1001_1-3-27a29cf7ec630b1c59eef8c75fbfc77da3699775&amp;sxts=1622976780090" target="_blank" rel="noopener">https://wenku.baidu.com/view/27a29cf7ec630b1c59eef8c75fbfc77da3699775.html?rec_flag=default&amp;fr=pc_newview_relate-1001_1-1-wk_rec_doc-1001_1-3-27a29cf7ec630b1c59eef8c75fbfc77da3699775&amp;sxts=1622976780090</a></p><p>GEC6818开发板裸机教程<br><a href="https://wenku.baidu.com/view/b82b68d686868762caaedd3383c4bb4cf7ecb7e0.html?rec_flag=default&amp;fr=pc_newview_relate-1001_1-2-wk_rec_doc-1001_1-3-b82b68d686868762caaedd3383c4bb4cf7ecb7e0&amp;sxts=1622979148725" target="_blank" rel="noopener">https://wenku.baidu.com/view/b82b68d686868762caaedd3383c4bb4cf7ecb7e0.html?rec_flag=default&amp;fr=pc_newview_relate-1001_1-2-wk_rec_doc-1001_1-3-b82b68d686868762caaedd3383c4bb4cf7ecb7e0&amp;sxts=1622979148725</a></p><p>ARM6818开发板使用<br><a href="https://wenku.baidu.com/view/e20be461f02d2af90242a8956bec0975f565a434.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/e20be461f02d2af90242a8956bec0975f565a434.html</a></p><p>C语实现状态机<br><a href="https://www.cnblogs.com/lihuidashen/p/11510532.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihuidashen/p/11510532.html</a></p><p>通过ssh连接开发板之arm-linux下ssh的安装使用<br><a href="https://blog.csdn.net/buynow123/article/details/51917643" target="_blank" rel="noopener">https://blog.csdn.net/buynow123/article/details/51917643</a></p><p>配置SSH服务器到ARM开发板中使用（gec6818）<br><a href="https://blog.csdn.net/Chen_qi_hai/article/details/94648024" target="_blank" rel="noopener">https://blog.csdn.net/Chen_qi_hai/article/details/94648024</a></p><p>Linux的inode的理解<br><a href="https://blog.csdn.net/xuz0917/article/details/79473562" target="_blank" rel="noopener">https://blog.csdn.net/xuz0917/article/details/79473562</a></p><p>linux中Framebuffer的原理及实现机制<br><a href="https://blog.csdn.net/ce123_zhouwei/article/details/6705582?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162268233616780274199448%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162268233616780274199448&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-6705582.pc_search_result_cache&amp;utm_term=Linux+framebuffer%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/ce123_zhouwei/article/details/6705582?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162268233616780274199448%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162268233616780274199448&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-6705582.pc_search_result_cache&amp;utm_term=Linux+framebuffer%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87&amp;spm=1018.2226.3001.4187</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业实习 </tag>
            
            <tag> 实习 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产实习-STM32避障循迹小车项目</title>
      <link href="/2021/06/01/sheng-chan-shi-xi-stm32-dai-bi-zhang-gong-neng-de-xun-ji-xiao-che-xiang-mu/"/>
      <url>/2021/06/01/sheng-chan-shi-xi-stm32-dai-bi-zhang-gong-neng-de-xun-ji-xiao-che-xiang-mu/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> STM32 </tag>
            
            <tag> 生产实习 </tag>
            
            <tag> 循迹小车 </tag>
            
            <tag> 避障小车 </tag>
            
            <tag> 蓝牙模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线传感器网络必背习题</title>
      <link href="/2020/12/09/wu-xian-chuan-gan-qi-wang-luo-bi-bei-xi-ti/"/>
      <url>/2020/12/09/wu-xian-chuan-gan-qi-wang-luo-bi-bei-xi-ti/</url>
      
        <content type="html"><![CDATA[<p>填空题： </p><ol><li><p>传感器网络三大基本要素：<em>传感器<em>、</em>感知对象<em>、</em>观测者</em></p></li><li><p>传感器节点的基本功能模块包括： <em>数据采集模块</em> 、 <em>数据处理和控制模块</em> 、<br><em>通信模块</em> 、<em>供电模块*四个，其中 *通信模块</em> 能量消耗最大。</p></li><li><p>传感器节点通信模块的工作模式有 <em>发送</em> 、 <em>接收</em> 、 <em>空闲</em> 和 <em>睡眠</em> 。</p></li><li><p>无线传感器网络拓扑控制主要通过 <em>功率调节</em> 和 <em>睡眠调度机制</em> 两种方式实现。</p></li><li><p>传感器网络中的平面路由协议主要有 <em>洪泛路由</em> 、 <em>闲聊法</em> 、<em>SPIN</em> 等。</p></li><li><p>传感器网络中的路由协议按照节点在路由过程中是否有层次结构、作用是否有差异，可分为<br><em>平面路由协议</em> 和 <em>层次路由协议</em> 。</p></li><li><p><em>K-连通</em> 指至少去掉 k 个节点才能使网络不连通。</p></li><li><p><em>目标定位</em> 是确定网络覆盖范围内其他目标节点的坐标位置。</p></li><li><p>*无线传感器网络经典 MAC 协议是 <em>S-MAC*，它主要特征是<br>*提供良好的扩展性、减少节点能量消耗</em> 。</p></li><li><p>无线传感器网络根据覆盖目标不同，将覆盖算法分为 <em>点覆盖</em> 、 <em>面覆盖</em> 、<br><em>栅栏覆盖</em> 三种类型。</p></li><li><p>传感器网络拓扑结构包括 <em>平面网络结构</em> 、 <em>分级网络结构</em> 、 <em>混合网络结构</em><br>、<em>Mesh 网络结构</em> 四种。</p></li><li><p><em>洪泛</em> 路由协议是无线传感器网络中最基本、最简单的平面路由协议。</p></li><li><p>传感器网络中的路由协议按照传输过程中采用的路径多少分为： <em>单路径路由协议</em></p></li></ol><p>和 <em>多路径路由协议</em> 。</p><ol><li><p>无线传感器网络中节点部署方式主要分为 <em>确定性部署</em> 、 <em>随机性部署</em> 、<br><em>混合式部署</em> 三种。</p></li><li><p>实现传感器节点时间同步的同步消息包括 <em>单向消息交换</em> 、 <em>双向消息交换</em> 、<br><em>接收端-接收端同步</em> 三种。</p></li><li><p>无线传感器网络时间同步协议 TPSN 实现包括 <em>级别探索</em> 和 <em>同步</em> 两个阶段。</p></li><li><p>节点覆盖感知模型主要有 <em>布尔感知模型</em> 和 <em>概率感知模型</em> 。</p></li><li><p>混合网络拓扑结构中包括基本的 <em>平面</em> 和 <em>分级</em> 两种网络结构。</p></li><li><p>典型的覆盖算法包括 <em>最佳与最坏情况覆盖</em> 、 <em>圆周覆盖</em> 、和连通传感器覆盖等。</p></li><li><p>按源节点获取路径的方法： <em>主动路由协议</em> 、 <em>按需路由协议</em> 、 <em>混合路由协议</em><br>。</p></li><li><p>按节点参与通信的方式： <em>直接通信路由协议</em> 、 <em>平面路由协议</em> 、<br><em>层次路由协议</em> 。</p></li><li><p>按路由的发现过程： <em>以位置信息为中心的路由协议</em> 、 <em>以数据为中心的路由协议</em><br>。</p></li><li><p>无线通信介质主要包括 <em>无线电波</em> 、 <em>红外线</em> 、 <em>微波</em> 、 <em>卫星</em> 。</p></li><li><p>列举三个与距离无关的定位方法 <em>质心定位算法</em> 、 <em>凸规划定位算法</em> 、<em>APS<br>定位算法</em> 。</p></li><li><p>无线传感器网络传输层协议主要实现 <em>event-to-sink</em> 和 <em>sink-to-sensors</em><br>两种方式消息的传送。</p></li><li><p>根据信息的抽象程度，数据融合分为 <em>数据级融合</em> 、 <em>特征级融合</em> 、<br><em>决策级融合</em> 。</p></li><li><p>传感器网络节能的主要策略有 <em>休眠机制</em> 、 <em>数据融合机制</em> 。</p></li><li><p>常用的短距离无线通信技术包括 <em>蓝牙</em> 、<em>Zigbee<em>、</em>UWB<em>、</em>WIFI</em> 等。</p></li><li><p>*无线传感器网络接入 Internet 网络的方式有 <em>以太网</em> 、 <em>无线局域网</em> 、</p></li></ol><p><em>移动通信网</em> 、 <em>有线电视网</em> 等。</p><ol><li>名词解释：（只要给出缩写的全名中文意思，不需要解释）</li></ol><p>WSN：无线传感器网络</p><p>ISO：国际标准化组织</p><p>MAC：介质访问控制</p><p>RSSI：接收信号强度指示</p><p>ToA：（基于）到达时间定位法</p><p>TDoA：（基于）到达时间差定位法</p><p>AOA：（基于）到达角</p><p>LoS：视线传输/同步丢失</p><p>TDMA：时分复用/时分多址</p><p>SNEP：传感器网络加密协议</p><p>MST：最小生成树</p><p>LMST：本地最小生成树</p><p>RNG：相关（相对）邻近图</p><p>DRNG：有向相关（相对）邻近图</p><p>ARQ：自动重传请求</p><p>AP：接入点</p><p>CSMA/CA：带有冲突避免的载波侦听多路访问</p><p>PCF：点协调功能</p><p>DCF：分布式协调功能</p><p>RTS/CTS：请求发送/允许发送协议</p><p>WPAN：无线个人网络</p><ol><li><p>简答题：</p></li><li><p>简述无线传感器网络的定义及特点。</p></li></ol><p>定义：无线传感器网络是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络</p><p>特点：自组织性、以数据为中心、应用相关性、动态性、网络规模大、可靠性、集成化、协作方式执行任务</p><ol><li>简述无线传感器网络的关键技术包含哪些。</li></ol><p>关键技术：拓扑控制、路由协议、时间同步、定位技术、数据融合、异构网络的互联互通、信息安全技术、大结构关联协同处理数据</p><ol><li>简述无线传感器网络拓扑控制的定义及评价指标有哪些。</li></ol><p>定义：拓扑控制（topology<br>control）是一种协调节点间各自传输范围的技术，用以构建具有某些期望的全局特性（如，连通性）的网络拓扑结构，同时减少节点的能耗或增加网络的传输能力</p><p>评价指标：连通性、覆盖性、吞吐量、扩展性、鲁棒性</p><ol><li>简述无线传感器网络协议结构及各层功能。</li></ol><p>无线传感器网络协议由<strong>物理层、数据链路层、网络层、传输层和应用层</strong>组成</p><p><img src="https://s2.loli.net/2021/12/05/KUOqu3RQP1rfXHa.png" alt="图片"></p><ol><li>简述无线传感器网络安全需求有哪些。</li></ol><p>数据保密性、数据认证、数据完整性、数据实时性、密钥管理、真实性、扩展性、可用性、自组织性、鲁棒性等</p><ol><li>简述 S-MAC 协议工作方式以及优势与不足。</li></ol><p>S-MAC 协议是在 802.11MAC<br>协议的基础上，针对于传感器网络的节省能量的需求而提出的传感器网络的 MAC 协议;<br>通常情况下传感器网络的数据传输量少，节点协作完成共同的任务，网络内部能够进行数据的处理和融合以减少数据通信量，网络能够容忍一定程度的通信延迟;</p><p>工作机制：周期性侦听和睡眠、流量自适应侦听机制、串音避免、消息传递。</p><p>优点：</p><p>（1）采用流量自适应侦听机制，减少了网络中的传输延迟。</p><p>（2）通过睡眠机制减少了空闲侦听的能量消耗，实现简单。</p><p>缺点：</p><p>（1）竞争窗口固定导致在网络流量较大情况下，会造成网络吞吐量较低而能耗和时延较高。</p><p>（2）当网络负载较低的时候，由于 SMAC<br>协议采用固定的周期性侦听/睡眠机制，节能效果并不理想.</p><ol><li>简述 WSN 接入 Internet 的实现方式。</li></ol><p>以太网、无线局域网、移动通信网、有线电视网、卫星、5G</p><p>应用层网关</p><p>延时容忍网络</p><p>TCP/IP 覆盖传感器网络协议栈</p><p>传感器网络协议栈覆盖 TCP/IP</p><p>移动代理</p><ol><li>简述 WSN 路由协议的分类及分类标准有哪些（至少 3 种）。</li></ol><p>1、按源节点获取路径的方法：主动路由协议、按需路由协议、混合路由协议。</p><p>2、按节点参与通信的方式：直接通信路由协议、平面路由协议、层次路由协议。</p><p>3、按路由的发现过程：以位置信息为中心的路由协议、以数据为中心的路由协议。</p><ol><li><p>应用题：</p></li><li><p>画出无线传感器网络系统功能结构图，简单叙述各组成部分的功能及相关关系。</p></li></ol><p><img src="https://s2.loli.net/2021/12/05/qJd6y2YNeo4ZzPg.png" alt="图片"></p><p>传感器网络包括传感器节点，汇聚节点和管理节点</p><p>传感器节点大量部署在在某一监测区域内，节点以自组织的形式构成无线网络，以协作的方式实时感知、采集和处理网络覆盖区域的信息，并通过多跳的方式经由汇聚节点链路将整个区域的信息传送到远程控制管理中心，且远程控制管理中心也可以对网络节点进行实时监控和操作</p><ol><li>画出传感器网络的平面网络拓扑结构图（包含基站与普通节点），说明网络节点的工作方式，及优缺点。</li></ol><p><img src="https://s2.loli.net/2021/12/05/g7UqS4dzCYh6DOM.png" alt="图片"></p><p>平面网络结构所有节点为对等结构，具有完全一·致的功能特性，也就是说每个节点均包含<br>相同的 MAC、路由、管理和安全等协议。是无线传感器网络中最简单的一种拓扑结构</p><p>优点：网络拓扑结构简单，易维护，具有较好的健壮性</p><p>缺点：没有中心管理节点，采用自组织协同算法形成网络，组网算法复杂</p><ol><li>画出传感器网络的层次结构拓扑结构图（包含基站与普通节点），说明网络节点的工作方式，及优缺点。</li></ol><p><img src="https://s2.loli.net/2021/12/05/UVAzH132N7JdKQg.png" alt="图片"></p><p>特点（工作方式）：</p><p>(1)网络分为上层和下层两个部分，上层为中心骨干节点，下层为一般传感器节点</p><p>(2)通常网络可能存在一个或多个骨干节点</p><p>(3)所有骨干节点为对等结构</p><p>(4)分级网络通常以簇的形式存在</p><p>(5)网络拓扑结构扩展性好</p><p>优点：扩展性好，便于集中管理，可以降低系统建设成本，提高网络效率和可靠性</p><p>缺点：集中管理开销大，硬件成本高，一般节点不能直接通信</p><ol><li>简述 LEACH 协议实现过程。</li></ol><p>LEACH 是一种自适应分簇拓扑算法，它的执行是周期性的，每轮循环分为簇的建立</p><p>阶段和稳定的数据通信阶段。</p><p>簇的建立阶段：相邻节点动态地形成簇，随机产生簇头</p><p>数据通信阶段：簇内节点把数据发给簇头，簇头进行数据融合并把结果发给汇聚节点。</p><p>簇头耗能大，所以需要等概率选取簇头。使整个网络的能量负载达到均衡。</p><p>基本思想：网络周期地随机选择簇头，其它非簇头节点以就近原则加入相应簇头，形成虚<br>拟簇。簇内 节点将感知到的消息直接发送给簇头，由簇头转发给汇聚节点，簇头节点可<br>以将本簇内的 数据进行融合处理以减少网络传输的数据量</p><ol><li>简述基于节点度的功率控制算法实现过程（或伪代码），以本地平均算法为例说明。</li></ol><p>给定节点度的上限和下限，动态地调整节点发射功率,使节点的度数始终维持在度数的上限<br>和下限之间.LMA 算法利用局部信息来调整相邻节点的连通性,从而在保证网络连通的同时<br>使得节点间的链路具有一定的冗余性和扩展性。</p><p><img src="https://s2.loli.net/2021/12/05/jNemVhHafoDRuAg.png" alt="图片"></p><ol><li>简述无线传感器网络时间同步协议（TPSN）实现过程。</li></ol><p>传感器网络的时间同步协议(TPSN)是另一种传统的使用树结构组织网络的“发射端-接收端”同步方式。TPSN<br>同步有两个过程:级别探测阶段(在网络部署时执行)和同步阶段。</p><p>(1)级别探测阶段</p><p>这个阶段的目标是创建网络的分层拓扑结构,每个节点被分配了一个级别,根节点(例如一个配备了<br>GPS,可以通向外部世界的网关)驻留在级别 0。根节点通过发出一个 level_discovery<br>消息开始这个过程,这个消息包含了级别信息和发射者独有的身份信息。</p><p>(2)同步阶段</p><p>在同步阶段,TPSN 沿着在前一阶段建立起的分层结构的边缘使用双向同步机制,也就是每个<br>i 级节点会与处于 i-1 级的节点进行时钟同步。</p><p><img src="https://s2.loli.net/2021/12/05/YAmJe6oNHEchSQa.png" alt="图片"></p><ol><li>掌握基于 RSSI、TOA、TDOA、AOA 测距的理论基础及计算过程。</li></ol><p><img src="https://s2.loli.net/2021/12/05/QSZH6UqsXK5LyaW.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/14UaqCsmeugy9ri.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/81aBg62Qr5Xfs7h.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/xe1wsWBTEr6tYuo.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/5WXBpsVSMN2foLu.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/RxybcQvFsS4iPoq.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/I2qztME1JA9cTFG.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/KTuzP9hketRsSFC.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/vk5V1zYOSbyDRIj.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/gFN82fq7Ie5lYDX.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/Qq4mAEnYas7cwX5.png" alt="图片"></p><ol><li>掌握三边定位法、极大似然定位法理论基础及计算过程。</li></ol><p><img src="https://s2.loli.net/2021/12/05/ybICYZLXeAT8oWp.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/si56kBjzxvJI3cY.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/UcfJkrYe2P1lqTs.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/GmKSn37B16q4RCD.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/d5tcRe1qArjYwmz.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/u9wp2xFs7mtKOl5.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/u9wp2xFs7mtKOl5.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/3N2BLOEDSd5e8l6.png" alt="图片"></p><ol><li>**掌握 DV-Hop 定位实现过程。</li></ol><p><img src="https://s2.loli.net/2021/12/05/qJa6FEdfMKlxvkA.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/BoyVd8IYUERuALZ.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/riLZow4WMAPdYhe.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/Ceci2QUPqDyVAu1.png" alt="图片"></p><p><img src="https://s2.loli.net/2021/12/05/yDPTKBWmQo43jv5.png" alt="图片"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 无线传感器网络 </tag>
            
            <tag> 期末 </tag>
            
            <tag> wsn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大三阶段感受和生活</title>
      <link href="/2020/11/30/jie-duan-gan-shou/"/>
      <url>/2020/11/30/jie-duan-gan-shou/</url>
      
        <content type="html"><![CDATA[<p>d的</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 感受 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曼切斯特编解码</title>
      <link href="/2020/09/24/man-qie-si-te-bian-jie-ma/"/>
      <url>/2020/09/24/man-qie-si-te-bian-jie-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="曼切斯特码及数据帧的特征"><a href="#曼切斯特码及数据帧的特征" class="headerlink" title="曼切斯特码及数据帧的特征"></a>曼切斯特码及数据帧的特征</h1><p>在曼切斯特编码中，将一位时间一分为二：</p><p>位时间内发生低电平到高电平的变化表示‘0’<br>位时间内发生高电平到低电平的变化表示‘1’</p><p>由于跳变都发生在每个码元中间，接收端可以方便地利用它作为位同步时钟，所以曼切斯特编码也叫自同步编码。</p><p><img src="https://i.loli.net/2020/09/24/ZG8tMguzpyRK6bV.png" alt="曼切斯特编码"></p><p>从图中可以看出曼切斯特编码有以下特征：<br>1.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RFID射频技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> RFID射频技术 </tag>
            
            <tag> 曼切斯特码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信原理笔记</title>
      <link href="/2020/09/17/xian-dai-tong-xin-yuan-li/"/>
      <url>/2020/09/17/xian-dai-tong-xin-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="信息及其度量"><a href="#信息及其度量" class="headerlink" title="信息及其度量"></a>信息及其度量</h2><h3 id="消息与信息"><a href="#消息与信息" class="headerlink" title="消息与信息"></a>消息与信息</h3><p><strong>消息</strong>：包含信息的事物</p><p><strong>信息</strong>：消息中包含的有效内容</p><p>信息具有不确定性</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p><strong>信号</strong>是消息的载体，是一种电波形</p><p>信号分为<strong>模拟信号</strong>（连续信号）和<strong>数字信号</strong>（离散信号）</p><h4 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h4><p>模拟信号占有频带一般都比较窄，其频带利用率较高，缺点是抗干扰能力差，不易保密，设备元器件不易大规模集成。</p><h4 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h4><p>比模拟信号占据更宽的系统频带</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>1.抗干扰、抗噪声性能好</p><p>2.差错可控</p><p>3.易加密</p><p>4.数字通信设备和模拟通信设备相比，设计和制造更容易，体积更小，重量更轻</p><p>5.数字信号可以通过信源编码进行压缩，以减少冗余度，提高信道利用率。</p><p>6.易与现代技术相结合</p><h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p>信息量与消息的种类、特定内容及重要程度无关，仅仅与消息中包含的不确定度有关。消息发生的概率越小，该消息包含的信息量越大。消息发生的概率趋近于0，则其信息量趋近于无穷大。</p><p>信息论中，消息所含的信息量I与消息X出现的概率P(x)的关系为：<br>$$<br>I={log_a{\frac1{P(x)}}}=-{log_a{P(x)}}\<br>信息量的单位由对数底的取值决定\<br>a=2时单位为“比特”\<br>a=e时单位为“奈特”\<br>a=10时单位为“哈特”\<br>通常采用“比特”作为信息量的实用单位<br>$$<br>I代表两种含义：当事件X发送以前，表示事件X发送的不确定性；当事件X发生以后，表示事件X所含有的信息量。</p><p>设离散信息源是一个由n个符号组成的集合，符号集中的每个字符Xi在消息中是按一定概率P(xi)独立出现的，又设符号集中各符号出现的概率为<br><img src="https://i.loli.net/2020/09/18/HXBSv46tu9WnDxG.png" alt="符号集中各符号出现的概率"><br>改变信源每个符号所含的信息量的统计平均值，即平均信息量为：<br><img src="https://i.loli.net/2020/09/18/kNjnmK9FcaD14xO.png" alt="平均信息量"></p><p>连续消息的信息量可以用概率密度来描述，可以证明连续消息的平均信息量（相对熵）为：<br><img src="https://i.loli.net/2020/09/18/NWtygFpTISUoqhV.png" alt="连续消息的平均信息量"><br>f(x)是连续消息出现的概率密度</p><h2 id="通信系统"><a href="#通信系统" class="headerlink" title="通信系统"></a>通信系统</h2><h3 id="通信系统基本模型"><a href="#通信系统基本模型" class="headerlink" title="通信系统基本模型"></a>通信系统基本模型</h3><p><img src="https://i.loli.net/2020/09/18/6sGpvS4tWlzIw89.png" alt="通信系统的基本模型">信源：将消息转换为原始电信号（基带信号）。<br>发送设备：将输入的电信号变成适合信道传输的形式（调制、滤波、放大、发射）包含信源编码和信道编码。<br>信道：将信号从发送设备向接收设备传送的物理媒质，包含有线信道和无线信道。<br>接收设备：从带干扰的接收信号中恢复出相应的原始电信号（解调、滤波、抑制噪声）。<br>受信者（信宿）：将原始电信号转换成为消息。</p><p><strong>信源编码</strong>：可分为压缩编码和保密编码，提高数字信号传输的有效性，信源编码器输出的是信息码元，<strong>话音</strong>和<strong>图像</strong>压缩编码都是信源编码器完成的<br><strong>信道编码</strong>（纠错编码）：提高数字信号传输的可靠性，其基本做法是在信息码组中按一定的规则附加一些监督码元，以使接收端根据相应的规则进行检错和纠错<br><strong>数字调制</strong>：将所传输的数字序列的频谱搬移到合适信道传输的频带范围内，使其适应信道传输的要求，基本的调制方式有幅移键控（ASK）、频移键控（FSK）和相移键控（PSK）<br><strong>加性干扰</strong>：噪声叠加在信号上<br><strong>乘性干扰</strong>：<strong>多径传播</strong>是一种是信号质量降低的干扰，多径传播是信号振幅随机起伏的现象称为<strong>衰落</strong>。将这种衰落称为乘性干扰或乘性噪声。</p><p>在接收设备端的原始电信号还能称为基带信号吗？不是，带有噪声</p><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><h4 id="1-按信息传输的方向与时间关系划分通信方式"><a href="#1-按信息传输的方向与时间关系划分通信方式" class="headerlink" title="1.按信息传输的方向与时间关系划分通信方式"></a>1.按信息传输的方向与时间关系划分通信方式</h4><p>对于点对点之间的通信，按信息传送的方向与时间的关系，通信方式可分为单工通信，半双工通信及全双工通信<br>单工通信：广播、遥控、无线寻呼等<br>半双工通信：无线对讲机、收发报机等<br>全双工通信：电话、计算机网络通信等</p><p><img src="https://i.loli.net/2020/09/18/LuIPXo3K6DJkdN1.png" alt="通信方式示意图"></p><h4 id="2-按数字信号码元排列方式划分通信方式"><a href="#2-按数字信号码元排列方式划分通信方式" class="headerlink" title="2.按数字信号码元排列方式划分通信方式"></a>2.按数字信号码元排列方式划分通信方式</h4><p>在数字通信中按照数字码元排列顺序的方式不同，可将通信方式分为串行通信和并行通信。</p><p><img src="https://i.loli.net/2020/09/18/1qri29ZyIgY4uoV.png" alt="串并行通信方式"></p><h5 id="并行通信"><a href="#并行通信" class="headerlink" title="并行通信"></a>并行通信</h5><p>将代表信息的数字信号码元序列分割成两路或两路以上的数字信号序列同时在信道上传输。</p><p>优点：速度快、节省传输时间，但需占用频带宽，设备复杂，成本高，故较少采用，适用于短距离通信。</p><h5 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h5><p>将代表信息的数字信号码元序列按照时间顺序一个接一个地传输</p><p>适用于远距离传输</p><h4 id="3-按网络结构划分通信方式"><a href="#3-按网络结构划分通信方式" class="headerlink" title="3.按网络结构划分通信方式"></a>3.按网络结构划分通信方式</h4><p>线型、星型、树型、环形等等</p><h3 id="通信系统的分类"><a href="#通信系统的分类" class="headerlink" title="通信系统的分类"></a>通信系统的分类</h3><h4 id="1-按传输媒质分类"><a href="#1-按传输媒质分类" class="headerlink" title="1.按传输媒质分类"></a>1.按传输媒质分类</h4><p>有线通信系统和无线通信系统</p><h4 id="2-按信号的特征分"><a href="#2-按信号的特征分" class="headerlink" title="2.按信号的特征分"></a>2.按信号的特征分</h4><p>模拟通信系统和数字通信系统</p><h4 id="3-按工作频段分类"><a href="#3-按工作频段分类" class="headerlink" title="3.按工作频段分类"></a>3.按工作频段分类</h4><p>长波通信、中波通信、短波通信、微波通信</p><p><img src="https://i.loli.net/2020/09/18/hw6R9Vznq5vaC4g.png" alt="通信频段、常用传输媒质及主要用途"></p><p>工作波长和频率的换算公式为：<br>$$<br>\lambda=\frac cf=\frac{3x10^8}f\<br>其中\lambda为工作波长(m)，f为最高工作频率(Hz)，c为光速(m/s)<br>$$</p><h4 id="4-按调制方式分类"><a href="#4-按调制方式分类" class="headerlink" title="4.按调制方式分类"></a>4.按调制方式分类</h4><p>基带传输系统和频带（调制）传输系统</p><h4 id="5-按通信业务类型分类"><a href="#5-按通信业务类型分类" class="headerlink" title="5.按通信业务类型分类"></a>5.按通信业务类型分类</h4><p>电报通信系统、电话通信系统、数据通信系统和图像通信系统</p><h4 id="6-按信号复用方式分类"><a href="#6-按信号复用方式分类" class="headerlink" title="6.按信号复用方式分类"></a>6.按信号复用方式分类</h4><p>频分复用（FDM）、时分复用（TDM）、码分复用（CDM）通信系统</p><h3 id="模拟通信系统"><a href="#模拟通信系统" class="headerlink" title="模拟通信系统"></a>模拟通信系统</h3><p>传输模拟信号的系统，在信道中传输模拟信号。</p><p><img src="https://i.loli.net/2020/09/18/KIcStB6ZNRGlQiy.png" alt="模拟通信系统的模型"><br>发信人的语音信息经过变换器转变成电信号（<strong>模拟信源</strong>），然后由调制器放大后在信道中传输<br>原始电信号（基带信号）进行调制是为了<strong>提高频带利用率</strong>，使多路信号同时在信道中传输。<br>在接收端，经过解调器和你变换器还原成语音信息。</p><h3 id="数字通信系统"><a href="#数字通信系统" class="headerlink" title="数字通信系统"></a>数字通信系统</h3><p><img src="https://i.loli.net/2020/09/18/j2UzF1kDsOgeHcn.png" alt="image-20200918110926136"><br><strong>数字频带传输通信系统</strong>：；利用数字信号来传递信息的通信系统，分为数字频带传输通信系统和数字基带传输通信系统。<br>数字通信系统有一个非常重要的控制单元：同步系统，可以使通信系统的收、发两端或整个通信系统，以精度很高的时钟提供定时，以使系统数据流能与发送端同步、有序而准确地接受和恢复原信息<br>变换器：将信息转换成数字基带信号</p><p><img src="https://i.loli.net/2020/09/18/hs3LjT6tBmb9AU4.png" alt="数字基带传输系统模型"><br><strong>数字基带传输通信系统</strong>：与频带传输通信系统对应，把没有调制/解调器的数字通信系统称为数字基带传输通信系统<br>基带信号形成器：可能包含编码器、加密器以及波形变换等<br>接收滤波器：可能包含译码器、解密器等</p><h2 id="通信系统的性能指标"><a href="#通信系统的性能指标" class="headerlink" title="通信系统的性能指标"></a>通信系统的性能指标</h2><p>评价通信系统优劣的主要性能指标是系统的有效性和可靠性</p><p>有效性：指消息传输的“速度”问题<br>可靠性：指消息传输的“质量”问题</p><p>二者经常矛盾，反比</p><h3 id="模拟通信系统的性能指标"><a href="#模拟通信系统的性能指标" class="headerlink" title="模拟通信系统的性能指标"></a>模拟通信系统的性能指标</h3><p>模拟通信系统的有效性指标用所传信号的有效传输带宽来表征。当信道容许传输带宽一定，而进行多路频分复用时，每路信号所需的有效带宽越窄，信道内复用的路数越多</p><p><strong>信道复用的程度越高，信号传输的有效性越好</strong></p><p>信号的有效传输带宽与系统采用的调制方法有关</p><p>模拟通信系统的可靠性指标用整个通信系统的输出信噪比来衡量。信噪比是信号的平均功率S与噪声的平均功率N之比。<em>信噪比越高，说明噪声对信号的影响越小。显然，信噪比越高，通信质量就越好</em>。</p><p>输出信噪比一方面与信道内噪声的大小和信号的功率有关，同时又<em>和调制方式有很大关系</em>。例如宽带调频系统的有效性不如调幅系统，但是调频系统的可靠性往往比调幅系统好。</p><h3 id="数字通信系统的性能指标"><a href="#数字通信系统的性能指标" class="headerlink" title="数字通信系统的性能指标"></a>数字通信系统的性能指标</h3><h4 id="有效性指标"><a href="#有效性指标" class="headerlink" title="有效性指标"></a>有效性指标</h4><p>数字通信系统的有效性指标用传输速率和频带利用率来表征。</p><h5 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h5><p>传输速率有三种表示方式：<br>$$<br>码元传输速率R_B\信息传输速率R_b\消息速率R_M<br>$$</p><h6 id="码元传输速率"><a href="#码元传输速率" class="headerlink" title="码元传输速率"></a><strong>码元传输速率</strong></h6><p>简称传码率，又称符号速率等。它表示单位时间内传输码元的数目，单位是波特（Baud），记为B。<br>它表示单位时间内传输码元的数目，单位是波特（Baud），记为B。<br>例如，若1秒内传2400个码元，则传码率为2400B。<br>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与传输的码元长度T有关</p><p><img src="https://i.loli.net/2020/10/02/lADQnE2KjhVryNU.png" alt="符号(码元)传输速率"></p><h6 id="信息传输速率"><a href="#信息传输速率" class="headerlink" title="信息传输速率"></a><strong>信息传输速率</strong></h6><p>简称传信率，又称比特率等。它是指系统每秒钟传送的信息量，单位是比特/秒，常用符号“bit/s、bps或b/s”表示<br>它表示单位时间内传递的平均信息量或比特数<br>$$<br>在N进制下，设信息速率为R_b(bit/s)，码元速率为R_{BN}(Baud)，由于每个码元或符号通常\都含有一定比特的信息量，因此码元速率和信息速率有确定的关系，即:\<br>R_b=R_{BN}H(x)\ \ \ \ \ (bit/s)\<br>式中，H(x)为信源中每个符号所含的平均信息量（熵）。当离散信源的每一符号等概率出现\时，熵有最大值为{log_2N}(bit/符号),信息速率也达到最大，即：\<br>R_b=R_{BN}{log_2N}\ (bit/s)\<br>R_{BN}=\frac{R_b}{log_2N}\ (Baud)<br>$$</p><h6 id="消息速率"><a href="#消息速率" class="headerlink" title="消息速率"></a><strong>消息速率</strong></h6><p>单位时间内传输的消息数目。例如，传输中文文件时，消息速率的单位是“字/秒”</p><h6 id="码元速率与信息速率的关系"><a href="#码元速率与信息速率的关系" class="headerlink" title="码元速率与信息速率的关系"></a>码元速率与信息速率的关系</h6><p>每个码元或符号通常都含有一定bit数的信息量，因此码元速率和信息速率有确定的关系</p><p><img src="https://i.loli.net/2020/10/02/yPuq1p6LjRAflwv.png" alt="码元速率与信息速率的关系"></p><p>H为信源中每个符号所含的平均信息量（熵）<br><strong>M进制、等概率</strong>传输时，熵有最大值，信息速率也达到最大</p><p><img src="https://i.loli.net/2020/10/02/ZrAknGNFxgo9pj7.png" alt="![](https://i.loli.net/2020/10/02/ZrAknGNFxgo9pj7.png)"></p><p>码元速率为1200B<br>采用八进制（M=8）时，信息速率为3600b/s；<br>采用二进制（M=2）时， 信息速率为1200b/s，<br><em>二进制的码元速率和信息速率在数量上相等，有时简称它们为数码率。</em></p><h4 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h4><h5 id="错误率"><a href="#错误率" class="headerlink" title="错误率"></a>错误率</h5><p>衡量数字通信系统可靠性的指标是差错率， 常用误码率和误信率表示。<br>误码率（码元差错率Pe ）是指发生差错的码元数在传输总码元数中所占的比例，更确切地说，误码率是码元在传输系统中被传错的概率，即</p><p><img src="https://i.loli.net/2020/10/02/z6Wk1lIQCRxGocK.png" alt="误码率"></p><p>误信率（信息差错率Pb ）是指发生差错的比特数在传输总比特数中所占的比例， 即</p><p><img src="https://i.loli.net/2020/10/02/6AWBHUE1yjqcMTl.png" alt="误信率"></p><p>实际中分析误信率（二进制就是误码率），可用</p><p><img src="https://i.loli.net/2020/10/02/Dri6m3KL8IwaSPE.png" alt="实际中分析误信率"><br>Pe与Pb的关系：<br>    二进制—— Pb= Pe<br>    M进制—— Pb&lt; Pe</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 现代通信原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 现代通信原理 </tag>
            
            <tag> 扎实 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网竞赛实践之C#</title>
      <link href="/2020/09/07/c-wu-lian-wang-xiang-mu-shi-jian-quan-ji/"/>
      <url>/2020/09/07/c-wu-lian-wang-xiang-mu-shi-jian-quan-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基本"><a href="#C-基本" class="headerlink" title="C#基本"></a>C#基本</h1><p>C#是一种面向对象的编程语言。在面向对象的程序设计方法中，程序有各种相互交互的对象组成。相同种类的对象通常具有相同的类型，或者说，在同一Class中。</p><h2 id="C-代码基本结构"><a href="#C-代码基本结构" class="headerlink" title="C#代码基本结构"></a>C#代码基本结构</h2><h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><p>在任何C#程序中的第一条语句都是：</p><pre class=" language-c#"><code class="language-c#">using system</code></pre><p>using关键字用于在程序中包含命名空间，一个程序可以包含多个using语句。</p><h3 id="class关键字"><a href="#class关键字" class="headerlink" title="class关键字"></a>class关键字</h3><p>class关键字用于声明一个<strong>类</strong>，<strong>类</strong>是一种数据结构，可以封装数据成员、方法成员和其他的类。</p><p>C#中所有的语句都必须包含在类中。</p><p>类名是一种标识符，必须符合标识符的命名规则。</p><h3 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h3><p>一个C#程序中只能有一个入口点(Mian方法)</p><p>Main方法<strong>默认访问级别</strong>为private</p><p>可以用三种修饰符修饰Main方法：Pubic，Static，Void<br>Public：说明Mian方法是公有的，在类的外面也可以调用该方法。<br>Static：说明Main方法是一个静态方法，即这个方法属于类的本身而不是这个类的特定对象。调用静态方法不能使用类的实例化对象，必须直接使用类名来调用。<br>Void：说明Main方法是无返回值的</p><p>在Main方法中捕获异常信息并输出：try……catch(Exception)</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>变量是类的属性或数据成员，用于存储数据。</p><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>函数是一系列执行指定任务的语句，类的成员函数是在类内生命的</p><h3 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a>实例化类</h3><p>类是一个概念，只有将类实例化才能够实际上读取数据成员或者成员函数</p><h3 id="设置版本和帮助信息"><a href="#设置版本和帮助信息" class="headerlink" title="设置版本和帮助信息"></a>设置版本和帮助信息</h3><p>为C#程序设置版本和帮助信息，在“解决方案资源管理器”中找到</p><h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C#数据类型"></a>C#数据类型</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型变量可以直接分配给一个值，值类型直接包含数据。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p><p>换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是有一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong>引用类型有：object、dynamic、string</p><h2 id="Try…Catch…"><a href="#Try…Catch…" class="headerlink" title="Try…Catch…"></a>Try…Catch…</h2><p>1、代码放到try快中（try是c#的关键字）。代码运行是，会尝试执行try块内部的语句，如果么有语句发生异常，这些语句将顺序执行下去。直到全部都完成，但是一旦出现异常就跳出try块，执行catch块中的内容。</p><p>2、try块需要一个或者多个catch块程序捕捉并处理特定类型的异常。</p><h2 id="InitializeComponent-方法"><a href="#InitializeComponent-方法" class="headerlink" title="InitializeComponent()方法"></a>InitializeComponent()方法</h2><p>InitializeComponent()方法：由系统生成的对窗体界面的定义方法</p><pre class=" language-c#"><code class="language-c#">    public MainWindow()    {        InitializeComponent();    }</code></pre><h2 id="InitializeComponent方法定义哪里"><a href="#InitializeComponent方法定义哪里" class="headerlink" title="InitializeComponent方法定义哪里"></a><a href="https://www.cnblogs.com/cnblogsfans/archive/2011/02/19/1958575.html" target="_blank" rel="noopener">InitializeComponent方法定义哪里</a></h2><p>我们定位到那个方法转到定义，发现没反应。</p><p>实际上这个方法是编译时WPF会为我自动生成，编译后在下面红色标注的地方打开MainWindow.g.cs,在这个文件可以找到这个方法的定义</p><p><img src="https://images.cnblogs.com/cnblogs_com/cnblogsfans/201102/201102191634297448.png" alt=""></p><p>在每个窗口建立后，都会同时产生程序代码文件，即.cs文件，以及与之相匹配的.Designer.CS文件，业务逻辑以及事件方法等被编写在.CS文件中，而界面设计规则被封装在.Designer.CS文件中</p><p>InitializeComponent()方法和Dispose()方法，前者为界面设计的变现内容，后者为表单释放系统资源时候执行编码。</p><p>InitializeComponent()方法反映了窗体设计器中窗体和控件的属性。通常不会在这个文件中修改代码。如果更改InitializeComponent()方法中的相关属性参数，在窗体设计器界面上也会显示出来。</p><p>partial 表示以下创建的是分布类代码<br>也就是说 一个类的定义代码 可以写在两个不同的页面<br>Form1.cs和Form1.Designer.cs</p><p>注意：InitializeComponent()方法写在前面和后面是有区别的。InitializeComponent()方法是用来初始化窗体组件的，在InitializeComponent之前，窗体的各个控件还没有进行初始化，比如说窗体上有一个TextBoxUserName，在InitializeComponent之前它还只是一个TextBox类型的变量而已，如果在InitializeComponent之前调用这个TextBox的属性或方法，就会出错。再比如说你拖上取一个TextBox,它放在Form的位置，TextBox的一些属性。包括new 这个TextBox都放在那个函数里面处理的。</p><p>我们可以看一下Form.Designer.cs，在那里找到InitializeComponent方法，您会发现窗体对象的初始化都是在那里做的。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>基本的类型转换：<a href="https://www.runoob.com/csharp/csharp-type-conversion.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-type-conversion.html</a></p><p>类型转换：<a href="https://www.cnblogs.com/minotauros/p/11440040.html" target="_blank" rel="noopener">https://www.cnblogs.com/minotauros/p/11440040.html</a></p><p>讲解的比较详细：<a href="https://blog.csdn.net/wu_l_v/article/details/78989303" target="_blank" rel="noopener">https://blog.csdn.net/wu_l_v/article/details/78989303</a></p><h1 id="C-文件读写"><a href="#C-文件读写" class="headerlink" title="C#文件读写"></a>C#文件读写</h1><h2 id="添加命名控件"><a href="#添加命名控件" class="headerlink" title="添加命名控件"></a>添加命名控件</h2><pre class=" language-c#"><code class="language-c#">System.IO;System.Text;</code></pre><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>使用FileStream类进行文件的读取 ，并将它转换成char数组，然后输出</p><pre class=" language-c#"><code class="language-c#">byte[] byData = new byte[100];char[] charData = new char[1000];public void Read(){  try   {     FileStream file = new FileStream("E:\\test.txt", FileMode.Open);     file.Seek(0, SeekOrigin.Begin);     file.Read(byData, 0, 100);      //byData传进来的字节数组,用以接受FileStream对象中的数据,第2个参数是字节数组中开始写入数据的位置,它通常是0,     //表示从数组的开端文件中向数组写数据,最后一个参数规定从文件读多少字符.     Decoder d = Encoding.Default.GetDecoder();     d.GetChars(byData, 0, byData.Length, charData, 0);     Console.WriteLine(charData);     file.Close();    }   catch (IOException e)   {      Console.WriteLine(e.ToString());   }}</code></pre><p>使用StreamReader读取文件，然后一行一行的输出。</p><pre class=" language-c#"><code class="language-c#">public void Read(string path){    StreamReader sr = new StreamReader(path,Encoding.Default);    String line;    while ((line = sr.ReadLine()) != null)     {     Console.WriteLine(line.ToString());    }}</code></pre><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>使用FileStream类创建文件，然后将数据写入到文件里。</p><pre class=" language-c#"><code class="language-c#">public void Write(){   //FileMode.Append为不覆盖文件效果.create为覆盖   FileStream fs = new FileStream("E:\\ak.txt", FileMode.Create);   //获得字节数组   byte[] data = System.Text.Encoding.Default.GetBytes("Hello World!");    //开始写入   fs.Write(data, 0, data.Length);   //清空缓冲区、关闭流   fs.Flush();   fs.Close();}</code></pre><p>使用FileStream类创建文件，使用StreamWriter类，将数据写入到文件。</p><pre class=" language-c#"><code class="language-c#">public void Write(string path){   FileStream fs = new FileStream(path, FileMode.Create);   StreamWriter sw = new StreamWriter(fs);   sw.Write("Hello World!!!!");//开始写入   sw.Flush();//清空缓冲区   sw.Close();//关闭流   fs.Close();}</code></pre><h1 id="C-List介绍"><a href="#C-List介绍" class="headerlink" title="C# List介绍"></a>C# List介绍</h1><h2 id="一、LIST概述"><a href="#一、LIST概述" class="headerlink" title="一、LIST概述"></a><strong>一、LIST概述</strong></h2><p><strong>所属命名空间：</strong>System.Collections.Generic   </p><p>public class List<t> : IList<t>, ICollection<t>, IEnumerable<t>, IList, ICollection, IEnumerable</t></t></t></t></p><p> <a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx" target="_blank" rel="noopener">List</a>类是 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.arraylist.aspx" target="_blank" rel="noopener">ArrayList</a> 类的泛型等效类。该类使用大小可按需动态增加的数组实现 <a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx" target="_blank" rel="noopener">IList</a> 泛型接口。 </p><p> <strong>泛型的好处</strong>： 它为使用c#语言编写面向对象程序增加了极大的效力和灵活性。不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高。 </p><h2 id="二、性能注意事项："><a href="#二、性能注意事项：" class="headerlink" title="二、性能注意事项："></a><strong>二、性能注意事项：</strong></h2><p><strong>在决定使用</strong><a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx" target="_blank" rel="noopener"><strong>IList</strong></a> <strong>还是使用</strong><a href="http://msdn.microsoft.com/zh-cn/library/system.collections.arraylist.aspx" target="_blank" rel="noopener"><strong>ArrayList</strong></a><strong>类（两者具有类似的功能）时，记住</strong><a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx" target="_blank" rel="noopener"><strong>IList</strong></a> 类在大多数情况下执行得更好并且是类型安全的。</p><p>如果对<a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx" target="_blank" rel="noopener">IList</a> 类的类型 T 使用引用类型，则两个类的行为是完全相同的。但是，如果对类型 T 使用值类型，则需要考虑实现和装箱问题。</p><p> “添加到 ArrayList 中的任何引用或值类型都将隐式地向上强制转换为 Object。如果项是值类型，则必须在将其添加到列表中时进行装箱操作，在检索时进行取消装箱操作。强制转换以及装箱和取消装箱操作都会降低性能；在必须对大型集合进行循环访问的情况下，装箱和取消装箱的影响非常明显。”</p><h2 id="三、一般用法"><a href="#三、一般用法" class="headerlink" title="三、一般用法"></a><strong>三、一般用法</strong></h2><p><strong>List</strong>的基础、常用方法：</p><p><strong>声明：</strong> </p><p>1、List<t> mList = new List<t>(); </t></t></p><p>T为列表中元素类型，现在以string类型作为例子</p><p>E.g.： List<string> mList = new List<string>(); </string></string></p><p>2、List<t> testList =new List<t> (IEnumerable<t> collection);</t></t></t></p><p>   以一个集合作为参数创建List</p><p>   E.g.：</p><p>string[] temArr = { “Ha”, “Hunter”, “Tom”, “Lily”, “Jay”, “Jim”, “Kuku”, “Locu” };</p><p>List<string> testList = new List<string>(temArr);</string></string></p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h3><p>1、 List. Add(T item)  添加一个元素</p><p>E.g.：  mList.Add(“John”);</p><p>2、 List. AddRange(IEnumerable<t> collection)  添加一组元素</t></p><p>E.g.：</p><pre class=" language-c#"><code class="language-c#">string[] temArr = { "Ha","Hunter", "Tom", "Lily", "Jay", "Jim", "Kuku", "Locu" };mList.AddRange(temArr);</code></pre><p>3、Insert(int index, T item);  在index位置添加一个元素</p><p>E.g.：  mList.Insert(1, “Hei”);</p><h3 id="遍历List中元素"><a href="#遍历List中元素" class="headerlink" title="遍历List中元素"></a>遍历List中元素</h3><pre class=" language-c#"><code class="language-c#">foreach (T element in mList) //T的类型与mList声明时一样 {   Console.WriteLine(element); }</code></pre><p>E.g.：</p><p>foreach (string s in mList)</p><p>{</p><p>  Console.WriteLine(s);</p><p>}</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p> 1、 List. Remove(T item)    删除一个值</p><p>E.g.：  mList.Remove(“Hunter”);</p><p> 2、 List. RemoveAt(int index);  删除下标为index的元素</p><p>E.g.：  mList.RemoveAt(0);</p><p> 3、 List. RemoveRange(int index, int count);</p><p>从下标index开始，删除count个元素</p><p>   E.g.：  mList.RemoveRange(3, 2);</p><h3 id="判断某个元素是否在该List"><a href="#判断某个元素是否在该List" class="headerlink" title="判断某个元素是否在该List"></a>判断某个元素是否在该List</h3><p>List. Contains(T item)  返回true或false，很实用</p><p>E.g.：</p><p>if (mList.Contains(“Hunter”))</p><p>{</p><p>  Console.WriteLine(“There is Hunter in the list”);</p><p> }</p><p> else</p><p> {</p><p>   mList.Add(“Hunter”);</p><p>​    Console.WriteLine(“Add Hunter successfully.”);</p><p> }</p><h3 id="给List里面元素排序"><a href="#给List里面元素排序" class="headerlink" title="给List里面元素排序"></a>给List里面元素排序</h3><p>List. Sort ()  默认是元素第一个字母按升序</p><p>E.g.：  mList.Sort();</p><h3 id="给List里面元素顺序反转"><a href="#给List里面元素顺序反转" class="headerlink" title="给List里面元素顺序反转"></a>给List里面元素顺序反转</h3><p>List. Reverse ()  可以与List. Sort ()配合使用，达到想要的效果</p><p>E.g.：  mList.Sort();</p><h3 id="List清空"><a href="#List清空" class="headerlink" title="List清空"></a>List清空</h3><p>List. Clear () </p><p>E.g.：  mList.Clear();</p><h3 id="获得List中元素数目"><a href="#获得List中元素数目" class="headerlink" title="获得List中元素数目"></a>获得List中元素数目</h3><p>List. Count ()  返回int值</p><p>E.g.：</p><p>int count = mList.Count();</p><p>​    Console.WriteLine(“The num of elements in the list: “ +count);</p><h2 id="List的进阶、强大方法"><a href="#List的进阶、强大方法" class="headerlink" title="List的进阶、强大方法"></a>List的进阶、强大方法</h2><p>举例用的List：</p><pre class=" language-c#"><code class="language-c#">string[] temArr = { Ha","Hunter", "Tom", "Lily", "Jay", "Jim", "Kuku", " "Locu" };mList.AddRange(temArr);</code></pre><h3 id="List-Find方法"><a href="#List-Find方法" class="headerlink" title="List.Find方法"></a>List.Find方法</h3><p>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 List 中的第一个匹配元素。 </p><p>public T Find(Predicate<t> match);</t></p><p>Predicate是对方法的委托，如果传递给它的对象与委托中定义的条件匹配，则该方法返回 true。当前 List 的元素被逐个传递给Predicate委托，并在 List 中向前移动，从第一个元素开始，到最后一个元素结束。当找到匹配项时处理即停止。</p><p>Predicate 可以委托给一个函数或者一个拉姆达表达式:</p><p>委托给拉姆达表达式：</p><p>E.g.：</p><pre class=" language-c#"><code class="language-c#"> string listFind = mList.Find(name => //name是变量，代表的是mList   {               //中元素，自己设定     if (name.Length > 3)     {       return true;     }       return false;    });    Console.WriteLine(listFind);   //输出是Hunter</code></pre><p>委托给一个函数：</p><p>E.g.：</p><pre class=" language-c#"><code class="language-c#">string listFind1 = mList.Find(ListFind); //委托给ListFind函数Console.WriteLine(listFind);      //输出是Hunter</code></pre><h3 id="ListFind函数"><a href="#ListFind函数" class="headerlink" title="ListFind函数"></a>ListFind函数</h3><pre class=" language-c#"><code class="language-c#">public bool ListFind(string name){  if (name.Length > 3)    {     return true;    }      return false;}</code></pre><p>这两种方法的结果是一样的。</p><h3 id="List-FindLast方法"><a href="#List-FindLast方法" class="headerlink" title="List.FindLast方法"></a>List.FindLast方法</h3><p>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 List 中的最后一个匹配元素。 </p><p>public T FindLast(Predicate<t> match);</t></p><p>用法与List.Find相同。</p><h3 id="List-TrueForAll方法"><a href="#List-TrueForAll方法" class="headerlink" title="List.TrueForAll方法"></a>List.TrueForAll方法</h3><p>确定是否 <a href="http://msdn.microsoft.com/en-us/6sh2ey19(zh-cn,VS.85).aspx" target="_blank" rel="noopener">List</a> 中的每个元素都与指定的谓词所定义的条件相匹配。</p><p> public bool TrueForAll(Predicate<t> match);</t></p><p>委托给拉姆达表达式：</p><p>E.g.：</p><pre class=" language-c#"><code class="language-c#"> bool flag = mList.TrueForAll(name =>   {​     if (name.Length > 3)​     {​      return true;​     }​     else​      {​       return false;​       }​    }  );  Console.WriteLine("True for all: "+flag); //flag值为false</code></pre><p>委托给一个函数，这里用到上面的<strong>ListFind</strong>函数：</p><p>E.g.：</p><pre class=" language-c#"><code class="language-c#"> bool flag = mList.TrueForAll(ListFind); //委托给ListFind函数Console.WriteLine("True for all: "+flag); //flag值为false</code></pre><p>这两种方法的结果是一样的。</p><h3 id="List-FindAll方法"><a href="#List-FindAll方法" class="headerlink" title="List.FindAll方法"></a>List.FindAll方法</h3><p>检索与指定谓词所定义的条件相匹配的所有元素。</p><p>public List<t> FindAll(Predicate<t> match);</t></t></p><p>E.g.：</p><pre class=" language-c#"><code class="language-c#">List<string> subList = mList.FindAll(ListFind); //委托给ListFind函数 foreach (string s in subList)  {   Console.WriteLine("element in subList: "+s);  }</code></pre><p>​    这时subList存储的就是所有长度大于3的元素</p><h3 id="List-Take-n"><a href="#List-Take-n" class="headerlink" title="List.Take(n)"></a>List.Take(n)</h3><p> 获得前n行 返回值为IEnumetable<t>，T的类型与List<t>的类型一样</t></t></p><p>E.g.：</p><pre class=" language-c#"><code class="language-c#"> IEnumerable<string> takeList= mList.Take(5); foreach (string s in takeList)  {​    Console.WriteLine("element in takeList: " + s);  }</code></pre><p>​    这时takeList存放的元素就是mList中的前5个</p><h3 id="List-Where方法"><a href="#List-Where方法" class="headerlink" title="List.Where方法"></a>List.Where方法</h3><p>检索与指定谓词所定义的条件相匹配的所有元素。跟List.FindAll方法类似。</p><p>E.g.：</p><p>​    </p><pre class=" language-c#"><code class="language-c#">  IEnumerable<string> whereList = mList.Where(name =>​       {​          if (name.Length > 3)​          {​            return true;​          }​          else​          {​            return false;​          }​       });​     foreach (string s in subList)​     {​       Console.WriteLine("element in subList: "+s);​     }</code></pre><p>​     这时subList存储的就是所有长度大于3的元素</p><h3 id="List-RemoveAll方法"><a href="#List-RemoveAll方法" class="headerlink" title="List.RemoveAll方法"></a>List.RemoveAll方法</h3><p>移除与指定的谓词所定义的条件相匹配的所有元素。</p><p>public int RemoveAll(Predicate<t> match);</t></p><p>E.g.：</p><p>​     </p><pre class=" language-c#"><code class="language-c#"> mList.RemoveAll(name =>​        {​          if (name.Length > 3)​          {​            return true;​          }​          else​          {​            return false;​          }​        });​      foreach (string s in mList)​      {​        Console.WriteLine("element in mList:   " + s);​      }</code></pre><p>   这时mList存储的就是移除长度大于3之后的元素。</p><p>List<t> 是一个泛型链表…T表示节点元素类型<br>比如<br>List<int> intList;表示一个元素为int的链表<br>intList.Add(34); //添加<br>intList.Remove(34);//删除<br>intList.RemoveAt(0); //删除位于某处的元素<br>intList.Count; //链表长度<br>还有Insert,Find,FindAll,Contains等方法,也有索引方法 intList[0] = 23;</int></t></p><p>1.减少了装箱拆箱<br>2.便于编译时检查数据类型</p><p>List<object> 就相当于 System.Collections命名空间里面的List<p></p><h2 id="C-List和string-之间的相互转换"><a href="#C-List和string-之间的相互转换" class="headerlink" title="C#List和string[]之间的相互转换"></a>C#List<string>和string[]之间的相互转换</string></h2><p>1.从System.String[]转到List&lt;System.String&gt;</p><pre class=" language-c#"><code class="language-c#">List<System.String> List = new List<System.String>(); string[] str={"1","2","3"};List = new List<System.String>(str);</code></pre><p>2.从List&lt;System.String&gt;转到System.String[]</p><pre class=" language-c#"><code class="language-c#">List<System.String> List = new List<System.String>(); List.Add("1");List.Add("2");List.Add("3");//添加数据System.String[] str = { };str = List.ToArray();</code></pre><p>3.字符串数组可以，其他有些类型像int数组等等的也是可以的。</p><h1 id="C-字符分割"><a href="#C-字符分割" class="headerlink" title="C# 字符分割"></a>C# 字符分割</h1><h2 id="Split-函数"><a href="#Split-函数" class="headerlink" title="Split()函数"></a>Split()函数</h2><p>Split方法提供了字符分割的几种方法</p><p>String.Split方法提供了如下6个重载函数：</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_86599791.htm" target="_blank" rel="noopener">String.Split (Char[])</a></td><td align="left">返回包含此实例中的子字符串（由指定 Char 数组的元素分隔）的 String 数组。由 .NET Compact Framework 支持。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_d4a51604.htm" target="_blank" rel="noopener">String.Split (Char[], Int32)</a></td><td align="left">返回包含此实例中的子字符串（由指定 Char 数组的元素分隔）的 String 数组。参数指定返回的子字符串的最大数量。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_0b4c5fa1.htm" target="_blank" rel="noopener">String.Split (Char[], StringSplitOptions)</a></td><td align="left">返回包含此字符串中的子字符串（由指定的 Char 数组的元素分隔）的 String 数组。参数指定是否返回空数组元素。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_2_f66d5c6c.htm" target="_blank" rel="noopener">String.Split (String[], StringSplitOptions)</a></td><td align="left">返回包含此字符串中的子字符串（由指定的 String 数组的元素分隔）的 String 数组。参数指定是否返回空数组元素。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_7399acf4.htm" target="_blank" rel="noopener">String.Split (Char[], Int32, StringSplitOptions)</a></td><td align="left">返回包含此字符串中的子字符串（由指定的 Char 数组的元素分隔）的 String 数组。参数指定要返回子字符串的最大数量，以及是否要返回空数组元素。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_2_42368699.htm" target="_blank" rel="noopener">String.Split (String[], Int32, StringSplitOptions)</a></td><td align="left">返回包含此字符串中的子字符串（由指定的 String 数组的元素分隔）的 String 数组。参数指定要返回子字符串的最大数量，以及是否要返回空数组元素。</td></tr></tbody></table><p>以下详细举例说明:</p><h3 id="String-Split-Char"><a href="#String-Split-Char" class="headerlink" title="String.Split(Char[])"></a>String.Split(Char[])</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctdd";string []strArray = str.Split(new char[]{'t'}); 或string []strArray = str.Split('t'); //单字符切割(result : "aaa" "bbscc" "dd")string []strArray = str.Split(new char[]{'t','s'}); //多字节切割(result : "aaa" "bb" "cc" "dd")</code></pre><h3 id="String-Split-Char-Int32"><a href="#String-Split-Char-Int32" class="headerlink" title="String.Split(Char[],Int32)"></a>String.Split(Char[],Int32)</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctdd";string []strArray = str.Split(new char[]{'t',2});//只切割成2份(result :"aaa" "bbscctdd")</code></pre><h3 id="String-Split-Char-StringSplitOptions"><a href="#String-Split-Char-StringSplitOptions" class="headerlink" title="String.Split(Char[],StringSplitOptions)"></a>String.Split(Char[],StringSplitOptions)</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctddt";string []strArray = str.Split(new char[]{'t',StringSplitOptions.RemoveEmptyEntries});//去除空元素(result :"aaa" "bbscc" "dd")string []strArray = str.Split(new char[]{'t',StringSplitOptions.None});//保留空元素(result :"aaa" "bbscc" "dd" “”) </code></pre><h3 id="String-Split-String-StringSplitOptions"><a href="#String-Split-String-StringSplitOptions" class="headerlink" title="String.Split(String[],StringSplitOptions)"></a>String.Split(String[],StringSplitOptions)</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctddt";string []strArray = str.Split(new String[]{"t",StringSplitOptions.RemoveEmptyEntries});//去除空元素(result :"aaa" "bbscc" "dd")string []strArray = str.Split(new String[]{"t",StringSplitOptions.None});//保留空元素(result :"aaa" "bbscc" "dd" “”) </code></pre><h3 id="String-Split-Char-Int32-StringSplitOptions"><a href="#String-Split-Char-Int32-StringSplitOptions" class="headerlink" title="String.Split(Char[],Int32,StringSplitOptions)"></a>String.Split(Char[],Int32,StringSplitOptions)</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctddt";string []strArray = str.Split(new char[]{'t',2,StringSplitOptions.RemoveEmptyEntries});//切割成2份且去除空元素(result :"aaa" "bbscctddt")string []strArray = str.Split(new char[]{'t',2,StringSplitOptions.None});//切割成2份且保留空元素(result :"aaa" "bbscctddt" “”)</code></pre><h3 id="String-Split-String-Int32-StringSplitOptions"><a href="#String-Split-String-Int32-StringSplitOptions" class="headerlink" title="String.Split(String[],Int32,StringSplitOptions)"></a>String.Split(String[],Int32,StringSplitOptions)</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctddt";string []strArray = str.Split(new String[]{"t",2,StringSplitOptions.RemoveEmptyEntries});//切割成2份且去除空元素(result :"aaa" "bbscctddt")string []strArray = str.Split(new String[]{"t",2,StringSplitOptions.None});//切割成2份且保留空元素(result :"aaa" "bbscctddt" “”)</code></pre><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p>正则匹配拆分字符串提供了5个重载函数：</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_16219e3a.htm" target="_blank" rel="noopener">Regex.Split (String)</a></td><td align="left">在由 <a href="http://blog.csdn.net/chen_zw/article/details/T_System_Text_RegularExpressions_Regex.htm" target="_blank" rel="noopener">Regex</a> 构造函数中指定的正则表达式模式定义的位置拆分指定的输入字符串。由 .NET Compact Framework 支持。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_843a3b0f.htm" target="_blank" rel="noopener">Regex.Split (String, Int32)</a></td><td align="left">在由 Regex 构造函数中指定的正则表达式定义的位置，将指定的输入字符串拆分指定的最大次数。由 .NET Compact Framework 支持。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_d460c748.htm" target="_blank" rel="noopener">Regex.Split (String, String)</a></td><td align="left">在由正则表达式模式定义的位置拆分输入字符串。由 .NET Compact Framework 支持。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_1c9576da.htm" target="_blank" rel="noopener">Regex.Split (String, Int32, Int32)</a></td><td align="left">从输入字符串中的指定字符位置开始，在由 Regex 构造函数中指定的正则表达式定义的位置，将指定的输入字符串拆分指定的最大次数。由 .NET Compact Framework 支持。</td></tr><tr><td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_2_385f6254.htm" target="_blank" rel="noopener">Regex.Split (String, String, RegexOptions)</a></td><td align="left">在由指定的正则表达式模式定义的位置拆分输入字符串。可指定选项来修改匹配的行为。</td></tr></tbody></table><h3 id="添加命名空间"><a href="#添加命名空间" class="headerlink" title="添加命名空间"></a>添加命名空间</h3><pre class=" language-c#"><code class="language-c#">using System.Text.RegularExpressions;</code></pre><h3 id="函数demo"><a href="#函数demo" class="headerlink" title="函数demo"></a>函数demo</h3><h4 id="Regex-Split-String-String"><a href="#Regex-Split-String-String" class="headerlink" title="Regex.Split(String,String)"></a>Regex.Split(String,String)</h4><p>string str = “aaatsbbtscctsdd”;<br>stirng []strArray = Regex.Split(str,”ts”); //正则匹配切割(result: “aaa” “bb” “cc” “dd”);</p><h4 id="Regex-Split-String-String-1"><a href="#Regex-Split-String-String-1" class="headerlink" title="Regex.Split(String,String)"></a>Regex.Split(String,String)</h4><p>string str = “aaatsbbtscctsdd”;<br>stirng []strArray = Regex.Split(str,”ts”,RegexOptions.IgnoreCase); //正则匹配切割(result: “aaa” “bb” “cc” “dd”);</p><h2 id="字符分割应用"><a href="#字符分割应用" class="headerlink" title="字符分割应用"></a>字符分割应用</h2><h3 id="单字符拆分"><a href="#单字符拆分" class="headerlink" title="单字符拆分"></a>单字符拆分</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctdd";string []strArray = str.Split(new char[]{'t'}); 或string []strArray = str.Split('t'); //单字符切割(result : "aaa"  "bbscc"  "dd")</code></pre><h3 id="多字符拆分"><a href="#多字符拆分" class="headerlink" title="多字符拆分"></a>多字符拆分</h3><pre class=" language-c#"><code class="language-c#">string str = "aaatbbscctdd";string []strArray = str.Split(new char[]{'t','s'}); //多字节切割(result : "aaa" "bb" "cc" "dd")</code></pre><h3 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h3><pre class=" language-c#"><code class="language-c#">using System.Text.RegularExpressions;string str = "aaatsbbtscctsdd";stirng []strArray = Regex.Split(str,"ts",RegexOptions.IgnoreCase); //正则匹配切割且(result: "aaa" "bb" "cc" "dd");</code></pre><p>或者</p><pre class=" language-c#"><code class="language-c#">string str = "aaatsbbtscctsdd";string []strArray = str.Split(new string[]{"ts"}); //字符串切割(result : "aaa" "bb" "cc" "dd")</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>String.Split方法没有重载String.Split(stirng [])方法，也就是说str.Split(“t”)或者str.Split(new string[]{“ts”,”dd”})都是错误的。</p><p>除了切割单字符可用String.Split(‘t’)外，其它的都必须用String.Split(new char[]{})这样的格式，否则编译会出错</p><h1 id="功能实现小记"><a href="#功能实现小记" class="headerlink" title="功能实现小记"></a>功能实现小记</h1><h2 id="WPF打开网页实现"><a href="#WPF打开网页实现" class="headerlink" title="WPF打开网页实现"></a>WPF打开网页实现</h2><h3 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h3><p>添加头文件引用</p><pre class=" language-C#"><code class="language-C#">using System.Diagnostics;</code></pre><pre class=" language-c#"><code class="language-c#">Process proc = new System.Diagnostics.Process();proc.StartInfo.FileName = "http://www.baidu.com";proc.Start();</code></pre><h3 id="WPF应用程序中打开"><a href="#WPF应用程序中打开" class="headerlink" title="WPF应用程序中打开"></a>WPF应用程序中打开</h3><pre class=" language-c#"><code class="language-c#">WebBrowser wBrowser = new WebBrowser();wBrowser .Source = new Uri("http://www.baidu.com");       this.Content = wBrowser ;</code></pre><h2 id="WPF插入超链接"><a href="#WPF插入超链接" class="headerlink" title="WPF插入超链接"></a>WPF插入超链接</h2><p>前端XAML：<br>值得注意的一点是，超链接的文字一定要包含在&lt;hyperlink&gt;&lt;/hyperlink&gt;标记中，否则报错。并且&lt;hyperlink&gt;&lt;/hyperlink&gt;标记不可以单独出现，一定要嵌套在textblcok中</p><pre class=" language-xaml"><code class="language-xaml"><TextBlock>        <Hyperlink NavigateUri="http://www.nlecloud.com/my/forget"                    Click="ForgotPassword_Click"                   Name="ForgotPassword">          忘记密码        </Hyperlink></TextBlock></code></pre><p>后端C#：</p><pre class=" language-c#"><code class="language-c#">private void ForgotPassword_Click(object sender, RoutedEventArgs e)        {//忘记密码            Hyperlink link = sender as Hyperlink;            Process.Start(new ProcessStartInfo(link.NavigateUri.AbsoluteUri));        }</code></pre><p>坑：窗口全局的MoseMove事件会影响超链接标记的点击属性，导致超链接点击事件不发生的情况。</p><h2 id="实现Image控件点击事件"><a href="#实现Image控件点击事件" class="headerlink" title="实现Image控件点击事件"></a>实现Image控件点击事件</h2><p>为Image控件设置鼠标点击事件</p><pre class=" language-XAMl"><code class="language-XAMl"><Image                            ToolTip="进入新大陆物联网云"                            MouseLeftButtonDown="Image_MouseLeftButtonDown"                            Width="120" Height="50"                            ></code></pre><p>在后台代码中写出点击事件的逻辑实现</p><pre class=" language-c#"><code class="language-c#">private void Image_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)        {            Process proc = new System.Diagnostics.Process();            proc.StartInfo.FileName = "http://www.nlecloud.com/";            proc.Start();        }</code></pre><h2 id="HeaderStringFormat-属性"><a href="#HeaderStringFormat-属性" class="headerlink" title="HeaderStringFormat 属性"></a>HeaderStringFormat 属性</h2><p>获取或设置一个撰写字符串，该字符串指定如果 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.header?view=netcore-3.1#System_Windows_Controls_HeaderedContentControl_Header" target="_blank" rel="noopener">Header</a> 属性显示为字符串，应如何设置该属性的格式。</p><pre class=" language-c#"><code class="language-c#">[System.ComponentModel.Bindable(true)]public string HeaderStringFormat { get; set; }</code></pre><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><ul><li><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=netcore-3.1" target="_blank" rel="noopener">String</a><br>一个撰写字符串，指定如果 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.header?view=netcore-3.1#System_Windows_Controls_HeaderedContentControl_Header" target="_blank" rel="noopener">Header</a> 属性显示为字符串，应如何设置该属性的格式。 默认值为 <code>null</code>。</p></li><li><p>属性<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.bindableattribute?view=netcore-3.1" target="_blank" rel="noopener">BindableAttribute</a></p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的示例将绑定 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabcontrol?view=netcore-3.1" target="_blank" rel="noopener">TabControl</a> 到对象的集合 <code>Student</code> 。 <code>Student</code>类具有一个 <code>Name</code> 属性和一个对象的集合 <code>Course</code> ，并实现了 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iformattable.tostring?view=netcore-3.1" target="_blank" rel="noopener">IFormattable.ToString</a> 返回 <code>Name</code> 学生或列出学生课程的字符串的方法。 该示例使用将 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformat?view=netcore-3.1" target="_blank" rel="noopener">HeaderStringFormat</a> 学生的名称放在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.header?view=netcore-3.1" target="_blank" rel="noopener">Header</a> 从) 继承的每个 (的中 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabitem?view=netcore-3.1" target="_blank" rel="noopener">TabItem</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol?view=netcore-3.1" target="_blank" rel="noopener">HeaderedContentControl</a> ，并使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabcontrol.contentstringformat?view=netcore-3.1" target="_blank" rel="noopener">TabControl.ContentStringFormat</a> 来为的内容中的每个学生显示课程列表 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabitem?view=netcore-3.1" target="_blank" rel="noopener">TabItem</a> 。</p><pre class=" language-xaml"><code class="language-xaml"><Grid>  <Grid.Resources>    <src:Students x:Key="Students"/>    <Style TargetType="TabItem">      <Setter Property="HeaderStringFormat" Value="n"/>      <Setter Property="FontFamily" Value="Lucida Sans Unicode"/>      <Setter Property="Foreground" Value="Green"/>      <Setter Property="FontWeight" Value="Bold"/>    </Style>  </Grid.Resources>  <TabControl ItemsSource="{StaticResource Students}"              FontFamily="Lucida Console" Foreground="Navy"              ContentStringFormat="cl"/></Grid></code></pre><p>下面的示例实现 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iformattable.tostring?view=netcore-3.1" target="_blank" rel="noopener">IFormattable.ToString</a> 方法以返回 <code>Name</code> 学生的或列出学生课程的字符串。</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">string</span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token keyword">string</span> format<span class="token punctuation">,</span> IFormatProvider formatProvider<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 'n': print the name only.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>format <span class="token operator">==</span> <span class="token string">"n"</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> Name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 'cl': print the course list.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>format <span class="token operator">==</span> <span class="token string">"cl"</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">string</span> stringFormat <span class="token operator">=</span> <span class="token string">"{0,-25}{1,-30}{2,-10}\r\n"</span><span class="token punctuation">;</span>        StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        str<span class="token punctuation">.</span><span class="token function">AppendLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         str<span class="token punctuation">.</span><span class="token function">AppendFormat</span><span class="token punctuation">(</span>stringFormat<span class="token punctuation">,</span> <span class="token string">"Title"</span><span class="token punctuation">,</span> <span class="token string">"Description"</span><span class="token punctuation">,</span> <span class="token string">"ID"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        str<span class="token punctuation">.</span><span class="token function">AppendLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">foreach</span> <span class="token punctuation">(</span>Course c <span class="token keyword">in</span> Courses<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            str<span class="token punctuation">.</span><span class="token function">AppendFormat</span><span class="token punctuation">(</span>stringFormat<span class="token punctuation">,</span> c<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> c<span class="token punctuation">.</span>Description<span class="token punctuation">,</span> c<span class="token punctuation">.</span>SectionID<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformat?view=netcore-3.1" target="_blank" rel="noopener">HeaderStringFormat</a> 可以是预定义的复合字符串格式。 有关字符串格式的详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/formatting-types" target="_blank" rel="noopener">格式设置类型</a>。 如果设置 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headertemplate?view=netcore-3.1" target="_blank" rel="noopener">HeaderTemplate</a> 了或的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headertemplateselector?view=netcore-3.1" target="_blank" rel="noopener">HeaderTemplateSelector</a> 属性，则将 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol?view=netcore-3.1" target="_blank" rel="noopener">HeaderedContentControl</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformat?view=netcore-3.1" target="_blank" rel="noopener">HeaderStringFormat</a> 忽略属性。</p><h3 id="依赖项属性信息"><a href="#依赖项属性信息" class="headerlink" title="依赖项属性信息"></a>依赖项属性信息</h3><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">标识符字段</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformatproperty?view=netcore-3.1" target="_blank" rel="noopener">HeaderStringFormatProperty</a></td></tr><tr><td align="left">元数据属性设置为 <code>true</code></td><td align="left">无</td></tr></tbody></table><h2 id="Xaml控件不可用属性"><a href="#Xaml控件不可用属性" class="headerlink" title="Xaml控件不可用属性"></a>Xaml控件不可用属性</h2><pre class=" language-xaml"><code class="language-xaml">isEnable = "False"</code></pre><h2 id="登录文本框判空提示"><a href="#登录文本框判空提示" class="headerlink" title="登录文本框判空提示"></a>登录文本框判空提示</h2><pre class=" language-c#"><code class="language-c#">getUsername.text == null;getPassword.password == null;</code></pre><h2 id="ToolTip提示控件"><a href="#ToolTip提示控件" class="headerlink" title="ToolTip提示控件"></a>ToolTip提示控件</h2><p>ToolTip控件可以在鼠标移动到某控件上后弹出提示的控件</p><pre class=" language-xaml"><code class="language-xaml"> < Button Content ="Button" HorizontalAlignment ="Left" Margin ="80,58,0,0" VerticalAlignment ="Top" Width ="75">            < Button.ToolTip >                < ToolTip Placement ="Right">                    < TextBlock >                    按钮tooltip                    </ TextBlock >                </ ToolTip >                            </ Button.ToolTip >        </ Button ></code></pre><p>其中Placement用来确定Tooltip提示框出现的位置。</p><p>对于StackPanel的控件，如下所示：</p><pre class=" language-xaml"><code class="language-xaml"> < StackPanel.ToolTip >   < ToolTip Placement ="Center">       < TextBlock >            第一个按钮        </ TextBlock >   </ ToolTip > </ StackPanel.ToolTip ></code></pre><p>对于ToolTip的控制，还提供了ToolTipService类，ToolTipService是一个静态类，表示一个服务，该服务提供用于控制提示的显示和行为的属性和事件。</p><pre class=" language-xaml"><code class="language-xaml">< Button ToolTipService.Placement ="Center" ToolTipService.BetweenShowDelay ="1000" ToolTipService.ToolTip ="按钮提示"  Content ="Button" HorizontalAlignment ="Left" Margin ="80,58,0,0" VerticalAlignment ="Top" Width ="75">    < Button.ToolTip >        < ToolTip Placement ="Right">            < TextBlock >                 按钮tooltip            </ TextBlock >        </ ToolTip >    </ Button.ToolTip ></ Button ></code></pre><p>ToolTipService主要属性</p><pre class=" language-c#"><code class="language-c#">ToolTipService.InitialShowDelay="1000"  //获取或设置工具提示打开前的时间长度ToolTipService.ShowDuration="7000" //显示时间ToolTipService.BetweenShowDelay="2000"//获取或设置两个工具提示显示之间的最大时间（第二个工具提示不经延迟即会出现）。ToolTipService.Placement="Right"//工具提示相对原控件打开时的方向，并指定工具提示在与屏幕边界重叠时的行为。ToolTipService.PlacementRectangle="50,0,0,0"//获取或设置相对于其来放置工具提示的矩形区域。ToolTipService.HorizontalOffset="10"//获取或设置由 PlacementRectangle 和 PlacementTarget 属性为工具提示指定的区域的左侧偏移量。ToolTipService.VerticalOffset="20"//获取或设置由 PlacementRectangle 和 PlacementTarget 属性为工具提示指定的区域的顶部距离。ToolTipService.HasDropShadow="False"//获取或设置工具提示是否显示投影效果。ToolTipService.IsEnabled="True"//获取或设置是否显示工具提示。</code></pre><h2 id="DispatcherTimer线程"><a href="#DispatcherTimer线程" class="headerlink" title="DispatcherTimer线程"></a>DispatcherTimer线程</h2><p>什么是 DispatcherTimer？ DispatcherTimer是一种定时器！</p><pre class=" language-c#"><code class="language-c#">        public MainWindow()        {            InitializeComponent();            this.Loaded += MainWindow_Loaded;        }        DispatcherTimer time;//实例化一个定时器        void MainWindow_Loaded(object sender,RoutedEventArgs e)        {            time = new DispatcherTimer();            time.Interval = TimeSpan.FromSeconds(3000);            time.Tick += time_tick;            time.Start();        }        void time_tick (object sender,EventArgs e)        {        }</code></pre><h2 id="WPF窗体出现位置"><a href="#WPF窗体出现位置" class="headerlink" title="WPF窗体出现位置"></a>WPF窗体出现位置</h2><p>如何设置WPF窗体在屏幕上显示的位置？</p><p>方法一<br>在后台代码中添加</p><pre class=" language-c#"><code class="language-c#">public Login(){InitializeComponent();WindowStartupLocation = WindowStartupLocation.CenterScreen;//WPF窗体在屏幕上居中}</code></pre><p>方法二<br>在XAML代码中添加</p><pre class=" language-xaml"><code class="language-xaml">WindowStartupLocation="CenterScreen"</code></pre><h2 id="获取当前桌面路径"><a href="#获取当前桌面路径" class="headerlink" title="获取当前桌面路径"></a>获取当前桌面路径</h2><pre class=" language-c#"><code class="language-c#">string strDesktopPath = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);//用函数获取当前电脑的桌面路径保存为string类型的变量</code></pre><h2 id="WPF窗体无边框"><a href="#WPF窗体无边框" class="headerlink" title="WPF窗体无边框"></a>WPF窗体无边框</h2><p>WPF做这样的窗口非常简单，只有需在窗口设计中设置两个属性，一个是AllowsTransparency, 设置为 Ture;  一个是 WindowStyle, 设置为 None。<br><img src="https://i.loli.net/2020/10/19/mnHiBZf5DvaSx2X.png" alt="属性设置"><br>注：是Window的属性，不要选中其他的控件。</p><p>另外，如果AllowsTransparency=”True”，那么 WindowStyle只能为 None， VS2015 已经做到连动设置，只要勾选AllowsTransparency，后一个也跟着变了。但 VS2008 还是需要用户分别设置，不然会报错。</p><p>还有一个问题不得不提，AllowsTransparency=”True” 之后就无法使用 WindowsFormsHost控件了，因为就算用了，WFH里的任何控件也是透明无法显示出来的，比如ReportViewer</p><h2 id="WPF窗体拖动"><a href="#WPF窗体拖动" class="headerlink" title="WPF窗体拖动"></a>WPF窗体拖动</h2><p>标题栏上有最大化最小化和关闭的按钮，其中在登录窗口我们一般是不会使用最大化按钮的。可是不得不说，标题栏还有一个很实用的作用，就是可以拖拽整个窗口，用户只要单击标题栏不放，就可以拖到桌面的任何地方。如今把标题栏隐藏之后，该如何弥补呢？</p><pre class=" language-c#"><code class="language-c#">private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)        {            try            {                this.DragMove();            }            catch { }        }</code></pre><p>网上很多教程到这一步就结束了，对我这种没有精通C#的人来说很不友善，实际上还需要为窗体XAML添加一个事件，代码如下，其他有关窗体操作的内容以此类推：</p><pre class=" language-xaml"><code class="language-xaml">MouseMove="Window_MouseLeftButtonDown"</code></pre><p>注：网上有些示例里，没有用 try{}catch{}，而只有一行代码</p><pre class=" language-C#"><code class="language-C#">this.DragMove();</code></pre><p>如果在登录窗口，只有那么几个控件和事件的话，应该也是无大碍的。</p><p>在这里有个小小的经验必须分享一下：由于在主界面里也使用了这种无标题栏的窗口，鼠标在Gridview上操作时，经常会引发异常崩溃。所以最好加 try…catch… 避免异常，哪怕是登录窗口也不例外。</p><h3 id="设置允许拖动区域"><a href="#设置允许拖动区域" class="headerlink" title="设置允许拖动区域"></a>设置允许拖动区域</h3><p>这里遇到一点问题，当窗体中有RichTextBox这种能输入的控件时，在控件中按下左键拖动鼠标就会报错，估计是控件本身的鼠标拖动和窗体的冲突。再者，我们在这些控件中拖动鼠标的目的是选择文字，而不是拖动窗口，这时就需要设置相应区域：</p><pre class=" language-c#"><code class="language-c#">private void BackGround_MouseMove(object sender, MouseEventArgs e)    {      Point pp = Mouse.GetPosition(this);      if (pp.X >= 20 && pp.X <= 288 && pp.Y>=78 && pp.Y <= 460)          {          }      else      {        if (e.LeftButton == MouseButtonState.Pressed)        {          //this.DragMove();                 Window.DragMove();        }      }    }</code></pre><h2 id="输入密码回车登录"><a href="#输入密码回车登录" class="headerlink" title="输入密码回车登录"></a>输入密码回车登录</h2><p>很多网站会注意这种情况，输入密码后回车，系统就可以登录，这就是良好的用户体验。（当然，也有些网站不注意用户体验，用户必须用鼠标去点击登录的）</p><p>其实在密码框添加一个 KeyDown 事件就可以</p><pre class=" language-c#"><code class="language-c#">        private void txt_Pwd_KeyDown(object sender, KeyEventArgs e)        {            switch (e.Key)            {                case Key.Enter:                    btn_login_Click(btn_login, null);                    break;                default:                    break;            }        }    </code></pre><p>同时需要在Xaml文件中添加键盘点击事件名称声明：</p><pre class=" language-xaml"><code class="language-xaml">Keyboard.KeyDown="txt_Pwd_KeyDown"</code></pre><h2 id="WPF退出程序"><a href="#WPF退出程序" class="headerlink" title="WPF退出程序"></a>WPF退出程序</h2><p>当处于全屏模式下时，没有右上角的退出按钮，此时需要手动写button退出功能。<br>调用下面语句可以直接退出。</p><pre class=" language-c#"><code class="language-c#">Application.Current.Shutdown();</code></pre><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="HandyControl与LiveCharts使用出现图形位置偏移问题"><a href="#HandyControl与LiveCharts使用出现图形位置偏移问题" class="headerlink" title="HandyControl与LiveCharts使用出现图形位置偏移问题"></a><a href="https://www.cnblogs.com/guanguanchangyu/p/12604090.html" target="_blank" rel="noopener">HandyControl与LiveCharts使用出现图形位置偏移问题</a></h2><blockquote><p><code>HandyControl</code>是一套<code>WPF</code>控件库，它几乎重写了所有原生样式，同时包含70余款自定义控件（正逐步增加）。</p></blockquote><p>此处为<a href="https://github.com/HandyOrg/HandyControl" target="_blank" rel="noopener"><code>HandyControl</code>源码传送门</a>,希望能对它能有所了解</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于<code>HandyControl</code>作为<code>WPF</code>的一款<code>UI</code>库，暂时没有考虑过增加，数据图形控件，对于需要数据统计图形展示的用户，可能引入<code>LiveCharts</code>做数据展示处理，运行之后，出现之前好好的控件，显示效果中，图形位置偏移走样问题。</p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a><a href="https://www.cnblogs.com/guanguanchangyu/p/12604090.html#1527470209" target="_blank" rel="noopener">现象</a></h3><p>引用<code>HandyControl</code>前，感觉生活很美好</p><p><a href="https://file.budbud.cn/handycontrol/path/livechart-right.png" target="_blank" rel="noopener"><img src="https://file.budbud.cn/handycontrol/path/livechart-right.png" alt="livechart-right"></a></p><p>引入<code>HandyControl</code>后，世界都懵逼了</p><p><a href="https://file.budbud.cn/handycontrol/path/livechart-wrong.png" target="_blank" rel="noopener"><img src="https://file.budbud.cn/handycontrol/path/livechart-wrong.png" alt="livechart-wrong"></a></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由于<code>HandyControl</code>本身重写了几乎所有的原生样式，当然也包括了<code>Path</code>的默认样式，<a href="https://github.com/HandyOrg/HandyControl/blob/28c464a8e2bc5318f3957a41dae799b824554232/src/Shared/HandyControl_Shared/Themes/Basic/Paths.xaml" target="_blank" rel="noopener">详细修改处👉传送门</a></p><pre class=" language-xaml"><code class="language-xaml"><Style TargetType="Path">        <Setter Property="Stretch" Value="Uniform"/></Style></code></pre><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>清除<code>HandyControl</code>影响，设置<code>Path</code>的<code>Style</code>为空，引入位置，一般在<code>App.xaml</code>中或者使用<code>LiveCharts</code>控件的<code>父级资源</code>中</p><pre class=" language-xaml"><code class="language-xaml"><Style TargetType="Path" BasedOn="{x:Null}"/></code></pre><p>解决方案出处：<a href="https://www.cnblogs.com/guanguanchangyu/p/12604090.html" target="_blank" rel="noopener">https://www.cnblogs.com/guanguanchangyu/p/12604090.html</a></p><h1 id="错误error"><a href="#错误error" class="headerlink" title="错误error"></a>错误error</h1><h2 id="未将对象引用设置到对象的实例"><a href="#未将对象引用设置到对象的实例" class="headerlink" title="未将对象引用设置到对象的实例"></a>未将对象引用设置到对象的实例</h2><p>完整错误：System.NullReferenceException：未将对象引用设置到对象的实例</p><p>错误场景：</p><pre class=" language-c#"><code class="language-c#"> public static int numberPeople()        {//当前排队人数            SensorDataFuzzyQryPagingParas query = new SensorDataFuzzyQryPagingParas()            {                DeviceID=119374,                ApiTags = "number_up"            };            var yxh = SDK.GetSensorDatas(query, TempInfo.API_HOST);             /*             修改前             return yxh.ResultObj.count;         */            if(yxh.IsSuccess())            {                return yxh.ResultObj.Count;            }            else            {                return 0;            }</code></pre><p>错误原因：出现这个问题是因为引用的对象是null或empty导致</p><p>声明变量时：T t = null;(T为类名),此时在栈上有一个地址。地址占4个字节，但地址没有任何指向，即指向内容为空。如果调用T的成员函数，出错：未将对象引用设置到对象实例</p><h2 id="不能在变量声明中指定数组大小"><a href="#不能在变量声明中指定数组大小" class="headerlink" title="不能在变量声明中指定数组大小"></a>不能在变量声明中指定数组大小</h2><p>不能在变量声明中指定数组大小（请尝试使用“new”表达式初始化）</p><p>将大小指定为数组声明的一部分时会发生此错误。 若要解决此错误，请使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/new-operator" target="_blank" rel="noopener">new 运算符</a>表达式。</p><p>下面的示例生成 CS0270：</p><pre class=" language-c#"><code class="language-c#">// CS0270.cs  // compile with: /t:module  public class Test  {     int[10] a;   // CS0270     // To resolve, use the following line instead:     // int[] a = new int[10];  }</code></pre><h1 id="动态图表LiveCharts"><a href="#动态图表LiveCharts" class="headerlink" title="动态图表LiveCharts"></a>动态图表LiveCharts</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>基本图表图线建立:<a href="http://www.manongjc.com/detail/14-bpxrwoalubxfjxk.html" target="_blank" rel="noopener">http://www.manongjc.com/detail/14-bpxrwoalubxfjxk.html</a></p><p>基本图形的数据绑定:<a href="https://www.liangzl.com/get-article-detail-172477.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-172477.html</a></p><pre class=" language-c#"><code class="language-c#"> mychart.Series = new SeriesCollection            {                new LineSeries                {                    Values = new ChartValues<int>(temp),                    DataLabels=true,                    Title = "当前人数"                }            };            //myAxisX.Labels = new[] { "", "", "", "", "","","","","","" };//横坐标定义            DateTime now = new DateTime();            for (int j = 0; j < 10; j++)            {                time1[j] = now.ToString();            }            myAxisX.Labels = time1;            myAxisY.MaxValue = 10;//纵坐标最大值定义            //myAxisY.LabelFormatter = value => value.ToString("0%");            myAxisY.Title = "人数";//纵坐标标题</code></pre><h2 id="设置曲线"><a href="#设置曲线" class="headerlink" title="设置曲线"></a>设置曲线</h2><pre class=" language-C#"><code class="language-C#">LineSeries mylineseries = new LineSeries();//首先实例化一条折线mylineseries.Title = "night";//设置折线名称mylineseries.Stroke = System.Windows.Media.Brushes.Black;//设置折线颜色mylineseries.StrokeThickness = 10;//设置折线粗细mylineseries.StrokeDashArray = new System.Windows.Media.DoubleCollection { 2 };//设置折线样式mylineseries.LineSmoothness = 1;//设置折线是否光滑mylineseries.Fill = System.Windows.Media.Brushes.LightBlue;//设置折线填充颜色</code></pre><h2 id="设置图表"><a href="#设置图表" class="headerlink" title="设置图表"></a>设置图表</h2><pre class=" language-c#"><code class="language-c#"><lvc:CartesianChart x:Name="mychart" Series="{Binding SeriesCollection}"/ >//首先在前台给图表命名mychart.Background = System.Windows.Media.Brushes.Gray;//设置图表的背景颜色mychart.LegendLocation = LegendLocation.Top;//设置图示位置</code></pre><h2 id="设置轴线"><a href="#设置轴线" class="headerlink" title="设置轴线"></a>设置轴线</h2><pre class=" language-xaml"><code class="language-xaml">//首先在前台对轴线命名<lvc:CartesianChart.AxisX>  <lvc:Axis x:Name="myaxisx"/>  </lvc:CartesianChart.AxisX>  </code></pre><pre class=" language-c#"><code class="language-c#">myaxisx.Separator.StrokeThickness = 10;//设置轴线粗细myaxisx.Separator.Step = 0.5;//设置轴线间隔myaxisx.Title = "Date";//设置轴线标题myaxisx.Position = AxisPosition.RightTop;//设置轴线标题myaxisx.Labels = new[]{ "Mon", "Tue","Wen","Thu","Fri","Sat","Sun"};//设置坐标轴标签myaxisx.LabelsRotation = 45;//设置坐标轴标签旋转角度</code></pre><h2 id="设置提示"><a href="#设置提示" class="headerlink" title="设置提示"></a>设置提示</h2><pre class=" language-xaml"><code class="language-xaml">//首先在前台对提示命名<lvc:CartesianChart.DataTooltip>  <lvc:DefaultTooltip x:Name="mytooltip"/>  </lvc:CartesianChart.DataTooltip>  </code></pre><pre class=" language-c#"><code class="language-c#">mytooltip.Background = System.Windows.Media.Brushes.LightCyan;//设置提示的背景颜色mytooltip.SelectionMode = TooltipSelectionMode.OnlySender;//设置提示的选择模式mytooltip.CornerRadius = new CornerRadius(5);//设置提示框的圆角半径</code></pre><pre class=" language-c#"><code class="language-c#">//设置提示框的边框颜色和大小mytooltip.BorderBrush = System.Windows.Media.Brushes.Yellow ;  mytooltip.BorderThickness = new Thickness (2);  </code></pre><p>以上所有后台代码设置均可以在前台实现同样的设置<br>部分前台设置如下：</p><pre class=" language-xaml"><code class="language-xaml"><lvc:CartesianChart.AxisY> <lvc:Axis Title="star" LabelFormatter="{Binding Formatter}" ></lvc:Axis> </lvc:CartesianChart.AxisY> </code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class=" language-xaml"><code class="language-xaml"><Window x:Class="chart_line.MainWindow"xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"xmlns:d="http://schemas.microsoft.com/expression/blend/2008"xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"xmlns:local="clr-namespace:chart_line"xmlns:lvc="clr-namespace:LiveCharts.Wpf;assembly=LiveCharts.Wpf"mc:Ignorable="d"Title="MainWindow" Height="350" Width="525"><Grid x:Name="grid"><lvc:CartesianChart x:Name="mychart" Series="{Binding SeriesCollection}" ><lvc:CartesianChart.AxisX><lvc:Axis x:Name="myaxisx"/></lvc:CartesianChart.AxisX><lvc:CartesianChart.AxisY><lvc:Axis Title="star" LabelFormatter="{Binding Formatter}" ></lvc:Axis></lvc:CartesianChart.AxisY><lvc:CartesianChart.DataTooltip><lvc:DefaultTooltip x:Name="mytooltip"  /></lvc:CartesianChart.DataTooltip></lvc:CartesianChart></Grid></Window></code></pre><pre class=" language-c#"><code class="language-c#">using LiveCharts;using LiveCharts.Wpf;namespace chart_line{/// <summary>/// Interaction logic for MainWindow.xaml/// </summary>public partial class MainWindow : Window{public SeriesCollection SeriesCollection { get; set; }public Func<double, string> Formatter { get; set; }public MainWindow(){InitializeComponent();LineSeries mylineseries = new LineSeries();mylineseries.Title = "night";mylineseries.Stroke = System.Windows.Media.Brushes.Blue ;mylineseries.StrokeThickness = 10;mylineseries.StrokeDashArray = new System.Windows.Media.DoubleCollection { 2 };mylineseries.LineSmoothness = 1;mylineseries.Fill = System.Windows.Media.Brushes.LightBlue  ;//mylineseries.PointGeometry = null;mychart.LegendLocation = LegendLocation.Top ;mychart.Background = System.Windows.Media.Brushes.Gray ;myaxisx.Separator.StrokeThickness = 10;myaxisx.Separator.Stroke= System.Windows.Media.Brushes.Red;myaxisx.Separator.Step = 0.5;myaxisx.Title = "Date";myaxisx.Position = AxisPosition.RightTop;//myaxisx.IsMerged = true;myaxisx.LabelsRotation = 45;myaxisx.Labels = new[]{ "Mon", "Tue","Wen","Thu","Fri","Sat","Sun"};//mytooltip.BulletSize = 10;mytooltip.Background = System.Windows.Media.Brushes.LightCyan  ;mytooltip.SelectionMode = TooltipSelectionMode.OnlySender;mytooltip.CornerRadius = new CornerRadius(5);mytooltip.BorderBrush = System.Windows.Media.Brushes.Yellow ;mytooltip.BorderThickness = new Thickness (2);double[] mynum = { 1, 3, 1, 6, 2, 9, 4 };mylineseries.Values = new ChartValues<double> ( mynum );Formatter = value => value + "-N";SeriesCollection = new SeriesCollection {mylineseries};DataContext = this;}}}</code></pre><p><img src="https://img-blog.csdnimg.cn/20190124225942411.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMTc2MTMz,size_16,color_FFFFFF,t_70" alt="效果图"></p><h1 id="XAML"><a href="#XAML" class="headerlink" title="XAML"></a>XAML</h1><p>作为XAML语言的一条规则，必须完全在该对象元素上的任何其他属性元素之前或之后完全指定XAML内容属性的值。例如，以下标记不会编译。</p><pre class=" language-xaml"><code class="language-xaml"><Button>I am a  <Button.Background>Blue</Button.Background>  blue button</Button></code></pre><h1 id="WPF控件"><a href="#WPF控件" class="headerlink" title="WPF控件"></a>WPF控件</h1><h2 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a><a href="https://www.cnblogs.com/Fred1987/p/6038608.html" target="_blank" rel="noopener">Slider</a></h2><h3 id="设置整数"><a href="#设置整数" class="headerlink" title="设置整数"></a>设置整数</h3><p>这个控件上值默认是浮点数，改变它的值可以拖动滑块，也可以在具有焦点的时候使用键盘，还可以点击滑块两侧的空白处（类似滚动条），值的步进有两个属性控制LargeChange和SmallChange，默认值分别是1和0.1，所以会出现1.3543这种情况，不过完全可以自定义的，添加代码：</p><pre class=" language-xaml"><code class="language-xaml">Ticks="1 2 3 4 5" //这个就是步进值的设置IsSnapToTickEnabled="True" //还要加上这一句才有效果</code></pre><p>或者</p><pre class=" language-xaml"><code class="language-xaml">SmallChange="1" IsSnapToTickEnabled="True"</code></pre><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>border作边框使用</p><pre class=" language-xaml"><code class="language-xaml">BorderBrush="Black"//设置边框颜色BorderThickness="2"//设置边框粗细</code></pre><h2 id="TextBlock"><a href="#TextBlock" class="headerlink" title="TextBlock"></a>TextBlock</h2><h3 id="TextBlock换行"><a href="#TextBlock换行" class="headerlink" title="TextBlock换行"></a><a href="https://www.cnblogs.com/wuzhenyi/archive/2013/01/13/2858797.html" target="_blank" rel="noopener">TextBlock换行</a></h3><p>新建一个TextBlock作为最基础的一个控件，他所携带的功能相对于其他的控件要来的比较少，</p><p>比较值得关注的属性出了布局用的以外和数据绑定意外，就只剩下的Text属性来。</p><p>TextBlock的默认内容属性是Text。</p><p>对于换行来说，需要关注的也就是Text和Inline2个属性。</p><p>常见的TextBlock换行方法</p><p>1）转义字符换行</p><p> 在XAML的后台文件中加入代码</p><pre class=" language-c#"><code class="language-c#">Me.TextBlock1.Text = "AAAAAAA " + vbCrLf + "BBBBBBBB"this.TextBlock1.Text = "AAAAAAA\nBBBBBBBB";</code></pre><p> 在XAML上写时</p><pre class=" language-xaml"><code class="language-xaml"><TextBlock Text="AAAAAAA&#x000A;BBBBBB"   Height="198" HorizontalAlignment="Left"            Margin="30,27,0,0" Name="TextBlock1" VerticalAlignment="Top" Width="436" >           </TextBlock></code></pre><p>这样就可以表示显示的表示换行了，</p><p>但是下面这种情况是无效的。</p><pre class=" language-xaml"><code class="language-xaml">        <TextBlock  Height="198" HorizontalAlignment="Left"                    Margin="30,27,0,0" Name="TextBlock1" VerticalAlignment="Top" Width="436" >             AAAAAAA&#x000A;BBBBBB        </TextBlock></code></pre><p>在Text的内容里赋值时候，会按照XML去解析，所以对于XML的转义字符都会起到他们的作用，而上面这种情况，虽然这种写法是</p><p>是默认获取TextBlock的内容属性，但是在赋值过程中会经过Convert按照String来处理，字符串中解析到换行符时，默认转成了空格。</p><p>所以你看到的结果AAAAAAA和BBBBBB并没有被换行表示，只是中间隔了一个空格。</p><p>另外XML的转义字符:</p><p><strong>空格</strong> (&amp;#x0020;)<br>Tab (&amp;#x0009;)<br><strong>回车</strong> (&amp;#x000D;)<br><strong>换行</strong> (&amp;#x000A;)</p><p> 2）设置属性，自动换行</p><p>因为TextBlock有TextWrapping属性的支持，根据控件宽度自动设置换行，没有特殊要求的时候，这基本上能满足需求</p><pre class=" language-xaml"><code class="language-xaml">        <TextBlock  Height="49" HorizontalAlignment="Left"                    Margin="30,27,0,0" Name="TextBlock1" VerticalAlignment="Top" Width="60" TextWrapping="Wrap">             AAAAAAABBBBBB        </TextBlock></code></pre><p>3）使用InLines属性的LineBreak来换行</p><p>简单的来说就是，显示的XAML表示用</p><pre class=" language-xaml"><code class="language-xaml">        <TextBlock  Height="49" HorizontalAlignment="Left"                    Margin="30,27,0,0" Name="TextBlock1" VerticalAlignment="Top" Width="60" TextWrapping="Wrap">             <Run>AAAAAA</Run>            <LineBreak/>            <Run>BBBBBB</Run>        </TextBlock></code></pre><p>后台代码添加</p><pre class=" language-c#"><code class="language-c#">        TextBlock1.Inlines.Add(New Run("AAAAAA"))        TextBlock1.Inlines.Add(New LineBreak())        TextBlock1.Inlines.Add(New Run("BBBB"))</code></pre><p>另外如果RUN里面有大量的文字表示，超过了TextBlock的Width时候，文字会被剪切掉，而不是自动换行，这点需要注意一下</p><h1 id="WPF美化"><a href="#WPF美化" class="headerlink" title="WPF美化"></a>WPF美化</h1><h2 id="MaterialDesignInXaml"><a href="#MaterialDesignInXaml" class="headerlink" title="MaterialDesignInXaml"></a>MaterialDesignInXaml</h2><p>美化包：MaterialDesignInXaml</p><p>导入包：管理Nuget程序包中搜索美化包名</p><p>使用前添加引用：</p><pre class=" language-xaml"><code class="language-xaml"> xmlns:materialDesign="http://materialdesigninxaml.net/winfx/xaml/themes"</code></pre><p>App.xaml文件添加引用：</p><pre class=" language-xaml"><code class="language-xaml"><ResourceDictionary>            <ResourceDictionary.MergedDictionaries>                <ResourceDictionary Source="pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml" />                <ResourceDictionary Source="pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml" />                <ResourceDictionary Source="pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml" />                <ResourceDictionary Source="pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml" />            </ResourceDictionary.MergedDictionaries>            </ResourceDictionary></code></pre><pre class=" language-xaml"><code class="language-xaml"> <Grid Name="myGrid" Width="auto" ShowGridLines="False" Background="AliceBlue">        <Grid.RowDefinitions>            <RowDefinition Height="150"/>            <RowDefinition Height="75"/>            <RowDefinition Height="75"/>            <RowDefinition Height="80"/>            <RowDefinition Height="150"/>        </Grid.RowDefinitions>        <Grid.ColumnDefinitions>            <ColumnDefinition Width="200"/>            <ColumnDefinition Width="*"/>            <ColumnDefinition Width="200" />        </Grid.ColumnDefinitions>        <!--为什么放大窗口后textbox比textblock要长？？-->        <TextBlock Grid.Row="0" Grid.Column="1" Text="登录SwissArmyKnife系统" FontSize="32" TextAlignment="Center" Margin="0,70,0,30"/>        <TextBox Grid.Row="1" Grid.Column="1" Text="请输入账号"  FontSize="32" Margin="50,15"/>        <PasswordBox Grid.Row="2" Grid.Column="1"  ToolTip="请输入密码" Margin="50,15" FontSize="32"                       x:Name="FloatingPasswordBox"                     materialDesign:HintAssist.Hint="请输入密码"                     materialDesign:HintAssist.Foreground="Green"                     materialDesign:TextFieldAssist.UnderlineBrush="Green"                     Style="{StaticResource MaterialDesignFloatingHintPasswordBox}" />        <Button Grid.Row="3" Grid.Column="1" Content="登录" FontSize="20" Margin="40,15" />    </Grid></code></pre><h3 id="简单对话框"><a href="#简单对话框" class="headerlink" title="简单对话框"></a>简单对话框</h3><p>来自：<a href="https://blog.csdn.net/bondw/article/details/102762482" target="_blank" rel="noopener">https://blog.csdn.net/bondw/article/details/102762482</a></p><p>效果图：</p><p><img src="https://img-blog.csdnimg.cn/20191027002851125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbmR3,size_16,color_FFFFFF,t_70" alt="简单对话框demo"></p><p>定义对话框模板SampleMessageDialog.xaml</p><p>注意需要向解决方案添加用户控制窗口，否则会报错</p><pre class=" language-xaml"><code class="language-xaml"><UserControl x:Class="test.SampleMessageDialog"     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"     xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"     xmlns:d="http://schemas.microsoft.com/expression/blend/2008"     xmlns:materialDesign="http://materialdesigninxaml.net/winfx/xaml/themes"     mc:Ignorable="d" d:DesignHeight="300" d:DesignWidth="300" MaxWidth="400">    <Grid Margin="16">        <Grid.RowDefinitions>            <RowDefinition />            <RowDefinition />        </Grid.RowDefinitions>        <TextBlock x:Name="Message" Margin="0 6 0 0" FontSize="18" Grid.Row="0" />        <Button Grid.Row="1" IsDefault="True" Style="{DynamicResource MaterialDesignFlatButton}" HorizontalAlignment="Right" Margin="16 16 16 0" Command="{x:Static materialDesign:DialogHost.CloseDialogCommand}">            ACCEPT        </Button>    </Grid></UserControl></code></pre><p>对应的SampleMessageDialog.cs</p><pre><code>using System.Windows.Controls;namespace test{    /// &lt;summary&gt;    /// Interaction logic for SampleMessageDialog.xaml    /// &lt;/summary&gt;    public partial class SampleMessageDialog : UserControl    {        public SampleMessageDialog()        {            InitializeComponent();        }    }}</code></pre><p>对应的函数</p><pre class=" language-c#"><code class="language-c#">public async void MessageTips(string message, object sender, RoutedEventArgs e){    var sampleMessageDialog = new SampleMessageDialog    {        Message = { Text = message }    };    await DialogHost.Show(sampleMessageDialog, "RootDialog");}</code></pre><p>在需要的位置使用</p><pre class=" language-xaml"><code class="language-xaml">MessageTips("请确认", sender, e);</code></pre><p><strong>坑</strong></p><p>直接用，会报错：<br>System.InvalidOperationException:“No loaded DialogHost instances.”<br>原因是对话框放置的位置找不到，这个放置的位置就是这里的 <strong>RootDialog</strong></p><pre class=" language-c#"><code class="language-c#">await DialogHost.Show(sampleMessageDialog, "RootDialog");</code></pre><p>需要在windows.xaml里设置，把GRID内容放入到如下容器里面</p><pre class=" language-xaml"><code class="language-xaml"><materialDesign:DialogHost Identifier="RootDialog">……</materialDesign:DialogHost></code></pre><h2 id="导入ttf"><a href="#导入ttf" class="headerlink" title="导入ttf"></a>导入ttf</h2><p>因为实现ImageButton接触ttf在wpf中的使用，ttf是图标按钮的集合文件。可在阿里<a href="http://www.iconfont.cn网站选择下载。首先选择所需图标添加到购物车，选择完成后从购物车中选择“下载代码”，便可将其中的图标打包生成ttf文件并下载至本地。下载的文件夹中包含图一所示文件，其中iconfont.ttf是程序所需文件，打开该文件可看到“字体名称”，程序根据该名称查找ttf文件。程序中引用该文件首先需将该字体包设置为Resource，如FontFamily。" target="_blank" rel="noopener">www.iconfont.cn网站选择下载。首先选择所需图标添加到购物车，选择完成后从购物车中选择“下载代码”，便可将其中的图标打包生成ttf文件并下载至本地。下载的文件夹中包含图一所示文件，其中iconfont.ttf是程序所需文件，打开该文件可看到“字体名称”，程序根据该名称查找ttf文件。程序中引用该文件首先需将该字体包设置为Resource，如FontFamily。</a></p><p> c#代码中的引用格式为“#”+”字体名称”。iconfont.cn中下载的字体名称一般都是“iconfont”，所以引用时使用“#iconfont”即可，实例截取：component/Resources/#iconfont”。</p><p><img src="https://images2015.cnblogs.com/blog/649940/201705/649940-20170519154738478-128340687.png" alt="img"></p><p>图中的demo_unicode.html包含了ttf文件中的unicode编码，如图二所示。wpf中引用时，在xaml和xaml.cs中的方式有所不同。如arrow-left图标的编码是“&amp;#xe614;”，当在xaml中引用时需要直接复制该编码，而在代码(.cs文件)中引用时，格式为“\ue614”。</p><p>　　具体介绍在App.xaml中设置为程序资源（Application.Resources）的方法及使用步骤：</p><p>　　　　步骤1，在App.xaml中设置如下，其中ttf资源文件所在目录为WpfUI/Resources/，WpfUI是项目名称，iconfont.ttf是字体库文件名，iconfont是字体库的“字体名称”。</p><pre class=" language-xaml"><code class="language-xaml"><Application.Resources>        <FontFamily x:Key="IconFont">            pack://application:,,,/WpfUI;component/Resources/iconfont.ttf#iconfont        </FontFamily>        <!--其他设置--></Application.Resources></code></pre><p>步骤2，在xaml中应用到目标，以设置MenuItem图标为例</p><pre class=" language-xaml"><code class="language-xaml"><MenuItem Name="menuItem1" Header="Icon示例" Icon="&#xe61a;" FontFamily="{StaticResource IconFont}"</code></pre><p>当前项目常用图标地址：<a href="http://www.iconfont.cn/collections/detail?cid=4215" target="_blank" rel="noopener">http://www.iconfont.cn/collections/detail?cid=4215</a></p><h2 id="PanuonUI-Silver"><a href="#PanuonUI-Silver" class="headerlink" title="PanuonUI.Silver"></a><strong><a href="https://gitee.com/panuon/PanuonUI.Silver" target="_blank" rel="noopener">PanuonUI.Silver</a></strong></h2><p>WPF 的第三方UI库，基于PanuonUI拓展开发的</p><p>gitee：<a href="https://gitee.com/panuon/PanuonUI.Silver" target="_blank" rel="noopener">https://gitee.com/panuon/PanuonUI.Silver</a></p><p>PanuonUI.Silver 2.0手册：<a href="https://www.yuque.com/mochengvia/silver2.0" target="_blank" rel="noopener">https://www.yuque.com/mochengvia/silver2.0</a></p><h2 id="DMSkin"><a href="#DMSkin" class="headerlink" title="DMSkin"></a>DMSkin</h2><p>WPF的第三方库，看了下作者的基于自己的DMSkin写的示例程序，特别棒！</p><p>已经fork到自己的仓库了： <a href="https://github.com/AuntYang/DMSkin" target="_blank" rel="noopener">https://github.com/AuntYang/DMSkin</a></p><h2 id="HandyControl"><a href="#HandyControl" class="headerlink" title="HandyControl"></a><a href="https://github.com/HandyOrg/HandyControl" target="_blank" rel="noopener">HandyControl</a></h2><p>WPF的第三方库，在GitHub上开源的中国开发者开发的第三方库，目前不是特别完善，但每个月都在更新。</p><p>HandyControl：<a href="https://github.com/HandyOrg/HandyControl" target="_blank" rel="noopener">https://github.com/HandyOrg/HandyControl</a></p><p>文档：<a href="https://handyorg.github.io/handycontrol" target="_blank" rel="noopener">https://handyorg.github.io/handycontrol</a></p><h2 id="MahApps-Metro"><a href="#MahApps-Metro" class="headerlink" title=" MahApps.Metro"></a><strong><a href="https://github.com/MahApps/MahApps.Metro" target="_blank" rel="noopener"> MahApps.Metro</a></strong></h2><p>WPF的第三方库，同样在Github上开源的免费库，可以在Nuget上添加引用。</p><p>MahApps.Metro：<a href="https://github.com/MahApps/MahApps.Metro" target="_blank" rel="noopener">https://github.com/MahApps/MahApps.Metro</a></p></object></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 物联网大赛 </tag>
            
            <tag> WPF </tag>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#之WPF学习</title>
      <link href="/2020/07/08/c-zhi-wpf/"/>
      <url>/2020/07/08/c-zhi-wpf/</url>
      
        <content type="html"><![CDATA[<h1 id="WPF界面布局与控件"><a href="#WPF界面布局与控件" class="headerlink" title="WPF界面布局与控件"></a>WPF界面布局与控件</h1><h2 id="WPF界面布局"><a href="#WPF界面布局" class="headerlink" title="WPF界面布局"></a>WPF界面布局</h2><h1 id="WPF样式引用及样式存放"><a href="#WPF样式引用及样式存放" class="headerlink" title="WPF样式引用及样式存放"></a>WPF样式引用及样式存放</h1><h2 id="独立的样式文件xmal-类似css"><a href="#独立的样式文件xmal-类似css" class="headerlink" title="独立的样式文件xmal(类似css)"></a>独立的样式文件xmal(类似css)</h2><h2 id="将样式包含在设计界面"><a href="#将样式包含在设计界面" class="headerlink" title="将样式包含在设计界面"></a>将样式包含在设计界面</h2><h2 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h2><h2 id="UI界面的路由事件"><a href="#UI界面的路由事件" class="headerlink" title="UI界面的路由事件"></a>UI界面的路由事件</h2><h1 id="WPF主窗体设置"><a href="#WPF主窗体设置" class="headerlink" title="WPF主窗体设置"></a>WPF主窗体设置</h1><p>问题情景：一项目需多窗口，在建立项目时得到的MainWindow.xaml窗口默认为整个程序启动的主窗体，而实际程序编写时MainWindow并不是作为启动的主窗体，此时需要修改配置文件，将需要的窗体修改为程序启动的主窗体。</p><h2 id="APP-xaml文件"><a href="#APP-xaml文件" class="headerlink" title="APP.xaml文件"></a>APP.xaml文件</h2><pre class=" language-xaml"><code class="language-xaml"><Application x:Class="testWpf.App"                                               xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"   xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    StartupUri="Window2.xaml"> <Application.Resources>    </Application.Resources></Application></code></pre><p>可以在App.xaml文件中设置StartupUri属性来决定哪个窗口是主要窗口</p><h1 id="WPF中Textbox设置提示文字"><a href="#WPF中Textbox设置提示文字" class="headerlink" title="WPF中Textbox设置提示文字"></a>WPF中Textbox设置提示文字</h1><p>原理是在textbox上遮罩一个Brush，Brush上写提示文字，在Brush接收到聚焦时消失，上代码：</p><pre class=" language-xaml"><code class="language-xaml"><TextBox Width="150" Margin="5">    <TextBox.Resources>        <VisualBrush x:Key="HintText" TileMode="None" Opacity="0.5" Stretch="None" AlignmentX="Left">            <VisualBrush.Visual>                <TextBlock FontStyle="Italic" Text="请输入用户名"/>            </VisualBrush.Visual>        </VisualBrush>    </TextBox.Resources>    <TextBox.Style>        <Style TargetType="TextBox">            <Style.Triggers>                <Trigger Property="Text" Value="{x:Null}">                    <Setter Property="Background" Value="{StaticResource HintText}"/>                </Trigger>                <Trigger Property="Text" Value="">                    <Setter Property="Background" Value="{StaticResource HintText}"/>                </Trigger>            </Style.Triggers>        </Style>    </TextBox.Style></TextBox></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 物联网大赛 </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学术英语复习笔记</title>
      <link href="/2020/06/21/xue-zhu-ying-yu-fu-xi-bi-ji/"/>
      <url>/2020/06/21/xue-zhu-ying-yu-fu-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Text5"><a href="#Text5" class="headerlink" title="Text5"></a>Text5</h1><p>Litigable [‘lɪtɪɡəbl]: a. 可诉讼的，可作诉讼标的</p><p>Pot: n. 赌注总额</p><p>Specter[‘spɛktɚ]: n. 恶兆</p><p>For good or ill: 不管结果如何</p><p>Mob: n. 暴民，乱民</p><p>Uplift: v. 使高涨、振奋</p><p>Shrinkage: n 收缩，减少，降低</p><p>Dispossessed[,dɪspə’zɛst]: a. 被夺走的，被剥夺的</p><p>Displace: v. t. 取代，代替</p><p>Barter[‘bɑːtə]: v. 交换</p><p>Canal[kə’næl]: n. 运河</p><p>Ranching [‘ræntʃɪŋ]: n. 牧场经营</p><p>Bushel [‘bʊʃ(ə)l]:. c. 蒲式耳（在美国=35.24 升）</p><p>Plough [plaʊ]/ plow: n. 犁</p><p>Sow [səʊ]: v. t. 播种</p><p>Harvester: n. 收割机</p><p>Superfluous [sjuː ‘pɜːflʊəs;]: a. 多余的</p><p>Raw: a. 未加工过的，天然的</p><p>Handcraft [‘hæn(d)krɑːft]: v. t. 用手工制作</p><p>Deskill  降低…的技术要求,使非技能化 </p><p>Undercut: v. t. 逐渐削弱，逐渐破坏</p><p>Elder: n. 长者，长辈</p><p>Turn the / a corner: 好转，有起色</p><p> superfluous  多余的 more than is needed, desired, or required</p><p>moan  抱怨，悲叹 a groan or an utterance expressing pain or disapproval</p><p>craftsman  手艺人 a creator of great skill in the manual arts</p><p>biomedical 生物医学的relating to the activities and applications of science to clinical medicine</p><p>dispossessed无依无靠的physically or spiritually homeless or deprived of security</p><p>manufacture 制造，生产the act of making something(a product from raw materials</p><p>Unemploy 解雇，失业 lay off</p><p>shrinkage收缩，减低process or result of becoming less or smaller</p><p>entertainer表演者a person who tries to please or amuse</p><p>deskill使 降低技能化remove or reduce the need for skill in a job, usually by changing to machinery</p><p>1 electric power   automation   (自动化) equipment</p><p>2 occupational  (职业的) disease</p><p>3 illegal      immigrant     (移民)</p><p>4 Music can     uplift   (振奋) your spirits.</p><p>5 result in substantial population      displacement        (  转移)</p><p>6 the        hand-crafted      (手工制作的) furniture</p><p>7 He has     ranched     (在牧场工作) in the north for 20 years.</p><p>8 eat      nutritious     (有营养的) food</p><p>9 be     involved     (卷入) in the trouble</p><p>10 a new      assembly      (装配) line</p><p>11      yield  (屈服) to the enemy</p><p>12 make      incredible      (难以置信的) progress</p><p>13 unrealistic      optimism     (乐观)</p><p>14 in recent    mob    (暴徒) violence</p><p>15 get     professional   (专业的) help</p><p>16 the luggage should be    labelled   (加上标签)</p><p>17 financial    analyst     (分析员)  </p><p>18 trade    surplus      (盈余)</p><p>19 attack on pearl     harbor    (海港)</p><p>20 a professional      columnist      (专栏作家)</p><p>21 the      virtual   (事实上的) manager of the business</p><p>22 underestimate the strength of the    revolutionary    (革命的) forces</p><p>23 untie the   lace    (鞋带) and take off your shoes</p><p>24 They are trying to      undercut     (削弱) his authority</p><p>25    barter     (交换) furs for guns</p><p>26 a(n)      litigable     (可诉讼的) case</p><p>27 raise the     specter     (恐惧) of oil crisis</p><p>28   sift   (仔细翻看) through her purse</p><p>29 He has got a(n)    pot   (大量的) of money.</p><table><thead><tr><th>agriculture</th><th>analyst</th><th>assembly</th><th>automation</th><th>barter</th></tr></thead><tbody><tr><td>bushel</td><td>columnist</td><td>displacement</td><td>document</td><td>handcrafted</td></tr><tr><td>harbor</td><td>immigrant</td><td>incredibly</td><td>instructor</td><td>involve</td></tr><tr><td>item</td><td>label</td><td>lace</td><td>litigable</td><td>mob</td></tr><tr><td>nutritious</td><td>occupational</td><td>optimism</td><td>pot</td><td>professional</td></tr><tr><td>ranch</td><td>revolutionary</td><td>sift</td><td>specter</td><td>surplus</td></tr><tr><td>undercut</td><td>uplift</td><td>virtual</td><td>yield</td><td></td></tr></tbody></table><h1 id="Text8"><a href="#Text8" class="headerlink" title="Text8"></a>Text8</h1><p>Convergence [kən’vɜːdʒəns]</p><p> n. 会合（倾向），会合点，会聚点</p><p>Devour [dɪ’vaʊə]: v. t. 吞食，耗尽，吞没，席卷</p><p>Light: a. 精致的，轻巧的，灵巧的</p><p>Come of sth: 是…的结果</p><p>I wrote to over twenty companies asking for work, but nothing came of my efforts.</p><p>Micrometer: 微米 1000,000/1 米</p><p>Nano-: 表示“毫微” 1,000,000,000/1</p><p>Nucleus: 原子核</p><p>Element: n. 成分，性质，基本组成部分，要素，（人的）一组，自然环境</p><p>Quantum [‘kwɒntəm]  mechanics [mɪ’kænɪks]</p><p>量子力学</p><p>Surface area: 表面面积</p><p>Erratic [ɪ’rætɪk]: a. 不稳定的，不确定的，不规则的</p><p>Teleport: v. t. 心灵运输（物体、人）,远距离传送</p><p>Tunnel: v. i. 掘隧道，穿透势垒，隧穿</p><p>Bulk [bʌlk]: n. 巨大的体积，大块，大多数</p><p>In bulk: 大量，大批，整体</p><p>Assemble: v. t. 集合，聚集，收集，装配</p><p>Microprocessor [maɪkrə(ʊ)’prəʊsesə]: n. 微处理机</p><p>Franchise [‘fræn(t)ʃaɪz]: n. 公民权，特许经销权</p><p>Replicator[‘rɛplɪketɚ]: n. 复制基因，复制者</p><p>Scopic: a. 观察仪器的，显示器的</p><p>Assembler: n. 装配工，装配器，汇编语言</p><p>按照计划指导，为…制定计划</p><p>Trillion: n. 万亿，兆</p><p>Trillions: 大量，无数</p><p>Gear: n. 齿轮，工具，设备</p><p>Fabricate  [‘fæbrɪkeɪt]: v. t. 制造，组装，创造</p><p>Surgeon: n. 外科医师，军医</p><p>Scalpel [‘skælp(ə)l]: n. 解剖刀</p><p>Airborne [‘eəbɔːn]: a. 升空的，在空中的，在飞行中的</p><p>Bottom-up: a. 从细节到总体的</p><p>Renewable: a. 能源等可再生的</p><p>Drill: v. t. 钻洞，钻孔，钻井勘探</p><p>Hype: n. 大肆的广告宣传；炒作</p><p>Dissipate [‘dɪsɪpeɪt]: v. 消散，逐渐消失</p><p>Build: v. 增长，增强</p><p>Rigorous [‘rɪg(ə)rəs]: a. 仔细的，严密的，严格的</p><p> bring or call together into a group or whole      assemble 聚集</p><p> a specific use to which something is put             application 应用</p><p>a supposition, theory, or opinion arrived at through speculating      speculation推测，思索</p><p>give all your attention and effort to one particular thing            dedicate 投入</p><p>of or relating to an atom or atoms                atomic 原子的</p><p>eat up greedily                devour吞食</p><p>at the very end; finally                eventually</p><p>forming a satisfactory or balanced whole        <strong><em>\</em>complementary补充的，互补的**</strong>    </p><p>decrease in size, extent, or range            diminish 减少，缩小</p><p>of or near the present time            immediate</p><p>1We love the valley in all its      aspects     (方面).</p><p>2 Please     replicate      (折叠) the paper.</p><p>3 The two accidents took place        <strong><em>\</em>simultaneously         (同时地**</strong>)</p><p>4 There was an air of      expectancy        (期望) among the waiting</p><p>5 Article in The Wall Street      <strong><em>\</em>Journ*****</strong>*al*<strong>*     *</strong>*(日报****) leans heavily on</p><p>6 What does it require to be a successful      mechanic       (技工)</p><p>7 Thousands of wounded were brought to the next town where he arrived and there was  practically   (几乎) no medical aid.</p><p>8 A text message confirming the policy number and sale is then sent (自动的)<strong><em>\</em>automatically**</strong></p><p>9 He says the troops will have to launch     <strong><em>\</em>precise    (精确的**</strong>) attack</p><p>10 The trouble was that he never had a(n)     specific     (明确的) aim</p><p>11 Kevin drove       erratically     (不规律地), knocked down several cones, and ran over at least one of the inflatable dolls.</p><p>12 This is a(n)       exclusive    (纯粹的) white residential area.</p><p>13 “Good morning” is a(n)        conventional       (传统的) greeting.</p><p>14 Honesty and kindness are      elements     (基础) of a good life.</p><p>15 I needed a place to fire ceramic        semiconductor         (半导体)</p><p>16 The findings reported its findings in the journal Nature Structural and           <strong><em>\</em>Molecular(分子**</strong>的) Biology.</p><p>17 It is a(n)    vast    (广阔的) desert.</p><p>18 The         appearance    (外貌) of the old house changed.</p><p>19 The dispute has scared away     potential      (潜在的) investors.</p><p>20 This small house is my only      property     (资产).</p><p>21 Do you know how to        <strong><em>\</em>manipulate     (操作**</strong>) a computer?</p><p>22 You are not allowed to      fabricate     (伪造) a certificate.</p><p>23 It is hard to      foresee      (预见) what will happen.</p><p>24 The       substance     (主旨) of his speech was that he was better</p><p>25 Exceptions cannot be made for    individual        (个体).</p><p>26 She then looked at the     reverse    (反面) side of the coin.</p><p>27 They were in         theoretical       (理论上的) harmony.</p><h1 id="Text9"><a href="#Text9" class="headerlink" title="Text9"></a>Text9</h1><p>Jocular [‘dʒɒkjʊlə]: a. 爱开玩笑的</p><p>Geophysics[,dʒiːə(ʊ)’fɪzɪks]: 地球物理学</p><p>Prominent  [‘prɒmɪnənt]: a. 突出的，杰出的</p><p>Magnitude[‘mægnɪtjuːd]: n. 巨大，广大，重要性，量，数值</p><p>Intensity /ɪnˈtensəti/ : n. 强烈，剧烈，强度，烈度</p><p>Amplify[‘æmplɪfaɪ]: v. 增强，扩大</p><p>Arctic /ˈɑːktɪk/: a. 北极的 n. 北极</p><p>Perennial [pə’renɪəl]: a. 终年的，常年的，长期的</p><p>Dramatically  /drəˈmætɪkli/ : adv. 引人注目地，剧烈地</p><p>Shelter  /ˈʃeltə(r)/ : n. 动物的栖息处</p><p>Seal /siːl/ : n. 海豹</p><p>Den  /den/ : n. 兽穴，兽窝，洞穴</p><p>Carry /ˈkæri/ : n. 运载的方法</p><p>Concurrently[ kən’kɝrəntli]: adv. 同时发生地，并存地</p><p>Vegetation[vedʒɪ‘teɪʃ(ə)n]: n. 植物，草木，植被</p><p>Reproduce  /ˌriːprəˈdjuːs/: v. 繁育，使繁殖</p><p>Depletion [dɪ’pliːʃn]: n. 空虚，耗尽，枯竭</p><p>Allergen [‘ælədʒ(ə)n]: n. 过敏源 ，变态反应</p><p>Ongoing: a. 进行中的，不间断的</p><p>Chlorofluorocarbon [‘klɔ:rəu,fluərəu’kɑ:bən]: n. 含氯氟烃</p><p>Gasoline /ˈɡæsəliːn/ : n. 汽油 </p><p>英petrol /ˈpetrəl/ = 美 gasoline</p><p>Hydrocarbon[,haɪdrə(ʊ)’kɑːb(ə)n]: n. 碳氢化合物</p><p>Absorbent [əb’zɔːb(ə)nt; -‘sɔːb-]: a. 能吸收的 n. 吸收剂，吸收物</p><p>Abundant[əˈbʌndənt]: a. 大量的，充足的</p><p>Drastic  /ˈdræstɪk/ : a. 猛烈的</p><p>Asphalt[‘æsfælt]: n. u. 沥青，柏油</p><p>Nitrous[‘naɪtrəs] oxide: n. 一氧化二氮，笑气</p><p>Microbes /‘maɪkrob微生物</p><p>= microorganism  /ˌmaɪkrəʊˈɔːɡənɪzəm/</p><p>Fertilizer[‘fɜːtɪlaɪzə]: n. 肥料</p><p>Fossil  /ˈfɒsl/ fuel : n. 矿物燃料</p><p>Slash[slæʃ] and burn: 刀耕火种  指把草木烧成灰当作肥料；就地挖坑播下种子。 </p><p>Retention [rɪ’tenʃ(ə)n]: n. 保留，留住，保存，存放</p><p>Simulate[‘sɪmjʊleɪt]: v. t. 模拟，模仿</p><p>Verify  /ˈverɪfaɪ/: v. t. 核实，证明</p><p>Brutality[brʊ’tælɪtɪ]: n. 残忍，野蛮，粗暴</p><p>Exposure [ɪk’spəʊʒə]: n. 暴露，经历，接触</p><p>Fusion[‘fjuːʒ(ə)n]: n. 核聚变</p><p>Put forth: 提出，建议，使出，发挥</p><p>Put forth one’s effort 尽力</p><p>Suffocate [‘sʌfəkeɪt]: v. t. 使窒息</p><p>existing or happening at the same time            concurrently 同时发生地</p><p>acting, done or given willingly; not forced or compelled            voluntary</p><p>damage or destruction affecting a large area or a lot of people   devastation破坏</p><p>make or produce something that is not real but has the appearance or feeling of being real    simulate模仿,假冒</p><p>the act of decreasing something marke            depletion消耗</p><p>present in great quantity            abundant</p><p>previous determination as if by destiny or fate        predestination宿命论，预先注定</p><p>the trait of extreme cruelty                brutality 残忍</p><p>the remains (or an impression) of a plant or animal that existed in a past geological age and that has been excavated  /‘ɛkskə,vet/ from the soil                fossil 化石</p><p>greatly and suddenly                dramatically剧烈地</p><p>1 the       magnitude     (巨大) of loss</p><p>2 increase       significantly      (显著地) overnight</p><p>3       atmosphere      (大气) pressure</p><p>4 work with greater    intensity      (紧张)</p><p>5 give     evidence     (证据) in support of a theory</p><p>6 birds     migrating      (迁徙) in winter</p><p>7 speak more    specifically        (明确地) /spəˈsɪfɪkli/ </p><p>8    amplify     (增强) the electric current</p><p>9 a disease of frequent      occurrence        (发生)</p><p>10 be in control of your own     destiny     (命运)</p><p>11 strong       motivation     (动机) to succeed</p><p>12    annual     (年度的) bonus</p><p>13 be     released      (释放) from prison</p><p>14 a(n)     vicious    (恶毒的) enemy to defeat</p><p>15 create a(n)          environmentally      (有关环境方面) safe society</p><p>16    alternate      (交替) between rain and sunshine</p><p>17 the most       prominent     (突出的) feature </p><p>18 his     reaction     (反应) to the news</p><p>19        drastically    (大幅度地) cutting staff</p><p>20 traffic      regulation      (规则)</p><p>21 a(n)    minimal    (最小的) charge for the service</p><p>22      exposure     (暴露) of the body to sunlight</p><p>23     retain    (保持) youthful vigor</p><p>24     compound       (混合) the ingredients</p><p>25 They are free       eventually     (最后).</p><p>26     decline    (谢绝) an invitation</p><p>27 Man is a reasoning     creature     (生物).</p><h1 id="Text-10"><a href="#Text-10" class="headerlink" title="Text 10"></a>Text 10</h1><p>an event or set of events that forms part of a longer series but is considered separately episode 一个事件</p><p>make known the presence or arrival of  herald  /ˈherəld/ 预示来临</p><p>approve and sanction formally  ratify 批准，认可</p><p>marked, prominent, obvious  pronounced明显的</p><p>impossible to refute  irrefutable不可反驳的</p><p>done contrary to or without choice  involuntarily非自愿的</p><p>the force that keeps an object in the same position, or keeps it moving until it is moved or stopped by another force  inertia  /ɪˈnɜːʃə/惯性</p><p>wear down, polish, or sharpen by friction  grind 磨碎</p><p>certain to happen and unable to be avoided or prevented   inevitable必然的</p><p>higher than normal  elevated  提高的</p><p>1   undergo   (经历) a smooth transition</p><p>2 be offered     massive   (大量的) sums to leave</p><p>3    unprecedented       (史无前例的) reforms</p><p>4    runaway   (失控的) inflation</p><p>5 achieve a wide variety of    consensus     (共识)</p><p>6 such a mon will largely   hinder   (阻碍) any move</p><p>7 total farm   output    (产量) for this year</p><p>8 a child’s      concentration span      (注意力集中的时间)</p><p>9 paint a(n)    bleak  (无望的) picture for the future</p><p>10      make a dent    (有点进展) in the work</p><p>11       constantly    (经常地) changing population</p><p>12 complete the project with a (结果)  outcome</p><p>13    play down     (淡化) the significance of the meeting</p><p>14 temperature     variation   (变化) due to solar radiation</p><p>15 skills that are      absolutely    (绝对地) vital </p><p>16     denigrate  (诋毁) his rivals/ˈdenɪɡreɪt/ </p><p>17 Don’t     mess with    (干预) things you don’t know.</p><p>18 windows which admit light but totally    insulate   (隔离</p><p>19 resist the       overwhelming     (无法抗拒的) temptation </p><p>20 witness the results of    savage    (野蛮的) attacks</p><p>21 take actions to help   resolve   (解决) housing problem</p><p>22 create a(n)     gigantic (巨大的) bubble in shares</p><p>23 the system which reduced pollution    output   (输出) to</p><p>24 conditions that vary     dramatically      (戏剧化地) day</p><p>25 ban the use of     sex-selective    (性别选择性的)</p><h1 id="Text-15"><a href="#Text-15" class="headerlink" title="Text 15"></a>Text 15</h1><p>force something to experience something very unpleasant, especially over a long time    <strong><em>\</em>subjec**</strong>t使遭受</p><p>making you feel worried or upset     disturbing 烦扰的</p><p>expressing strong opinions publicly, especially about things that you disagree    vocal直言不讳的<br>go beyond; overcome        exceed 超过，超越<br>illness, especially a slight one     ailment  小病，不安</p><p>of morals or moral questions    ethical 伦理的</p><p>prevent something from having any effect        neutralize抵消，使无效</p><p>assigning some quality or character to a person or thing     attribution赋予 (某品质或特点)</p><p>something that encourages somebody to do something; stimulus     incentive激励；鼓励</p><p>not getting adequate food     underfed营养不良的</p><p>1      genetically   (基因上地) engineering</p><p>2 advantages    outweigh    (比……重要) disadvantages greatly</p><p>3     infrastructure       (基础设施) construction/ˈɪnfrəstrʌktʃə(r)/ </p><p>4     statistics     (统计) analysis</p><p>5 will soon     resolve   (解决) all the difficulties</p><p>6      financial  (金融的) institution</p><p>7     rigorous    (严格的) discipline</p><p>8    spark  (点燃) the flames of revolution</p><p>9 be in     collaboration   (合作) with your partner</p><p>10 a(n)    desperate   (绝望的) cry for help</p><p>   (改变) alter     the bad habit</p><p>12 resources of     cultivable     (可耕种的) land</p><p>13     temper   (缓和) criticism with reason</p><p>14    lobby   (游说……以争取) for the funds</p><p>15 He is at the      leading-edge    (领先地位).</p><p>16 a(n)    array  (一系列) of information</p><p>17 be    deficient    (缺乏的) in nutrition</p><p>18 be   restricted     (限制) to adults</p><p>19       unfounded  (没有根据的) suspicions</p><p>20 Coal can be      converted  (使转变) to gas.</p><p>21 a(n)       devastating   (毁灭性的) hurricane</p><p>22    staple  (主要的) exports of this country</p><p>23     transform   (转变) dream into reality</p><h1 id="Text-19"><a href="#Text-19" class="headerlink" title="Text 19"></a>Text 19</h1><p> the scientific study of people and their societies        anthropology人类学</p><p> trying to appear to be important when it is not in order to be impressive     pretentious做作的</p><p>words used by experts to discuss their subject     jargon 术语</p><p>connected with words or using words     verbal用文字的，口头的</p><p>a set of ideas from which more complicated ideas are developed     framework框架，结构</p><p>written language in its usual form, as opposed to poetry     prose 散文，乏味的</p><p>concerned with the central government of a country         federal 联邦的，同盟的</p><p>the state of being real, true, or based on facts     validity 有效性，可信度</p><p>connected with the subject being discussed         relevance 关联</p><p>a suggested explanation that has not yet been proved to be true.    Hypothesis 假设 </p><p>1      methodical   /məˈθɒdɪkl/  (井井有条的) work</p><p>2 It can  add to  (增添) the value of the housing.</p><p>3     undertake   (承担) full responsibility for the loss</p><p>4 Errors must be   eliminated</p><p>   (消除掉) before you hand in your essay.</p><p>5 Important content should be    highlighted    (强调).</p><p>6 His face    took on   (呈现) a worried look.</p><p>7    sacrifice  (牺牲) one’s health for professional success</p><p>8 hours spent on   editing   (编辑) the book</p><p>9 some     obstacles   (障碍) to its development</p><p>10   dread  (害怕) working after a long holiday</p><p>11 The dispute    grew out   (由发展而来) of an argument.</p><p>12    duplicate    (重复) an experiment</p><p>13 develop the  core  (核心) of people</p><p>14    suppress   (抑制) the body’s immune system</p><p>15 completely      antithetical to     (完全对立的) the ideas</p><p>16     guidelines    (方针) for the treatment</p><p>17 medical     personnel  (全体人员)</p><p>18   detail   (详细介绍) a number of joint initiatives</p><p>19 very    pleasing    (使人快乐的) to the eye</p><p>20 many     rhetorical   (修辞性的) phrases used in his speech</p><p>21    prefer to  (更适合的) walking with bare feet</p><p>22 very    readable   (易懂的) account of their research</p><p>23 You have to learn to     live with   (承受) stress.</p><p>24 The job      made demand on    (需要) my time.</p><p>25 the     underlying    (根本性的) causes for her divorce</p><p>26   set out   (开始着手进行) to rob the bank</p><p>27 Women    make up    (构成) only 10 percent of the workforce.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学术英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术英语 </tag>
            
            <tag> 复习 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理复习笔记</title>
      <link href="/2020/06/09/shu-ju-ku-yuan-li-fu-xi-bi-ji/"/>
      <url>/2020/06/09/shu-ju-ku-yuan-li-fu-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库是数据管理的最新技术</p><p>数据库技术一般包含<strong>数据管理</strong>和<strong>数据处理</strong>两部分</p><p>数据库系统<br>本质上是一个用计算机存储数据的系统<br>除了保存数据外，还提供对数据进行各种管理和处理：<br>        1.安全管理<br>        2.数据共享<br>        3.数据查询</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p><strong>数据</strong>是数据库中存储的基本对象<br>数据可以定义为：<strong>数据是描述事物的符号记录</strong><br>数据需要经过解释才能明确其表达的含义<br>数据和解释不可分割</p><pre><code>- 数据的解释是对数据的说明- 数据的含义称为数据的语义</code></pre><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库（Database）是存放数据的仓库<br>永久存储在计算机存储设备上<br>按一定格式存储<br>是有<strong>组织</strong>的、<strong>可共享</strong>的大量数据的集合</p><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><p>Database Management System——DBMS<br>数据库中的数据被统一管理，合理组织，任何对数据的操作都由数据库管理系统DBMS完成。<br>是一个专门用于实现对数据进行管理和维护的<strong>系统软件</strong><br><img src="https://i.loli.net/2020/06/09/N4HdMuUnK8OLboW.png" alt="数据库管理系统"></p><p>数据库管理系统主要功能<br>        1.数据库的建立与维护<br>        2.数据定义<br>        3.数据组织、存储和管理<br>        4.数据操作<br>        5.事物的管理和运行</p><h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>一般由数据库、数据库管理系统（及相关实用工具）、应用程序、数据库管理员组成<br><img src="https://i.loli.net/2020/06/09/DowxunLChbfG9tW.png" alt="数据库系统"></p><h2 id="数据库技术的发展"><a href="#数据库技术的发展" class="headerlink" title="数据库技术的发展"></a>数据库技术的发展</h2><h3 id="手工管理阶段"><a href="#手工管理阶段" class="headerlink" title="手工管理阶段"></a>手工管理阶段</h3><h3 id="文件管理阶段"><a href="#文件管理阶段" class="headerlink" title="文件管理阶段"></a>文件管理阶段</h3><p>文件方式管理数据的缺点<br>        1.编写应用程序不方便<br>        2.数据冗余不可避免<br>        3.应用程序依赖性<br>        4.不支持对文件的并发访问<br>        5.数据间联系弱<br>        6.难以按用户视图表示数据<br>        7.无安全控制功能 </p><p><img src="https://i.loli.net/2020/06/09/dgqyPZQ7OI4vLiJ.png" alt="文件管理阶段 "></p><h3 id="数据库管理系统-1"><a href="#数据库管理系统-1" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><p>数据库管理的优点<br>        1.相互关联的数据的集合<br>        2.较少的数据冗余<br>        3.程序与数据相互独立<br>        4.保证数据的安全、可靠<br>        5.最大限度地保证数据的正确性<br>        6.数据可以并发使用并能保证一致性</p><p><img src="https://i.loli.net/2020/06/09/4WwjcA5YCQ1slHG.png" alt="数据库操作模式"></p><h2 id="数据库的结构"><a href="#数据库的结构" class="headerlink" title="数据库的结构"></a>数据库的结构</h2><p>考察数据库结构有不同的层次或不同的角度。</p><ul><li>从<strong>数据库管理角度</strong>看，数据库通常采用三级模式结构。这是数据库管理系统内部的系统结构。</li><li>从<strong>数据库最终用户角度</strong>看，数据库的结构分为集中式结构、文件服务器结构、客户/服务器结构等。这是数据库的外部结构。</li></ul><h3 id="模式的基本概念"><a href="#模式的基本概念" class="headerlink" title="模式的基本概念"></a>模式的基本概念</h3><p><strong>数据模型</strong>（组织层数据模型）是描述数据的组织形式<br><strong>模式</strong>是用给定的数据模型对具体数据的描述<br><strong>模式</strong>是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及“型”的描述，不涉及具体的值<br><strong>关系模式</strong>是关系的“型”或元组的结构共性的描述，实际上对应的是关系表的表头<br><strong>模式</strong>的一个具体值称为模式的一个<strong>实例</strong>。<br>如表中的每一行数据就是一个具体实例。<br>模式是相对稳定的，实例是相对变动的。<br><img src="https://i.loli.net/2020/06/09/rzkl3SJfungyXOj.png" alt="关系模式"></p><p>三级模式结构<br><img src="https://i.loli.net/2020/06/09/1uwrcJs7AWCdF5U.png" alt="三级模式结构"><br>关系数据库中的<strong>模式一定是关系的</strong>，在该层可见的实体是关系的表和关系的操作符。<br><strong>外模式</strong>也是关系的，它们的内容来自模式<br><strong>内模式</strong>不是关系的，它是数据的物理存储方式。</p><p>外模式<br>也称为用户模式、子模式。<br>用户对现实系统中感兴趣整体的局部数据结构的描述。<br>是DB整体数据结构的子集或局部重构。<br>用外模式定义语言表达。例，对RDB，定义视图结构。<br>是保证数据库安全的一个措施。 </p><p>内模式<br>也称为存储模式。<br>是对整个数据库的底层表示。<br>描述了数据的存储结构，比如：<br>        1.数据的组织与存储方式<br>        2.索引按什么方式组织<br>        3.是否加密等<br>但不涉及物理记录的形式。</p><p>模式<br>也称为逻辑模式或模式，是数据库中<strong>全体数据</strong>的逻辑结构和特征的描述，是<strong>所有用户</strong>的公共数据描述。<br>是数据库系统结构的<strong>中间层</strong>。<br>不涉及数据的物理存储细节和硬件环境，<br>与具体的应用程序、应用开发工具和环境无关。<br>模式实际上是数据库数据在逻辑级上的视图。<br>一个数据库只有一种模式。<br>不涉及存储记录对列、索引、指针或其他存储的访问细节。</p><p>模式映像与数据独立性<br>数据库系统的三级模式是对数据的三个抽象级别，<br>它把数据的具体组织留给DBMS管理，使用户能逻辑地、抽象地处理数据，<br>而不必关心数据在计算机中的具体表示方式与存储方式。</p><p>两个映像<br>为了能够在内部实现这三个抽象层次的联系和转换，数据库管理系统在三级模式之间提供了两层映象：<br>        1.外模式/模式映象<br>            当模式改变时，可用外模式/模式定义语句，调整外模式/模式映象定义，从而保持外模式不变。<br>            *<em>数据和程序逻辑独立（概念独立） *</em></p><p>​        2.模式/内模式映象<br>​            当存储结构改变时，可（由DBA）用内模式定义语句，调整内模式定义，从而保持模式不变。<br>​            *<em>数据和程序物理独立（存储独立） *</em></p><p>物理独立性<br>指当数据的存储位置或存储结构发生变化时，不影响应用程序的特性。</p><p>逻辑独立性<br>指当表达现实世界的信息内容发生变化时，如：<br>        1.增加信息<br>        2.删除无用信息等<br>不影响应用程序的特性。</p><p>非独立性<br>在使用文件管理数据时，应用程序常常是数据依赖的，<br>也就是说数据的物理表示方式和有关的存取技术都要在应用程序中考虑，<br>而且，有关物理表示的知识和访问技术直接体现在应用程序的代码中。</p><h2 id="数据库与计算思维（自查）"><a href="#数据库与计算思维（自查）" class="headerlink" title="数据库与计算思维（自查）"></a>数据库与计算思维（自查）</h2><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>现实世界的数据是散乱无章的，散乱的数据不利于人们对其进行有效的管理和处理。<br>因此，必须把现实世界的数据按照一定的格式组织起来，以方便对其进行操作和使用。<br>在用数据库技术管理数据时，数据被按照一定的格式组织起来，比如二维表结构，以使数据能够被更高效地管理和处理。</p><p>描述事物的符号记录称为<strong>数据</strong>。<br>将从数据中获得的有意义的内容称为<strong>信息</strong>。<br>数据有一定的格式，这些格式的规定是数据的语法，而数据的含义是数据的语义。<br>数据是信息存在的一种形式，只有通过解释或处理才能成为有用的信息。<br><img src="https://i.loli.net/2020/06/09/3UQkmEDYr1y2sWS.png" alt="数据与解释"></p><h3 id="数据的静态特征"><a href="#数据的静态特征" class="headerlink" title="数据的静态特征"></a>数据的静态特征</h3><p>​        1.数据的基本结构<br>​        2.数据间的联系<br>​        3.数据取值范围约束</p><h3 id="数据的动态特征"><a href="#数据的动态特征" class="headerlink" title="数据的动态特征"></a>数据的动态特征</h3><p>指对数据可以进行的操作以及操作规则。<br>对数据库数据的操作主要有<br>        1.查询数据<br>        2.更改数据：插入、删除和更新<br>一般将对数据的静态特征和动态特征的描述称为数据模型三要素</p><p>计算机中的模型是对事物、对象、过程等客观系统中感兴趣的内容的模拟和抽象表达，是理解系统的思维工具<br>数据模型(data model)也是一种模型，它是对现实世界数据特征的抽象。<br>数据库管理系统是基于某种数据模型对数据进行组织的，因此，了解数据模型的基本概念是学习数据库知识的基础。<br>在数据库领域中，数据模型用于表达现实世界中的对象，即将现实世界中杂乱的信息用一种规范的、形象化的方式表达出来。</p><p>数据模型即要面向现实世界，又要面向机器世界，因此需满足三个要求:<br>        1.能够真实地模拟现实世界<br>        2.容易被人们理解<br>        3.能够方便地在计算机上实现</p><p>数据模型实际上是模型化数据和信息的工具。根据模型应用的不同目的，可以将模型分为两大类：<br>        1.<strong>概念层数据模型</strong>（概念模型），从数据的语义视角来抽取模型，是按用户的观点来对数据和信息进行建模。<br>            从数据的应用语义视角来抽取现实世界中有价值的数据并按用户的观点对数据进行建模。<br>            主要用在数据库的设计阶段，<br>            与具体的数据库管理系统无关，<br>            与具体的实现方式无关。<br>        2.<strong>组织层数据模型</strong>（组织模型）。从数据的组织层次来描述数据。<br>            从数据的组织方式来描述数据。主要有：<br>                    1.层次模型<br>                    2.网状模型<br>                    3.关系模型<br>                    4.对象-关系模型<br>            是从计算机系统的观点对数据进行建模，<br>            与所使用的数据库管理系统有关。<br><img src="https://i.loli.net/2020/06/09/So4Drw6svWnqlbF.png" alt="数据模型"></p><h3 id="概念层数据模型"><a href="#概念层数据模型" class="headerlink" title="概念层数据模型"></a>概念层数据模型</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>概念层数据模型是指抽象现实系统中有应用价值的元素及其关联关系，反映现实系统中有应用价值的信息结构，并且不依赖于数据的组织层数据模型。<br>用于对信息世界建模，是现实世界到信息世界的<strong>第一层抽象</strong>，是数据库设计人员进行数据库设计的工具，也是数据库设计人员和业务领域的用户之间进行交流的工具。</p><p>概念层数据模型应该：<br>        1.具有较强的语义表达能力<br>        2.能够方便、直接地表达应用中的各种语义知识<br>        3.简单、清晰，易于被用户理解<br>是面向用户、面向现实世界的数据模型，与具体的DBMS无关。<br>常用概念模型：<strong>实体-联系模型</strong>、<strong>语义对象模型</strong></p><h4 id="实体-联系模型（E-R）"><a href="#实体-联系模型（E-R）" class="headerlink" title="实体-联系模型（E-R）"></a>实体-联系模型（E-R）</h4><p>由P. P. S. Chen于1976年提出，即通常所说的E-R方法。<br>这种方法由于简单、实用，因此得到了广泛的应用，也是目前描述信息结构最常用的方法。<br>实体-联系方法使用的工具称为<strong>E-R图</strong>，也把这种描述结果称为<strong>E-R模型</strong>。</p><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>具有公共性质的可相互区分的现实世界对象的集合。例如：学生、课程、职工<br>在E-R图中用矩形框表示具体的实体，把实体名写在框内。</p><p>实体中每个具体的记录值（一行数据），称为实体的一个<strong>实例</strong>。<br>有些书也将实体称为<strong>实体集</strong>或<strong>实体类型</strong>，而将每行具体的记录称为<strong>实体</strong><br><img src="https://i.loli.net/2020/06/09/3fptnANsFVyHlmG.png" alt="实体与实例"></p><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>描述实体或者联系的性质或特征的数据项。</p><p>标识属性<br>能够唯一标识实体的一个属性或最小的一组属性（称为属性集或属性组）称为实体的标识属性，称为实体的码。<br>例如，“学号”就是学生实体的码。</p><p>属性的表示方式<br>用圆角矩形或椭圆框表示，框内写上属性名，并用连线连到相应实体。<br><img src="https://i.loli.net/2020/06/09/Y1VWPuncsKOpygd.png" alt="属性的表示方式"></p><h5 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h5><p>联系是数据之间的关联集合，是客观存在的应用语义链 。<br>实体内部的联系：一个实体内属性之间的联系。比如职工中的职工号和此职工的部门经理号<br>实体之间的联系：不同实体之间的联系。比如课程和学生实体之间存在选课联系。</p><p>联系的表示方式<br>实体之间的联系用菱形框表示，框内写上联系名，并用连线与有关的实体相连。<br><img src="https://i.loli.net/2020/06/09/uzkeMgG7ywH6hY5.png" alt="联系的表示方式"></p><p>联系的种类：<br>1.一对一联系(1:1)</p><p>如果实体A中的每个实例在实体B中至多有一个（也可以没有）实例与之关联，反之亦然，则称实体A与实体B具有一对一联系，记作：1:1<br>部门和正经理（假设一个部门只有一个正经理，一个人只当一个部门的经理）、系和正系主任（假设一个系只有一个正主任，一个人只当一个系的主任）都是一对一联系。 </p><p>2.一对多联系(1:n)</p><p>如果实体A与实体B之间存在联系，并且对于实体A中的一个实例，实体B中有多个实例与之对应；而对实体B中的任意一个实例，在实体A中都只有一个实例与之对应，则称实体A到实体B的联系是一对多的，记为1 : n<br>有部门和职工两个实体，并且有语义：一个部门可以有多名职工，但是一个职工只在一个部门工作。则部门和职工之间的联系是一对多的，我们把这种联系命名为工作。</p><p>3.多对多联系(m:n)</p><p>如果实体A与实体B之间存在联系，并且对于实体A中的一个实例，实体B中有多个实例与之对应；而对实体B中的一个实例，在实体A中也有多个实例与之对应，则称实体A到实体B的联系是多对多的，记为m : n 。<br>有学生和课程两个实体，并有语义：一个学生可以修多门课程，一门课程可以被多个学生修。那么学生和课程之间的联系就是多对多的，我们把这种联系命名为选课。</p><p>联系说明<br>一对一联系是一对多联系的特例，而一对多联系又是多对多联系的特例。<br>实体之间联系的种类与<strong>语义</strong>直接相关。<br>例如，部门和经理：<br>        1.如果一个部门只有一个经理，一个人只担任一个部门的经理，则部门和经理之间是一对一联系。<br>        2.如果一个部门可以有多个经理，而一个人只担任一个部门的经理，则部门和经理之间就是一对多联系。<br>        3.如果一个部门可以有多个经理，而且一个人也可以担任多个部门的经理，则部门和经理之间就是多对多联系。<br><img src="https://i.loli.net/2020/06/09/eaMLRE8xtyhFVmu.png" alt=""></p><h3 id="组织层数据模型"><a href="#组织层数据模型" class="headerlink" title="组织层数据模型"></a>组织层数据模型</h3><p>组织层数据模型是从数据的组织形式的角度来描述信息。<br>在数据库技术的发展过程中用到的组织层数据模型主要有：<br>        1.层次模型（Hierarchical Model）<br>        2.网状模型（Network Model）<br>        3.关系模型（Relational Model）<br>        4.面向对象模型（Object Oriented Model）</p><h4 id="层次数据模型"><a href="#层次数据模型" class="headerlink" title="层次数据模型"></a>层次数据模型</h4><p>是数据库管理系统中最早出现的数据模型。<br>层次数据库管理系统采用层次模型作为数据的组织方式。<br>层次数据库管理系统的典型代表是IBM公司的IMS，是IBM1968年推出的第一个大型商用数据库管理系统。</p><p>用树形结构表示实体和实体之间的联系。<br>现实世界中许多实体之间的联系本身就呈现出一种自然的层次关系，如：<br>    -行政机构<br>    -家族关系</p><p>构成层次模型的树由结点和连线组成<br>        1.结点表示实体，结点中的项表示实体的属性<br>        2.连线表示相连的两个实体间的联系，这种联系是一对多的。<br>通常把表示“一”的实体放在上方，称为<strong>父结点</strong><br>把表示“多”的实体放在下方，称为<strong>子结点</strong><br>将不包含任何子结点的结点称为<strong>叶结点</strong><br><img src="https://i.loli.net/2020/06/09/gY8JkKhiAr52DqV.png" alt="层次模型示意图"></p><p>层次模型的限制<br>可以方便的表示一对多的联系。但有以下两点限制：<br>        1.有且仅有一个结点无父结点，这个结点即为树的<strong>根</strong>；<br>        2.其他结点有且仅有一个父结点。</p><p>层次模型的基本特点<br>任何一个给定的记录值只有从层次模型的根部开始按路径查看时，才能明确其含义，任何子结点都不能脱离父结点而存在。<br><img src="https://i.loli.net/2020/06/09/uWt8mMUliNsBVQw.png" alt="层次模型的基本特点"></p><p>层次模型的局限性<br>只能表示一对多的联系，不能直接表示多对多联系。<br>如果把多对多联系转换为一对多联系，会出现一个子结点有多个父结点的情况。</p><p>解决办法<br>把一个层次模型分解为两个层次模型<br><img src="https://i.loli.net/2020/06/09/lsiVShCOcZp94jW.png" alt=""></p><h4 id="网状数据模型"><a href="#网状数据模型" class="headerlink" title="网状数据模型"></a>网状数据模型</h4><p>如果去掉层次模型中的两点限制，即<br>        1.允许一个以上的结点无父结点，<br>        2.每个结点可以有多个父结点，<br>便构成了网状模型。<br>用<strong>图</strong>形结构表示实体和实体之间的联系。<br><img src="https://i.loli.net/2020/06/09/WzkNHfCBeOo7Dda.png" alt="网状模型示例"><br><img src="https://i.loli.net/2020/06/09/9fyRax1gAzNeBLV.png" alt="网状模型示意图"></p><p>网状模型限制<br>网状数据模型可以直接表示多对多联系。但实现起来太复杂。<br>因此一些支持网状模型的数据库管理系统，对多对多联系还是进行了限制<br>例如，网状模型的典型代表CODASYL就只支持一对多联系。</p><h4 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h4><p>关系数据模型是目前<strong>最重要的一种数据模型</strong>，<br>关系数据库就是采用关系数据模型作为数据的组织方式。<br>关系数据模型源于数学，它把数据看成是二维表中的元素，而这个二维表在关系数据库中就称为<strong>关系</strong>。</p><p>关系数据模型的数据结构<br>用关系（表格数据）表示实体和实体之间的联系的模型就称为<strong>关系数据模型</strong>。<br>在关系数据模型中，实体本身以及实体和实体之间的联系都用关系来表示，实体之间的联系不再通过指针来实现。<br><img src="https://i.loli.net/2020/06/09/o1urYxQI6EfZpNG.png" alt="关系模型示例"></p><p>在关系数据库中，记录值仅仅构成关系，关系之间的联系是靠语义相同的字段（称为<strong>连接字段</strong>）值表达的。<br>例如，要查询“刘晨”的考试成绩，首先要在“学生”关系中得到“刘晨”的学号值，然后根据这个学号值再在“选课”关系中找出该学生的所有考试记录值。<br><img src="https://i.loli.net/2020/06/09/noQ4rRhbFLma8iN.png" alt="示例"></p><p>关系模型的好处<br>关系数据模型易于设计、实现、维护和使用，<br>它与层次数据模型和网状数据模型的最根本区别是，关系数据模型不依赖于导航式的数据访问系统，数据结构的变化不会影响对数据的访问。</p><h1 id="关系数据模型-1"><a href="#关系数据模型-1" class="headerlink" title="关系数据模型"></a>关系数据模型</h1><p>关系数据模型源于数学</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系模型由三部分组成：<br>        1.数据结构<br>        2.操作集合<br>        3.完整性约束<br>这三部分也称为<strong>关系模型三要素</strong></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>关系数据模型用二维表来组织数据。<br>这个二维表在关系数据库中就称为关系。<br>关系数据库就是表或者说是关系的集合。<br>表是逻辑结构而不是物理结构。</p><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a><strong>数据操作</strong></h4><p>关系数据模型中的操作包括：<br>传统的关系运算：并、交、差、广义笛卡尔积<br>专门的关系运算：选择、投影、连接、除<br>有关的数据操作：查询、插入、删除、更改<br>操作特点：<br>关系模型中操作的数据以及查询的结果都是完整的集合（或表），<br>这些集合可以只包含一行数据，也可以是不包含任何数据的空集合。<br>非关系模型数据库中典型的操作是一次一行或一次一个记录。<br>集合处理能力是关系系统区别于其他系统的重要特征。</p><h4 id="关系模型与非关系模型区别"><a href="#关系模型与非关系模型区别" class="headerlink" title="关系模型与非关系模型区别"></a>关系模型与非关系模型区别</h4><p>在<strong>非关系模型</strong>中，各个数据记录之间是通过指针等方式连接的，当要定位到某条记录时，需要用户自己按指针的链接方向逐层查找——<strong>导航</strong>。<br>在<strong>关系模型</strong>中，用户只需指定数据的定位条件，数据库管理系统就可以自动定位到该数据记录——<strong>非导航</strong>。</p><h4 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h4><p>关系模型的数据操作主要包括：查询、插入、删除、更改<br>关系数据库中的信息表示方式：表中的行列位置有明确的值——逻辑层。</p><h4 id="关系数据库的物理层"><a href="#关系数据库的物理层" class="headerlink" title="关系数据库的物理层"></a>关系数据库的物理层</h4><p>关系数据库在物理层也使用指针，但这些物理层的存储细节对用户来说都是不可见的，用户所看到的物理层实际上就是存放数据的数据库文件:文件名、存放位置</p><h4 id="关系语言特点"><a href="#关系语言特点" class="headerlink" title="关系语言特点"></a>关系语言特点</h4><p>关系操作是通过关系语言实现的，关系语言的特点是<strong>高度非过程化</strong>：<br>        1.用户不必关心数据的存取路径和存取过程，只需要提出数据请求，DBMS会自动完成用户请求的操作；<br>        2.用户没有必要编写程序代码来实现对数据的重复操作。</p><h4 id="数据完整性约束"><a href="#数据完整性约束" class="headerlink" title="数据完整性约束"></a>数据完整性约束</h4><p>数据的完整性是指保证数据正确性的特征。<br>数据完整性是一种语义概念，包括：<br>        1.与现实世界中应用需求的数据的相容性和正确性<br>        2.数据库内数据之间的相容性和正确性</p><p>数据完整性<br>数据完整性由一组完整性规则定义，关系模型的完整性规则是对关系的某种约束条件。<br>在关系数据模型中将数据完整性分为三类：<br>        1.实体完整性<br>        2.参照完整性（引用完整性）<br>        3.用户定义的完整性</p><h3 id="关系模型的基本术语与形式化定义"><a href="#关系模型的基本术语与形式化定义" class="headerlink" title="关系模型的基本术语与形式化定义"></a>关系模型的基本术语与形式化定义</h3><h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><p><strong>关系</strong>：关系就是二维表，二维表的名字就是关系的名字。<br><strong>属性</strong>：二维表中的每个列就称为一个属性（或叫字段），<br>            1.每个属性有一个名字——属性名<br>            2.某一列的值——属性值<br>            3.列的个数——关系的元数。如果一个二维表有n个列，则称其为n元关系。<br><strong>值域</strong>：二维表中属性的取值范围称为值域。<br>            例如：<br>                “年龄”的取值为大于0的整数<br>                “性别”列的取值为{男,女}<br><strong>元组</strong>:二维表中的一行数据称为一个元组（记录值）。<br><img src="https://i.loli.net/2020/06/09/QRGfFLTElOmb1My.png" alt="元组"><br><strong>分量</strong>：元组中的每一个属性值称为元组的一个分量。<br>            n元关系的每个元组有n个分量。<br>            例：（0811101，李勇，21，男，计算机系），有5个分量<br><strong>关系模式</strong>：二维表的结构称为关系模式。<br>                    设有关系名为R，属性分别为A1，A2，…，An，则关系模式可以表示为：<br>                        R（A1，A2，…，An）<br>                    如果将关系模式理解为数据类型，则关系就是该数据类型的一个具体值。<br><strong>关系数据库</strong>：对应于一个关系模型的所有关系的集合称为关系数据库。<br><strong>候选键</strong>：如果一个属性或属性集的值能够惟一标识一个关系的元组而又不包含多余的属性,则称该属性或属性集为候选键。<br><strong>主键</strong>：当一个关系中有多个候选键时，从中选择一个作为主键。每个关系只能有一个主键。<br>            主键也称为主码或主关键字，用于惟一地确定一个元组。<br>            主键可以由一个属性组成，也可以由多个属性共同组成。<br><strong>主属性</strong>：包含在任一候选键中的属性称为主属性。<br><strong>非主属性</strong>：不包含在任一候选键中的属性称为非主属性。</p><table><thead><tr><th>关系术语</th><th>一般的表格术语</th></tr></thead><tbody><tr><td>关系名</td><td>表名</td></tr><tr><td>关系模式</td><td>表头（表所含列的描述）</td></tr><tr><td>关系</td><td>（一张）二维表</td></tr><tr><td>元组</td><td>记录或行</td></tr><tr><td>属性</td><td>列</td></tr><tr><td>分量</td><td>一条记录中某个列的值</td></tr></tbody></table><h4 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h4><p>$$<br>定义笛卡尔积：设D_1，D_2，…，D_n为任意集合\<br>定义笛卡尔积D_1，D_2，…，D_n为：D_1 × D_2 × … × D_n ＝{( d_1，d_2，…，d_n ) | d_i ∈D_i，i＝1，2，…，n }\<br>其中每一个元素（d_1，d_2，…，d_n）称为一个n元组，简称元组。\<br>元组中每一个d_i称为是一个分量。\<br>\<br>D1＝{计算机系，信息管理系} \<br>D2＝{李勇，刘晨，吴宾}\<br>D3＝{男，女}\<br>则D_1 × D_2 × D_3笛卡尔积为：{（计算机系，李勇，男），（计算机系，李勇，女），\                             （计算机系，刘晨，男），（计算机系，刘晨，女），\<br> （计算机系，吴宾，男），（计算机系，吴宾，女），\<br> （信息管理系，李勇，男），（信息管理系，李勇，女），\<br> （信息管理系，刘晨，男），（信息管理系，刘晨，女），\<br> （信息管理系，吴宾，男），（信息管理系，吴宾，女）}<br>$$</p><p><img src="https://i.loli.net/2020/06/09/FhVGLrMI1H2xYsw.png" alt="形式化定义"></p><p>关系的形式化定义<br>笛卡尔积D1，D2，…，Dn的任意一个子集称为D1，D2，…，Dn上的一个n元关系。<br>形式化的关系定义同样可以把关系看成二维表，给表中的每个列取一个名字，称为属性。<br>n元关系有n个属性，一个关系中的属性的名字必须是唯一的。<br>属性Di的取值范围（i＝1，2，…，n）称为该属性的值域。<br><img src="https://i.loli.net/2020/06/09/w9IaG1ZJPQnCp2T.png" alt="关系的形式化定义"></p><p>对关系的限定<br>关系中的每个分量都是不可再分的最小属性<br>表中列的数据类型是固定的，即列中的每个分量都是同类型的数据，来自相同的值域。<br>不同列的数据可以取自相同的值域。<br>关系表中列的顺序不重要。<br>关系表行的顺序也不重要。<br>同一个关系中的元组不能重复。</p><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>关系代数是关系操作语言的一种传统表示方式，是一种<strong>抽象的查询语言</strong>。<br>是一种纯理论语言，它定义了一些操作，运用这些操作可以从一个或多个关系中得到另一个关系，而不改变源关系。<br>关系代数的操作数和操作结果都是关系，而且一个操作的输出可以是另一个操作的输入。</p><h4 id="关系代数的运算"><a href="#关系代数的运算" class="headerlink" title="关系代数的运算"></a>关系代数的运算</h4><p>关系代数的运算对象是关系，运算结果也是关系。<br>与一般的运算一样，运算对象、运算符和运算结果是关系代数的三大要素。<br>关系代数的运算可分为以下两大类：<br>        1.传统的集合运算：并、交、差、笛卡尔积<br>        2.专门的关系运算：选择、投影、连接、除<br><img src="https://i.loli.net/2020/06/09/Ea3FYAHwCctXSlB.png" alt="运算符"><br><img src="https://i.loli.net/2020/06/09/BNz5nQtTupMFre8.png" alt="运算符"></p><h4 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h4><p><img src="https://i.loli.net/2020/06/09/yuqnm6bCTvG7ELp.png" alt="并、交、差运算示意图"></p><h5 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h5><p>并（R∪S）：设关系R与关系S均是n目关系，关系R与关系S的并记为：R∪S＝{t | t∈R ∨t∈S }<br>其结果仍是n目关系，由属于R或属于S的元组组成。<br>元组在新关系中的顺序不重要。<br><img src="https://i.loli.net/2020/06/09/KFqe3E4zMakXSUg.png" alt="并运算示例"></p><h5 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h5><p>交（R∩S）：设关系R与关系S均是n目关系，关系R与关系S的交记为：R∩S＝{t | t∈R ∧t∈S }<br>其结果仍是n目关系，由属于R并且也属于S的元组组成。</p><h5 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h5><p>差（R－S）：设关系R与关系S均是n目关系，关系R与关系S的差记为：R－S＝{t | t∈R ∧t∈S }<br>其结果仍是n目关系，由属于R但不属于S的元组组成。<br><strong>R∩S＝R-(R – S )</strong><br><img src="https://i.loli.net/2020/06/09/KDTs3reqMn7a8zL.png" alt="交、差运算示例"></p><h5 id="广义笛卡尔积"><a href="#广义笛卡尔积" class="headerlink" title="广义笛卡尔积"></a>广义笛卡尔积</h5><p>两个分别为n目和m目的关系R和关系S的笛卡尔积是一个（m＋n）列的元组的集合。元组的前n个列是R的一个元组，后m个列是S的一个元组。<br>若R有K1个元组，S有K2个元组，则关系R和关系S的广义笛卡尔积有K1×K2个元组，记做：R×S＝｛tr^ts | tr∈R ∧ ts∈S｝<br>tr^ts表示由元组tr和ts前后有序连接而成的一个元组。<br>任取元组tr和ts，当且仅当tr属于R且ts属于S时，tr和ts的有序连接即为R×S的一个元组。<br><img src="https://i.loli.net/2020/06/09/3ELr5gnXoUjpZhB.png" alt="广义笛卡尔积"></p><h3 id="专门的关系运算（大题）"><a href="#专门的关系运算（大题）" class="headerlink" title="专门的关系运算（大题）"></a>专门的关系运算（大题）</h3><h4 id="选择运算-Select"><a href="#选择运算-Select" class="headerlink" title="选择运算(Select)"></a>选择运算(Select)</h4><p>从指定的关系中选择满足给定条件（用逻辑表达式表达）的元组而组成一个新的关系。<br><img src="https://i.loli.net/2020/06/09/eEymFoOp2sivj43.png" alt="选择运算(Select)"><br><img src="https://i.loli.net/2020/06/09/4CJWoiVcxv32UmF.png" alt="选择运算示意图"><br><img src="https://i.loli.net/2020/06/09/My2tZ9BkYXsg8hl.png" alt="选择运算示例"></p><h4 id="投影运算-Project"><a href="#投影运算-Project" class="headerlink" title="投影运算(Project)"></a>投影运算(Project)</h4><p>从关系R中选择若干属性，并用这些属性组成一个新的关系。<br><img src="https://i.loli.net/2020/06/09/GhsjS31Dx6TOnb7.png" alt="投影运算"><br><img src="https://i.loli.net/2020/06/09/u9WZsO7zHKJcpfS.png" alt="image-20200609205645529"><br><img src="https://i.loli.net/2020/06/09/PpbhJ4FlXQefEVW.png" alt="投影运算示例"></p><p><img src="https://i.loli.net/2020/06/09/yuGXYHQkMhDOVrF.png" alt="例题"><br><img src="https://i.loli.net/2020/06/09/2mzI1vPC7rpfLTG.png" alt="例题"></p><h4 id="连接运算-Join"><a href="#连接运算-Join" class="headerlink" title="连接运算(Join)"></a>连接运算(Join)</h4><p>连接运算用来连接相互之间有联系的两个关系，从而产生一个新的关系。<br>连接运算具有如下几种形式：<br>        1.θ连接<br><img src="https://i.loli.net/2020/06/09/vTcjs7h6N13JCUt.png" alt="θ连接"><br>            A、B是关系R和S上语义相同的属性或属性组，<br>            θ是比较运算符。<br>            连接运算从R和S的广义笛卡尔积中选择R关系在A属性组上的值与S关系在B属性组上的值满足θ的元组。</p><p>​        2.等值连接（θ连接的特例）<br><img src="https://i.loli.net/2020/06/09/XNlRBEe1G8zWOC7.png" alt="等值连接">            θ为“=”的连接成为等值连接。它是从关系R与S的笛卡尔积中选取A，B属性值相等的那些元组</p><p>​        3.自然连接<br>​            是一种特殊的等值连接，它去掉了等值连接结果中的重复的属性列。<br>​            即若R与S具有相同的属性组B，则自然连接可记作：<br><img src="https://i.loli.net/2020/06/09/gaQ3Nqd1lk2jvxF.png" alt="自然连接"></p><p><img src="https://i.loli.net/2020/06/09/P1vj53scRZMektf.png" alt="例题"><br><img src="https://i.loli.net/2020/06/09/3kW1bigdmUDPYSh.png" alt="等值连接与自然连接示例"><br><img src="https://i.loli.net/2020/06/09/4ERtW6OXGuADL5Q.png" alt="等值连接与自然连接示例"></p><p>​        4.外部连接（或称外连接）<br>​            如果希望不满足连接条件的元组也出现在连接结果中，则可以通过外连接实现。<br>​            外连接有三种：<br>​                    左外连接：<img src="https://i.loli.net/2020/06/09/sJz3bGgt6wrjlHh.png" alt="    左外连接"><br>​                    右外连接：<img src="https://i.loli.net/2020/06/09/1eNAk8rMtRJh5vi.png" alt="右外连接"><br>​                    全外连接：<img src="https://i.loli.net/2020/06/09/mTc4wYipXKBsZhg.png" alt="全外连接"></p><p>​            外连接含义<br>​            <strong>左（右）外连接</strong>：把连接符号左（右）边的关系中不满足连接条件的元组也保留到连接后的结果中，并在连接结果                                            中将该元组所对应的右（左）边关系的各个属性均置成空值（NULL）。<br>​            <strong>全外连接</strong>：把连接符号两边的关系中不满足连接条件的元组均保留到连接后的结果中，并在连接结果中将不满足连                                接条件的各元组的相关属性均置成空值（NULL）。<br><img src="https://i.loli.net/2020/06/09/l16RCQjUAXb2TG4.png" alt="左外连接示例"><br><img src="https://i.loli.net/2020/06/09/eVPlOBJWn1RQGXs.png" alt="全外连接示例"></p><p>​        5.半连接<br>​        在两个关系之间执行连接操作，并将其结果投影在第一个操作关系的所有属性上。<br>​        半连接的一个优点是可以减少必须参与连接的元组的数目。<br>​        半连接操作的表达形式为：<img src="https://i.loli.net/2020/06/09/Q4mcw3vDdEZszhi.png" alt=""><br>​        上述半连接是一个半θ连接，其他还有半等值连接、半自然连接等。<br><img src="https://i.loli.net/2020/06/09/xCt8d3SKusZEHYT.png" alt="半连接实例"><br><img src="https://i.loli.net/2020/06/09/HUanCuEqwXMloBD.png" alt="半连接示例"></p><h4 id="除运算-Division"><a href="#除运算-Division" class="headerlink" title="除运算(Division)"></a>除运算(Division)</h4><p>设关系S的属性是关系R的属性的一部分，则R÷S为这样一个关系：<br>        1.此关系的属性是由属于R但不属于S的所有属性组成<br>        2.R÷S的任一元组都是R中某元组的一部分。但必须符合下列要求，即任取属于R÷S的一个元组t，则t与S的任一元组连接后，都为R中原有的一个元组。<br><img src="https://i.loli.net/2020/06/09/FvcfVoAKCPqpJ8T.png" alt="除运算示意图"><br>除运算的一般形式<br>设有关系R（X,Y）和S（Y,Z），其中X、Y、Z为关系的属性组，则：<br>$$<br>R(X,Y)÷ S(Y,Z)＝R(X,Y)÷ ∏_Y(S)<br>$$<br>象集定义<br>设有关系R（X，Y），其中X，Y为属性（组），X=x在R上的象集是：Yx = {t[Y] | t∈R ∧t[X]=x }<br>t［Y］和t［X］分别表示R中的元组t在属性组Y和X上的分量的集合。<br><img src="https://i.loli.net/2020/06/09/AkabrWsUfjKQyT6.png" alt="象集示例"><br><img src="https://i.loli.net/2020/06/09/Go5NPIcYJkq7OAE.png" alt="象集示例"></p><p>除法的一般形式<br>设有关系R（X，Y）和S（Y，Z），其中X、Y、Z为关系的属性组，则：<br>$$<br>R÷S＝{tr[X] | t_r R ∧ ∏_Y（S） Y_x }<br>$$<br><img src="https://i.loli.net/2020/06/09/UZsoR7aPeichyMm.png" alt="除运算示例"><br><img src="https://i.loli.net/2020/06/09/Lq5zo17gwN4hQke.png" alt="例题"></p><h3 id="关系代数的优先级"><a href="#关系代数的优先级" class="headerlink" title="关系代数的优先级"></a>关系代数的优先级</h3><p><img src="https://i.loli.net/2020/06/09/uA6jxkwh8DBE1gX.png" alt="image-20200609211810096"></p><h3 id="关系代数综合示例"><a href="#关系代数综合示例" class="headerlink" title="关系代数综合示例"></a>关系代数综合示例</h3><p><img src="https://i.loli.net/2020/06/09/5oqpRzHv2NsMPZA.png" alt="关系代数综合示例"><br><img src="https://i.loli.net/2020/06/09/SWT8iu3GgYJCf2E.png" alt="关系代数综合示例"><br><img src="https://i.loli.net/2020/06/09/a45qPEiRJVo29WO.png" alt="关系代数综合示例"><br><img src="https://i.loli.net/2020/06/09/e9rdYWNCt1biHRX.png" alt="关系代数综合示例"><br><img src="https://i.loli.net/2020/06/09/F7rfaTuISYlJAmR.png" alt="关系代数综合示例"><br><img src="https://i.loli.net/2020/06/09/bKHDyJrdmQNPi6q.png" alt="关系代数综合示例"></p><h3 id="关系代数操作总结"><a href="#关系代数操作总结" class="headerlink" title="关系代数操作总结"></a>关系代数操作总结</h3><p><img src="https://i.loli.net/2020/06/09/1Q73xu4sckOfbma.png" alt="关系代数操作总结"><br><img src="https://i.loli.net/2020/06/09/sZPztDK7VTQIWlH.png" alt="关系代数操作总结"></p><h1 id="SQL语言（大题）"><a href="#SQL语言（大题）" class="headerlink" title="SQL语言（大题）"></a>SQL语言（大题）</h1><h2 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h2><p>SQL(structured query language)语言全称是结构化查询语言<br>它是一种在关系型数据库中定义和操纵数据的标准语言<br>SQL包含的功能：数据定义、数据查询、数据操作、数据控制</p><p>SQL语言的特点<br>        1.一体化<br>        2.高度非过程化<br>        3.面向集合的操作方式<br>        4.提供多种方式使用<br>        5.语言简洁</p><p>SQL语言的功能<br>数据定义功能、数据控制功能、数据查询功能和数据操纵功能</p><table><thead><tr><th>SQL功能</th><th>命令动词</th></tr></thead><tbody><tr><td>数据查询</td><td>SELECT</td></tr><tr><td>数据定义</td><td>CREATE、DROP、ALTER</td></tr><tr><td>数据操纵</td><td>INSERT、UPDATE、DELETE</td></tr><tr><td>数据控制</td><td>GRANT、REVOKE、DENY</td></tr></tbody></table><h2 id="SQL支持的数据类型"><a href="#SQL支持的数据类型" class="headerlink" title="SQL支持的数据类型"></a>SQL支持的数据类型</h2><p>SQL Server支持的主要数据类型有：数值型、日期时间型、字符串型、其他类型</p><h4 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h4><h5 id="精确数字"><a href="#精确数字" class="headerlink" title="精确数字"></a>精确数字</h5><p><img src="https://i.loli.net/2020/06/09/9w42AVEr3RBZTHg.png" alt="数值型"></p><h5 id="近似数字"><a href="#近似数字" class="headerlink" title="近似数字"></a>近似数字</h5><p><img src="https://i.loli.net/2020/06/09/woYOUeisfp5aNz8.png" alt="数值型"></p><h4 id="日期和时间型"><a href="#日期和时间型" class="headerlink" title="日期和时间型"></a>日期和时间型</h4><p><img src="https://i.loli.net/2020/06/09/ZtKcXIGBjprb3y9.png" alt="日期和时间型"></p><h4 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h4><h5 id="普通字符编码串"><a href="#普通字符编码串" class="headerlink" title="普通字符编码串"></a>普通字符编码串</h5><p><img src="https://i.loli.net/2020/06/09/zMeK9IPmlCyNLO4.png" alt="普通字符编码串"></p><h5 id="统一字符编码串"><a href="#统一字符编码串" class="headerlink" title="统一字符编码串"></a>统一字符编码串</h5><p><img src="https://i.loli.net/2020/06/09/1jpheYfnAvLQgyR.png" alt="统一字符编码串"></p><p>二进制串</p><p><img src="https://i.loli.net/2020/06/09/NHdlgq4eUvIuikX.png" alt="二进制串"></p><h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><p><img src="https://i.loli.net/2020/06/09/cwRqAWTYoHdOJNk.png" alt="SQL Server 2012还支持"></p><h2 id="数据定义功能"><a href="#数据定义功能" class="headerlink" title="数据定义功能"></a>数据定义功能</h2><table><thead><tr><th><strong>对 象</strong></th><th><strong>创  建</strong></th><th><strong>修  改</strong></th><th><strong>删  除</strong></th></tr></thead><tbody><tr><td><strong>数据库</strong></td><td><strong>CREATE DATABASE</strong></td><td><strong>ALTER DATABASE</strong></td><td><strong>DROP DATABASE</strong></td></tr><tr><td><strong>架构</strong></td><td><strong>CREATE SCHEMA</strong></td><td><strong>ALTER SCHEMA</strong></td><td><strong>DROP SCHEMA</strong></td></tr><tr><td><strong>表</strong></td><td><strong>CREATE TABLE</strong></td><td><strong>ALTER TABLE</strong></td><td><strong>DROP TABLE</strong></td></tr><tr><td><strong>视图</strong></td><td><strong>CREATE VIEW</strong></td><td><strong>ALTER VIEW</strong></td><td><strong>DROP VIEW</strong></td></tr><tr><td><strong>索引</strong></td><td><strong>CREATE INDEX</strong></td><td><strong>ALTER INDEX</strong></td><td><strong>DROP INDEX</strong></td></tr></tbody></table><p>数据库、架构和表的关系<br>        1.数据库是一个大的仓库<br>        2.架构是大仓库中的一个房间<br>        3.表是某个房间里的货架</p><h4 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h4><h5 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>数据库名<span class="token operator">></span><span class="token punctuation">[</span> <span class="token keyword">ON</span>  <span class="token punctuation">[</span> <span class="token keyword">PRIMARY</span> <span class="token punctuation">]</span> <span class="token operator">&lt;</span>文件<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span>       <span class="token punctuation">[</span> <span class="token punctuation">,</span> <span class="token operator">&lt;</span>文件组<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span> <span class="token punctuation">]</span>       <span class="token punctuation">[</span> LOG <span class="token keyword">ON</span> <span class="token operator">&lt;</span>文件<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">COLLATE</span> <span class="token operator">&lt;</span>校验方式名<span class="token operator">></span> <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token keyword">WITH</span>  <span class="token operator">&lt;</span>选项<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><h5 id="数据库修改"><a href="#数据库修改" class="headerlink" title="数据库修改"></a>数据库修改</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>数据库名<span class="token operator">></span>    <span class="token keyword">ADD</span> <span class="token keyword">FILE</span> <span class="token operator">&lt;</span>文件<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span>         <span class="token punctuation">[</span> <span class="token keyword">TO</span> FILEGROUP { 文件组} <span class="token punctuation">]</span>  <span class="token operator">|</span> <span class="token keyword">ADD</span> LOG <span class="token keyword">FILE</span> <span class="token operator">&lt;</span>文件<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span>   <span class="token operator">|</span> REMOVE <span class="token keyword">FILE</span> <span class="token operator">&lt;</span>文件名<span class="token operator">></span>  <span class="token operator">|</span> <span class="token keyword">MODIFY</span> <span class="token keyword">FILE</span> <span class="token operator">&lt;</span>文件<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><h5 id="数据库删除"><a href="#数据库删除" class="headerlink" title="数据库删除"></a>数据库删除</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>数据库名<span class="token operator">></span>    <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><h5 id="数据库操作举例"><a href="#数据库操作举例" class="headerlink" title="数据库操作举例"></a>数据库操作举例</h5><p>创建一个StudentCourse的数据库 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> StudentCourse</code></pre><p>将一个大小为10MB的数据文件student_Data.mdf添加到StudentCouse数据库中 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> StudentCourse<span class="token keyword">ADD</span> <span class="token keyword">FILE</span><span class="token punctuation">(</span> Name<span class="token operator">=</span>student_Data<span class="token punctuation">,</span>FILENAME<span class="token operator">=</span><span class="token string">'D:\sql\student_Data.mdf'</span><span class="token punctuation">,</span>Size<span class="token operator">=</span>10MB<span class="token punctuation">,</span>Maxsize<span class="token operator">=</span>100MB<span class="token punctuation">,</span>Filegrowth<span class="token operator">=</span>2MB <span class="token punctuation">)</span></code></pre><p>删除StudentCourse的数据库 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> StudentCourse</code></pre><h4 id="架构的定义"><a href="#架构的定义" class="headerlink" title="架构的定义"></a>架构的定义</h4><h5 id="架构创建"><a href="#架构创建" class="headerlink" title="架构创建"></a>架构创建</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> {     <span class="token operator">&lt;</span>架构名<span class="token operator">></span>  <span class="token operator">|</span> <span class="token keyword">AUTHORIZATION</span> <span class="token operator">&lt;</span>所有者名<span class="token operator">></span>  <span class="token operator">|</span> <span class="token operator">&lt;</span>架构名<span class="token operator">></span> <span class="token keyword">AUTHORIZATION</span> <span class="token operator">&lt;</span>所有者名<span class="token operator">></span>}<span class="token punctuation">[</span> { 表定义语句 <span class="token operator">|</span> 视图定义语句     <span class="token operator">|</span> 授权语句 <span class="token operator">|</span> 收权语句 <span class="token operator">|</span> 拒绝权限语句 }   <span class="token punctuation">]</span></code></pre><h5 id="架构修改"><a href="#架构修改" class="headerlink" title="架构修改"></a>架构修改</h5><p>可用于在同一数据库中的架构之间移动对象 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">SCHEMA</span>  <span class="token operator">&lt;</span>架构名<span class="token operator">></span>  TRANSFER  <span class="token operator">&lt;</span>对象名<span class="token operator">></span>  <span class="token punctuation">[</span> <span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><h5 id="架构定义"><a href="#架构定义" class="headerlink" title="架构定义"></a>架构定义</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">SCHEMA</span>  <span class="token operator">&lt;</span>架构名<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><h5 id="架构举例"><a href="#架构举例" class="headerlink" title="架构举例"></a>架构举例</h5><p>为用户“ZHANG”定义一个架构，架构名为“S_C”  </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> S_C <span class="token keyword">AUTHORIZATION</span> ZHANG</code></pre><p>将表Address从架构Person传输到S_C架构来修改该架构</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">SCHEMA</span> S_C TRANSFER Person<span class="token punctuation">.</span>Address</code></pre><p>删除S_C架构 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">SCHEMA</span> S_C</code></pre><h4 id="表的定义"><a href="#表的定义" class="headerlink" title="表的定义"></a>表的定义</h4><h5 id="基本表定义"><a href="#基本表定义" class="headerlink" title="基本表定义"></a>基本表定义</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span>  <span class="token keyword">TABLE</span>  <span class="token operator">&lt;</span>表名<span class="token operator">></span>（ <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">[</span>列级完整性约束定义<span class="token punctuation">]</span>{<span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span>    <span class="token punctuation">[</span>列级完整性约束定义］ … }   <span class="token punctuation">[</span><span class="token punctuation">,</span>表级完整性约束定义 <span class="token punctuation">]</span> ） </code></pre><h5 id="列级完整性约束说明"><a href="#列级完整性约束说明" class="headerlink" title="列级完整性约束说明"></a>列级完整性约束说明</h5><pre class=" language-sql"><code class="language-sql"><span class="token operator">NOT</span> <span class="token boolean">NULL</span>：限制列取值非空。<span class="token keyword">DEFAULT</span>：给定列的默认值。<span class="token keyword">UNIQUE</span>：限制列取值不重。<span class="token keyword">CHECK</span>：限制列的取值范围。<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span>：指定本列为主键。<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span>：定义本列为引用其他表的外键</code></pre><p>说明<br>NOT NULL和DEFAULT只能是列级完整性约束；<br>其他约束均可在表级完整性约束处定义。<br>注意以下几点：<br>        1.如果CHECK约束是定义多列之间的取值约束，则只能在表级完整性约束处定义；<br>        2.如果在表级完整性约束处定义主键和唯一值约束，则应将主键列和唯一值约束列用圆括号括起来，如：PRIMARY             KEY（列1｛[，列2 ] …｝） </p><h5 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h5><pre class=" language-sql"><code class="language-sql"> <span class="token operator">&lt;</span>列名<span class="token operator">></span>  <span class="token operator">&lt;</span>类型<span class="token operator">></span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>    例：sname char<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span></code></pre><h5 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h5><pre class=" language-sql"><code class="language-sql">  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">[</span><span class="token punctuation">(</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> … n<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">]</span>如果在列级完整性约束处定义单列主键，则可省略括号。例<span class="token number">1</span>： SNO char<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span>    例<span class="token number">2</span>： <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>SNO<span class="token punctuation">)</span>        <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>SNO，CNO<span class="token punctuation">)</span></code></pre><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token operator">&lt;</span>外键列名<span class="token operator">></span> <span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">REFERENCES</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>主键列名<span class="token operator">></span><span class="token punctuation">)</span>如果是在列级完整性约束处，则可省略“<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> （<span class="token operator">&lt;</span>列名<span class="token operator">></span>）”部分。例：定义SC表的Sno外键。    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Sno<span class="token punctuation">)</span>      <span class="token keyword">REFERENCES</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">)</span></code></pre><h5 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h5><pre class=" language-sql"><code class="language-sql">  <span class="token keyword">UNIQUE</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span> … n<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">]</span>限制一个列或者是多个列的组合取值不重复用在事实上具有唯一性的属性列上，比如身份证号码、驾驶证号码等。注意：有<span class="token keyword">UNIQUE</span>约束的列允许有一个空值；在一个表中可以定义多个<span class="token keyword">UNIQUE</span>约束；可以在一个列或多个列上定义<span class="token keyword">UNIQUE</span>约束</code></pre><h5 id="默认值约束"><a href="#默认值约束" class="headerlink" title="默认值约束"></a>默认值约束</h5><p> 在创建表时定义DEFAULT约束</p><pre><code> DEFAULT 常量表达式</code></pre><p> 为已创建好的表添加DEFAULT约束</p><pre><code> DEFAULT 常量表达式 FOR 列名</code></pre><p>作用：提供列的默认值。</p><h5 id="列取值范围约束"><a href="#列取值范围约束" class="headerlink" title="列取值范围约束"></a>列取值范围约束</h5><pre><code>CHECK(逻辑表达式)</code></pre><p>用于限制列的取值在指定范围内，即约束列的取值符合应用语义。<br>人的性别：“男”或“女”<br>注意，如果CHECK约束是定义多列之间的取值约束，则只能在“表级完整性约束定义”处定义。</p><h5 id="表定义Jobs表"><a href="#表定义Jobs表" class="headerlink" title="表定义Jobs表"></a>表定义Jobs表</h5><table><thead><tr><th><strong>列  名</strong></th><th><strong>含  义</strong></th><th><strong>数 据 类 型</strong></th><th><strong>约  束</strong></th></tr></thead><tbody><tr><td><strong>Jid</strong></td><td><strong>工作编号</strong></td><td><strong>char(6)</strong></td><td><strong>主键</strong></td></tr><tr><td><strong>Descp</strong></td><td><strong>工作描述</strong></td><td><strong>nvarchar(20)</strong></td><td><strong>非空</strong></td></tr><tr><td><strong>EduReq</strong></td><td><strong>学历要求</strong></td><td><strong>nchar(6)</strong></td><td><strong>默认值：本科</strong></td></tr><tr><td><strong>MinSalary</strong></td><td><strong>最低工资</strong></td><td><strong>int</strong></td><td></td></tr><tr><td><strong>MaxSalary</strong></td><td><strong>最高工作</strong></td><td><strong>int</strong></td><td><strong>大于等于最低工资</strong></td></tr></tbody></table><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Jobs <span class="token punctuation">(</span>  Jid          char<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>     <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>      Descp      <span class="token keyword">nchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  EduReq      <span class="token keyword">nchar</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  <span class="token keyword">DEFAULT</span> <span class="token string">'本科'</span><span class="token punctuation">,</span>   MinSalary  <span class="token keyword">int</span>         <span class="token punctuation">,</span>  MaxSalary  <span class="token keyword">int</span>         <span class="token punctuation">,</span>  <span class="token keyword">CHECK</span><span class="token punctuation">(</span> MaxSalary <span class="token operator">>=</span> MinSalary <span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="表定义Employees表"><a href="#表定义Employees表" class="headerlink" title="表定义Employees表"></a>表定义Employees表</h5><table><thead><tr><th><strong>列  名</strong></th><th><strong>含  义</strong></th><th><strong>数 据 类 型</strong></th><th><strong>约  束</strong></th></tr></thead><tbody><tr><td><strong>Eid</strong></td><td><strong>职工号</strong></td><td><strong>char(10)</strong></td><td><strong>主键</strong></td></tr><tr><td><strong>Ename</strong></td><td><strong>姓名</strong></td><td><strong>nchar(6)</strong></td><td><strong>非空</strong></td></tr><tr><td><strong>Sex</strong></td><td><strong>性别</strong></td><td><strong>nchar(1)</strong></td><td><strong>取值范围：“男”或“女”</strong></td></tr><tr><td><strong>BrithDate</strong></td><td><strong>出生日期</strong></td><td><strong>date</strong></td><td></td></tr><tr><td><strong>JobDate</strong></td><td><strong>参加工作日期</strong></td><td><strong>dateTime</strong></td><td><strong>默认为系统当前日期时间</strong></td></tr><tr><td><strong>Sid</strong></td><td><strong>身份证号</strong></td><td><strong>char(18)</strong></td><td><strong>取值不重</strong></td></tr><tr><td><strong>Jid</strong></td><td><strong>所干工作编号</strong></td><td><strong>char(6)</strong></td><td><strong>外键，引用工作表的工作编号</strong></td></tr><tr><td><strong>Tel</strong></td><td><strong>联系电话</strong></td><td><strong>char(11)</strong></td><td></td></tr></tbody></table><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Employees <span class="token punctuation">(</span>  Eid   char<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>      <span class="token punctuation">,</span>  Ename nvarchar<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  Sex   <span class="token keyword">nchar</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">CHECK</span><span class="token punctuation">(</span> Sex <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token operator">OR</span> Sex <span class="token operator">=</span> <span class="token string">'女'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  BirthDate <span class="token keyword">date</span>           <span class="token punctuation">,</span>  JobDate   <span class="token keyword">datetime</span>       <span class="token keyword">DEFAULT</span> GetDate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  Sid         char<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>        <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>  Jid         char<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>       <span class="token punctuation">,</span>  Tel        char<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>      <span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Eid<span class="token punctuation">)</span>        <span class="token punctuation">,</span>               <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Jid<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Jobs<span class="token punctuation">(</span>Jid<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><p>在定义完表之后，如果需求有变化，比如添加列、删除列或修改列定义，可以使用<strong>ALTER TABLE</strong>语句实现。<br><strong>ALTER TABLE</strong>语句可以对表添加列、删除列、修改列的定义、定义主键、外键，也可以添加和删除约束。 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>  <span class="token punctuation">[</span> <span class="token keyword">ALTER</span>  <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>新数据类型<span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token keyword">ADD</span>  <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">[</span>约束<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token keyword">DROP</span>  <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">]</span><span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">constraint</span> <span class="token operator">&lt;</span>约束名<span class="token operator">></span><span class="token punctuation">]</span> 约束定义<span class="token punctuation">]</span><span class="token operator">|</span> <span class="token punctuation">[</span> <span class="token keyword">DROP</span> <span class="token punctuation">[</span><span class="token keyword">constraint</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>约束名<span class="token operator">></span><span class="token punctuation">]</span></code></pre><p>修改表举例</p><p>例1．为Employees表添加工资列，此列的列名为Salary，数据类型为int，允许空</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Employees  <span class="token keyword">ADD</span> Salary  <span class="token keyword">INT</span></code></pre><p>例2.将Jobs表的Descp列的数据类型改为NCHAR(40)。</p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Jobs   <span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> Descp <span class="token keyword">NCHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span></code></pre><p>例3.删除Employees表的Tel列。</p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Employees   <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> Tel</code></pre><p>例4. 为Jobs表中MinSalary列添加约束：大于等于1600。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Jobs <span class="token keyword">ADD</span> <span class="token keyword">CHECK</span><span class="token punctuation">(</span> MinSalary <span class="token operator">>=</span> <span class="token number">1600</span> <span class="token punctuation">)</span></code></pre><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> { <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">]</span> … }</code></pre><p>例5. Employees表。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> Employees</code></pre><h2 id="数据查询功能"><a href="#数据查询功能" class="headerlink" title="数据查询功能"></a>数据查询功能</h2><h4 id="学生数据库结构"><a href="#学生数据库结构" class="headerlink" title="学生数据库结构"></a>学生数据库结构</h4><p>学生数据库由三个表组成：<br>Student、Course、SC，它们分别表示学生表、课程表和选课表<br><img src="https://i.loli.net/2020/06/10/ukLNzhvXxISUHnr.png" alt=""><br><img src="https://i.loli.net/2020/06/10/oT76OQ2J9vqx3es.png" alt=""><br><img src="https://i.loli.net/2020/06/10/nPEjVGXSgmydFft.png" alt=""></p><p>学生数据库结构</p><p><img src="https://i.loli.net/2020/06/10/kFzTH6wUNcYsrPx.png" alt="学生数据库结构"></p><p>查询语句结构</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>目标列名序列<span class="token operator">></span>    <span class="token comment" spellcheck="true">-- 需要哪些列</span>  <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>            <span class="token comment" spellcheck="true">-- 来自于哪些表</span> <span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>行选择条件<span class="token operator">></span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">-- 根据什么条件</span> <span class="token punctuation">[</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>分组依据列<span class="token operator">></span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>组选择条件<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>排序依据列<span class="token operator">></span><span class="token punctuation">]</span> </code></pre><h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><h5 id="查询指定列"><a href="#查询指定列" class="headerlink" title="查询指定列"></a>查询指定列</h5><p>查询全体学生的学号与姓名<br><img src="https://i.loli.net/2020/06/10/H9K6gjRu5ztqYro.png" alt="查询全体学生的学号与姓名"></p><h5 id="查询全部列"><a href="#查询全部列" class="headerlink" title="查询全部列"></a>查询全部列</h5><p>查询全体学生的全部信息<br><img src="https://i.loli.net/2020/06/10/AHpMcOw7WKvB5J4.png" alt="查询全体学生的全部信息"></p><h5 id="查询表中没有的列"><a href="#查询表中没有的列" class="headerlink" title="查询表中没有的列"></a>查询表中没有的列</h5><p>查询全体学生的姓名及年龄<br><img src="https://i.loli.net/2020/06/10/tO5ZvbTh81EGag3.png" alt="查询全体学生的姓名及年龄"></p><p>查询全体学生的姓名、年龄、字符串“今年是”、今年的年份<br><img src="https://i.loli.net/2020/06/10/4zZxMErR3awUdbm.png" alt="image-20200610082905128"></p><h5 id="查找满足关系的元组"><a href="#查找满足关系的元组" class="headerlink" title="查找满足关系的元组"></a>查找满足关系的元组</h5><p>操作类似于关系代数中的选择运算</p><table><thead><tr><th><strong>查询条件</strong></th><th><strong>谓   词</strong></th></tr></thead><tbody><tr><td>比较运算符</td><td>=, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;（或!=）</td></tr><tr><td>确定范围</td><td>BETWEEN AND, NOT BETWEEN AND</td></tr><tr><td>确定集合</td><td>IN, NOT IN</td></tr><tr><td>字符匹配</td><td>LIKE, NOT LIKE</td></tr><tr><td>空值</td><td>IS NULL, IS NOT NULL</td></tr><tr><td>多重条件</td><td>AND, OR</td></tr></tbody></table><h5 id="查询满足条件-比较大小"><a href="#查询满足条件-比较大小" class="headerlink" title="查询满足条件 比较大小"></a>查询满足条件 比较大小</h5><p>查询计算机系全体学生的姓名<br><img src="https://i.loli.net/2020/06/10/nXxBNkOKgAQIrWC.png" alt="查询计算机系全体学生的姓名"></p><p>查询考试成绩大于90分的学生的学号、课程号和成绩<br><img src="https://i.loli.net/2020/06/10/ufWCtNhsOG2gz9Q.png" alt="查询考试成绩大于90分的学生的学号、课程号和成绩"></p><h5 id="查询满足条件-确定范围"><a href="#查询满足条件-确定范围" class="headerlink" title="查询满足条件 确定范围"></a>查询满足条件 确定范围</h5><pre class=" language-sql"><code class="language-sql"><span class="token operator">BETWEEN</span> … <span class="token operator">AND</span> …<span class="token operator">NOT</span> <span class="token operator">BETWEEN</span> … <span class="token operator">AND</span> …</code></pre><p>作用：查找属性值在或不在指定范围内的元组。<br>说明：<br>        1.BETWEEN后是范围的下限（低值）<br>        2.AND后是范围的上限（高值） </p><p>例：查询学分在2至3之间的课程的课程名、学分和开课学期<br><img src="https://i.loli.net/2020/06/10/MUsP2y7Lzrou4RT.png" alt="查询示例"></p><p>例：查询学分不在2至3之间的课程的课程名、学分和开课学期<br><img src="https://i.loli.net/2020/06/10/IlnAY3RWitX1kMT.png" alt="查询示例"></p><p>例：查询出生在1997年的学生的全部信息<br><img src="https://i.loli.net/2020/06/10/qVP7UB2E84XMnpr.png" alt="image-20200610083609625"></p><h5 id="查询满足条件-确定集合"><a href="#查询满足条件-确定集合" class="headerlink" title="查询满足条件 确定集合"></a>查询满足条件 确定集合</h5><p><strong>作用</strong>：用来查找属性值属于指定集合的元组。<br>格式：</p><pre class=" language-sql"><code class="language-sql"> 列名   <span class="token punctuation">[</span><span class="token operator">NOT</span><span class="token punctuation">]</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>常量<span class="token number">1</span><span class="token punctuation">,</span> 常量<span class="token number">2</span><span class="token punctuation">,</span> …<span class="token punctuation">)</span></code></pre><p>例：查询计算机系和机电系学生的学号、姓名和所在系<br><img src="https://i.loli.net/2020/06/10/uhtaejlHnT5bgsO.png" alt="查询满足条件示例"></p><p>例：查询不在计算机系和机电系学生的学号、姓名和所在系<br><img src="https://i.loli.net/2020/06/10/dlxmnHTKj4UBLwE.png" alt="image-20200610083758897"></p><h5 id="查询满足条件-字符串匹配"><a href="#查询满足条件-字符串匹配" class="headerlink" title="查询满足条件 字符串匹配"></a>查询满足条件 字符串匹配</h5><pre class=" language-sql"><code class="language-sql">列名 <span class="token punctuation">[</span><span class="token operator">NOT</span><span class="token punctuation">]</span> <span class="token operator">LIKE</span> <span class="token operator">&lt;</span>匹配串<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ESCAPE</span> <span class="token operator">&lt;</span>转义字符<span class="token operator">></span><span class="token punctuation">]</span></code></pre><p><strong>匹配串中可包含如下通配符</strong>：<br>            %（百分号）：匹配0个或多个字符。<br>            _（下划线）：匹配一个字符。<br>            []：匹配方括号中的任何一个字符。<br>            [^]：不匹配方括号中的任何一个字符。<br>若要比较的字符是连续的，则可以用连字符“-”表达，例如，要匹配b、c、d、e中的任何一个字符，则可以表示为：[b-e]<br>如果要查找的字符串正好含有通配符，比如下划线或百分号，就需要用ESCAPE来说明。<br>   ESCAPE 转义字符<br>其中“转义字符”是任何一个有效的字符，在匹配串中也包含这个字符，表明位于该字符后面的那个字符将被视为普通字符，而不是通配符。</p><p>例：查找field1字段中包含字符串“30%”的记录：</p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">WHERE</span> field1 <span class="token operator">LIKE</span> <span class="token string">'%30!%%'</span> <span class="token keyword">ESCAPE</span> <span class="token string">'!'</span></code></pre><p>例：查找field1字段中包含下划线（_）的记录：</p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">WHERE</span> field1 <span class="token operator">LIKE</span> <span class="token string">'%!_%'</span> <span class="token keyword">ESCAPE</span> <span class="token string">'!'</span></code></pre><p>例：查询姓“李”的学生的学号、姓名和所在系<br><img src="https://i.loli.net/2020/06/10/OrA7vVaqBfbD9yC.png" alt="查询满足条件 字符串匹配"></p><p>例：查询姓名的第二个字是“冲”的学生的学号、姓名和所在系<br><img src="https://i.loli.net/2020/06/10/yld9jqFa2QsKHke.png" alt="查询满足条件 字符串匹配"></p><p>例：查询学号最后一位不是2或3的学生的学号、姓名和所在系<br><img src="https://i.loli.net/2020/06/10/vjRC71ZxF8Gaugk.png" alt="查询满足条件 字符串匹配"></p><h5 id="查询满足条件-涉空值"><a href="#查询满足条件-涉空值" class="headerlink" title="查询满足条件 涉空值"></a>查询满足条件 涉空值</h5><p>空值是未确定的值或其值尚不知道。<br>例如，学生选课，在开学初学生只有选课记录，没有修课成绩，这时成绩成绩一项的值就是空值。<br>判断列取值为空的语句格式为：</p><pre class=" language-sql"><code class="language-sql">列名 <span class="token operator">IS</span> <span class="token boolean">NULL</span></code></pre><p>判断列取值不为空的语句格式为：</p><pre class=" language-sql"><code class="language-sql">列名 <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span></code></pre><p>例：查询还没有考试的学生的学号、相应的课程号和成绩<br><img src="https://i.loli.net/2020/06/10/iVru8yH2dZfAUTb.png" alt="查询满足条件 涉空值"></p><p>例：查询有备注的学生的学号、姓名、所在系和备注<br><img src="https://i.loli.net/2020/06/10/aBqcKp5Eto2PMJR.png" alt="查询满足条件 涉空值"></p><h5 id="查询满足条件-多条件"><a href="#查询满足条件-多条件" class="headerlink" title="查询满足条件 多条件"></a>查询满足条件 多条件</h5><p>例：查询机电系有备注的学生的学号、姓名、所在系和备注<br><img src="https://i.loli.net/2020/06/10/w95RXg7h1sDHmWG.png" alt="查询满足条件 多条件"></p><p>例：查询机电系和计算机系1997年出生的学生的学号、姓名、所在系和出生日期<br><img src="https://i.loli.net/2020/06/10/L9lTYr3dP6DeFtU.png" alt="查询满足条件 多条件"></p><h5 id="查询满足条件-处理相同行"><a href="#查询满足条件-处理相同行" class="headerlink" title="查询满足条件 处理相同行"></a>查询满足条件 处理相同行</h5><p>例：查询有考试挂科的学生的学号和挂科的课程编号<br><img src="https://i.loli.net/2020/06/10/6lZ8hs3PNckeOfr.png" alt="查询满足条件 处理相同行"><br><img src="https://i.loli.net/2020/06/10/C7GX58UAwTqkOQy.png" alt="查询满足条件 处理相同行"></p><h5 id="对查询结果排序"><a href="#对查询结果排序" class="headerlink" title="对查询结果排序"></a>对查询结果排序</h5><p>可用ORDER BY子句对查询结果进行排序。 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">></span> … <span class="token punctuation">]</span> </code></pre><p>说明：按&lt;列名&gt;进行升序（ASC）或降序（DESC）排序。<br>当用多个列排序时，这些列在该子句中出现的顺序决定了对结果集进行排序的方式。 </p><p>例：将C01号课程的成绩按升序排列<br><img src="https://i.loli.net/2020/06/10/S2H9EsQAZoNxvVU.png" alt="对查询结果排序"></p><p>例：将060101号学生的成绩按降序排列<br><img src="https://i.loli.net/2020/06/10/YqOJEktj8vup7zr.png" alt="对查询结果排序"></p><h5 id="使用聚合函数进行统计"><a href="#使用聚合函数进行统计" class="headerlink" title="使用聚合函数进行统计"></a>使用聚合函数进行统计</h5><p>也称为集合函数或统计函数，<br>其作用是对一组值进行计算并返回一个统计结果。</p><pre class=" language-sql"><code class="language-sql"><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>：统计表中元组的个数。<span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span>：统计列值个数<span class="token function">SUM</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span>：计算列值的和值（必须是数值型列）。AVG（<span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span>：计算列值的平均值（必须是数值型列）。<span class="token function">MAX</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span>：得到列值的最大值。<span class="token function">MIN</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span>：得到列值的最小值。除COUNT（<span class="token operator">*</span>）外，其他函数在计算过程中均忽略<span class="token boolean">NULL</span>值。</code></pre><p>例：统计学生总人数<br><img src="https://i.loli.net/2020/06/10/ZdhqLJMxoS2RP8m.png" alt="使用聚合函数进行统计"></p><p>例：统计学生060101的总成绩<br><img src="https://i.loli.net/2020/06/10/VP34hwfydKNCSs2.png" alt="使用聚合函数进行统计"></p><p>例：统计学生060101的平均成绩<br><img src="https://i.loli.net/2020/06/10/7dlXauxH9Bh2nrW.png" alt="使用聚合函数进行统计"></p><p>例：统计课程C01的最高成绩和最低成绩<br><img src="https://i.loli.net/2020/06/10/ls9NEu5owAHR6Z4.png" alt="使用聚合函数进行统计"></p><h5 id="对数据进行分组"><a href="#对数据进行分组" class="headerlink" title="对数据进行分组"></a>对数据进行分组</h5><p>作用：可以控制计算的级别：对全表还是对一组。<br>目的：细化计算函数的作用对象。<br>分组语句的一般形式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>分组依据列<span class="token operator">></span> <span class="token punctuation">[</span>，… n <span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>组提取条件<span class="token operator">></span><span class="token punctuation">]</span></code></pre><p>例：统计每门课程的选课人数，列出课程号和选课人数<br><img src="https://i.loli.net/2020/06/10/SXa1PLlHsuVoWcp.png" alt="对数据进行分组"></p><p>例：统计每个学生的选课门数，列出学号和选课门数以及他的平均成绩<br><img src="https://i.loli.net/2020/06/10/xOcjGvBWYNIgSR9.png" alt="对数据进行分组"></p><p>例：统计每个系的男生人数和女生人数，结果按系名的升序排列<br><img src="https://i.loli.net/2020/06/10/IuoGlpMYnkFdRye.png" alt="对数据进行分组"></p><p>GROUP BY子句中的分组依据列必须是表中存在的列名，不能使用AS子句指派的列别名。<br>带有GROUP BY 子句的SELECT语句的查询列表中只能出现分组依据列和统计函数，因为分组后每个组只返回一行结果。<br>HAVING用于对分组自身进行限制，它有点象WHERE子句，但它用于组而比是对单个记录。</p><p>WHERE子句用来筛选FROM子句中指定的数据源所产生的行数据。<br>GROUP BY子句用来对经WHERE子句筛选后的结果数据进行分组。<br>HAVING子句用来对分组后的统计结果再进行筛选。</p><p>可以在分组操作之前应用的筛选条件，在WHERE子句中指定更有效。<br>在HAVING子句中指定的筛选条件应该是那些必须在执行分组操作之后应用的筛选条件。<br>将所有应该在分组之前进行的筛选条件放在WHERE子句中而不是HAVING子句中。</p><p>例：统计每个系的男生人数<br><img src="https://i.loli.net/2020/06/10/kWIiRwsOtQnXPeh.png" alt="对数据进行分组"></p><p>例：查询选课门数超过3门的学生的学号和选课门数<br><img src="https://i.loli.net/2020/06/10/tNWeyas7rXOk8SC.png" alt="对数据进行分组"></p><p>例4.41　查询计算机系和机电系每个系的学生人数<br>方案1：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sdept<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> Student  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sdept  <span class="token keyword">HAVING</span> Sdept <span class="token operator">in</span> <span class="token punctuation">(</span> <span class="token string">'计算机系'</span><span class="token punctuation">,</span> <span class="token string">'信息管理系'</span><span class="token punctuation">)</span></code></pre><p>方案2：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> sdept<span class="token punctuation">,</span> <span class="token function">COUNT</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> Student  <span class="token keyword">WHERE</span> Sdept <span class="token operator">in</span> <span class="token punctuation">(</span> <span class="token string">'计算机系'</span><span class="token punctuation">,</span> <span class="token string">'信息管理系'</span><span class="token punctuation">)</span>  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sdept</code></pre><h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><p>若一个查询同时涉及两个或两个以上的表，则称之为<strong>连接查询</strong>。<br>连接查询是关系数据库中最主要的查询，主要包括：<br>        1.内连接<br>        2.外连接：左外连接、右外连接</p><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>是一种最常用的连接类型。使用内连接时，如果两个表的相关字段满足连接条件，则从这两个表中提取数据并组合成新的记录。<br>在非ANSI标准的实现中，连接操作是在WHERE子句中执行的——theta连接<br>在ANSI SQL-92中，连接是在JOIN子句中执行的——ANSI连接。<br>我们介绍ANSI方式的连接格式：</p><pre class=" language-sql"><code class="language-sql">  <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token punctuation">[</span><span class="token keyword">INNER</span><span class="token punctuation">]</span> <span class="token keyword">JOIN</span> 表<span class="token number">2</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>连接条件<span class="token operator">></span> </code></pre><p>连接操作<br>连接查询中用于连接两个表的条件称为连接条件或连接谓词。<br>一般格式为：</p><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span><span class="token operator">&lt;</span>表名<span class="token number">1</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>表名<span class="token number">2</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span> </code></pre><p>首先取表1中的第1个元组，然后从头开始扫描表2，逐一查找满足连接条件的元组，<br>找到后就将表1中的第1个元组与该元组拼接起来，形成结果表中的一个元组。<br>表2全部查找完毕后，再取表1中的第2个元组，然后再从头开始扫描表2， …<br>重复这个过程，直到表1中的全部元组都处理完毕为止。</p><p>例：查询每个学生及其选课的详细<br><img src="https://i.loli.net/2020/06/10/ArtbyvzLdwO5olS.png" alt=""></p><p>例：查询每个学生及其选课的详细，并去掉重复的列<br><img src="https://i.loli.net/2020/06/10/IWJiMTNhloBS2mH.png" alt=""></p><p>例：查询计算机系选修了程序设计课程的学生的姓名、课程名和成绩信息<br><img src="https://i.loli.net/2020/06/10/qfAJOQ8ImR72jvY.png" alt=""></p><p>例：查询选修了程序设计课程的学生的姓名和所在系<br><img src="https://i.loli.net/2020/06/10/5cXq8MoA4zlpGsU.png" alt=""></p><p>例：统计每个系的学生的平均成绩<br><img src="https://i.loli.net/2020/06/10/ihEozSv51XtHkTc.png" alt=""></p><p>例：统计计算机系学生中每门课程的选课人数、平均成绩、最高最低成绩<br><img src="https://i.loli.net/2020/06/10/NtX5QLmSreAcZUz.png" alt=""></p><p>自连接<br>是特殊的内连接。<br>相互连接的表物理上为同一张表。<br>必须为两个表取别名，使之在逻辑上成为两个表。</p><pre class=" language-sql"><code class="language-sql">  <span class="token keyword">FROM</span> 表<span class="token number">1</span> <span class="token keyword">AS</span> T1   <span class="token comment" spellcheck="true">-- 在内存中生成“T1”</span>  <span class="token keyword">JOIN</span> 表<span class="token number">1</span> <span class="token keyword">AS</span> T2   <span class="token comment" spellcheck="true">-- 在内存中生成“T2”</span></code></pre><p>例：查询课程数据库原理的先修课程名<br><img src="https://i.loli.net/2020/06/10/haIwZ6oUuY7pEGq.png" alt=""></p><p>例：查询与钟文辉在同一个系学习的学生的姓名和所在系<br><img src="https://i.loli.net/2020/06/10/hiuZy2mkpQJHGg1.png" alt=""></p><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接会返回FROM子句中提到的至少一个表的所有行，只要这些行符合任何WHERE或HAVING搜索条件。<br>左外连接</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">LEFT</span> <span class="token punctuation">[</span><span class="token keyword">OUTER</span><span class="token punctuation">]</span> <span class="token keyword">JOIN</span></code></pre><p>右外连接 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">RIGHT</span> <span class="token punctuation">[</span><span class="token keyword">OUTER</span><span class="token punctuation">]</span> <span class="token keyword">JOIN</span></code></pre><p>例：查询计算机系学生的选课情况（学号、姓名、所在系、课程编号），包括未选课学生的相关信息<br><img src="https://i.loli.net/2020/06/10/3fmE2TykoRxsjgI.png" alt=""></p><p>例：查询没有人选的课程的课程名<br><img src="https://i.loli.net/2020/06/10/TgOw2lziGDofpIh.png" alt=""></p><p>例：统计计算机系每个学生的选课门数，包含未选课学生的情况<br><img src="https://i.loli.net/2020/06/10/nUDeHpKcaylGEJR.png" alt=""></p><p>例：统计机电系选课门数少于3门的学生的学号和选课门数，包括未选课的学生情况，结果按选课门数降序排列<br><img src="https://i.loli.net/2020/06/10/Is1tEHCKwBnjAQD.png" alt=""></p><p>TOP的使用</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">TOP</span> n <span class="token punctuation">[</span> <span class="token keyword">percent</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">WITH</span> TIES <span class="token punctuation">]</span> </code></pre><p>TOP n：取查询结果的前n行数据。<br>TOP n percnet：取查询结果的前n%行。<br>WITH TIES：包括并列的结果。<br>TOP谓词写在SELECT单词的后边</p><p>例：查询C04号课程成绩的前三名学生的学号和成绩<br><img src="https://i.loli.net/2020/06/10/ojJueYRgLp3hsBw.png" alt=""></p><p>例:查询学分最多的四门课程的名称、学分和开课学期<br><img src="https://i.loli.net/2020/06/10/Jva7qLX2Qb8GRhf.png" alt=""><br><img src="https://i.loli.net/2020/06/10/dsW3bwuFieIXc98.png" alt=""></p><p>例4.56　查询选课人数最多的两门课程，列出课程号和选课人数<br><img src="https://i.loli.net/2020/06/10/f8mq469FEHZOkWp.png" alt=""></p><h4 id="CASE表达式"><a href="#CASE表达式" class="headerlink" title="CASE表达式"></a>CASE表达式</h4><p>是一种多分支表达式，可以根据条件列表的值返回多个可能结果中的一个<br>可用在任何允许使用表达式的地方。<br>不是一个完整的T-SQL语句，不能单独执行。</p><h5 id="简单CASE函数"><a href="#简单CASE函数" class="headerlink" title="简单CASE函数"></a>简单CASE函数</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CASE</span> 测试表达式  <span class="token keyword">WHEN</span> 简单表达式<span class="token number">1</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">1</span>  <span class="token keyword">WHEN</span> 简单表达式<span class="token number">2</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">2</span>  …  <span class="token keyword">WHEN</span> 简单表达式n <span class="token keyword">THEN</span> 结果表达式n  <span class="token punctuation">[</span> <span class="token keyword">ELSE</span> 结果表达式n<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">]</span><span class="token keyword">END</span></code></pre><p>计算测试表达式，然后按从上到下的书写顺序将测试表达式的值与每个WHEN子句的简单表达式进行比较。<br>如果与测试表达式的值相等，则返回第一个与之匹配的WHEN子句所对应的结果表达式的值。<br>如果与所有测试表达式的值都不匹配：<br>若有ELSE子句,则返回ELSE子句中指定的值<br>若没有子句，则返回NULL。</p><p>例：查询全体学生的信息,并对所在系用代码显示：“计算机系”代码为“CS”,“机电系”代码为“JD”,“信息管理系”代码为“IM”<br><img src="https://i.loli.net/2020/06/10/mH1PeUY9Wt5c7MZ.png" alt=""></p><h5 id="搜索CASE函数"><a href="#搜索CASE函数" class="headerlink" title="搜索CASE函数"></a>搜索CASE函数</h5><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CASE</span>  <span class="token keyword">WHEN</span> 布尔表达式<span class="token number">1</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">1</span>  <span class="token keyword">WHEN</span> 布尔表达式<span class="token number">2</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">2</span>  …  <span class="token keyword">WHEN</span> 布尔表达式n <span class="token keyword">THEN</span> 结果表达式n  <span class="token punctuation">[</span> <span class="token keyword">ELSE</span> 结果表达式n<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">]</span><span class="token keyword">END</span></code></pre><p>按从上到下的书写顺序计算每个WHEN子句的布尔表达式。<br>返回第一个取值为TRUE的布尔表达式对应的结果表达式值。<br>如果没有取值为TRUE的布尔表达式：<br>若有ELSE子句,则返回ELSE子句中指定的值<br>若没有子句，则返回NULL。</p><p>例：查询全体学生的信息,并对所在系用代码显示：“计算机系”代码为“CS”,“机电系”代码为“JD”,“信息管理系”代码为“IM”<br><img src="https://i.loli.net/2020/06/10/kHsPftLvEVbrJSO.png" alt=""></p><p>例：查询“C04”号课程的考试情况，列出学号和成绩，同时对成绩进行如下处理：    如果成绩大于等于90，则在查询结果中显示“优”；    如果成绩在80到89分之间，则在查询结果中显示“良”；    如果成绩在70到79分之间，则在查询结果中显示“中”；    如果成绩在60到69分之间，则在查询结果中显示“及格”；    如果成绩小于60分，则在查询结果中显示“不及格”。<br><img src="https://i.loli.net/2020/06/10/puPQ6EsaRdxhvzY.png" alt=""></p><p>例：统计“计算机系”每个学生的选课门数，包括没有选课的学生。列出学号、选课门数和选课情况，其中对选课情况的处理为：如果选课门数超过4门，则选课情况为“多”；如果选课门数在2~4范围内，则选课情况为“一般”；如果选课门数少于2门，则选课情况为“少”；如果学生没有选课，则选课情况为“未选”。并将查询结果按选课门数降序排序。<br><img src="https://i.loli.net/2020/06/10/CyMEqOIF1TJKRUQ.png" alt=""></p><h4 id="将查询结果保存到表中"><a href="#将查询结果保存到表中" class="headerlink" title="将查询结果保存到表中"></a>将查询结果保存到表中</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 查询列表序列 <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>新表名<span class="token operator">></span> <span class="token keyword">FROM</span> 数据源 …</code></pre><p>&lt;新表名&gt;：存放查询结果的表名。<br>该语句将查询结果保存到新表中。</p><p>例：将计算机系学生的学号、姓名、性别、年龄，保存到新表Student_CS中<br><img src="https://i.loli.net/2020/06/10/EZCl4fd6O7LnbTr.png" alt=""><br><img src="https://i.loli.net/2020/06/10/x1fQGiTsLOtbyYU.png" alt=""></p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>在SQL语言中，一个SELECT-FROM-WHERE语句称为一个<strong>查询块</strong>。<br>如果在SELECT、INSERT、UPDATE或DELETE语句中嵌套了SELECT语句，则称之为<strong>子查询或内层查询</strong>；包含子查询的语句称为<strong>主查询或外层查询</strong>。<br>子查询也可以嵌套在另一个子查询中。为了与外层查询有所区别，总是把子查询写在圆括号中。</p><p>子查询语句通常出现在外层查询的WHERE子句或HAVING子句中，与运算符一起构成查询条件</p><p>子查询通常有如下几种形式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">WHERE</span> 列名 <span class="token punctuation">[</span><span class="token operator">NOT</span><span class="token punctuation">]</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>子查询<span class="token punctuation">)</span><span class="token keyword">WHERE</span> 列名 比较运算符 <span class="token punctuation">(</span>子查询<span class="token punctuation">)</span><span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span>子查询<span class="token punctuation">)</span></code></pre><p>子查询通常有如下几种形式：</p><h5 id="子查询-基于集合测试"><a href="#子查询-基于集合测试" class="headerlink" title="子查询 基于集合测试"></a>子查询 基于集合测试</h5><p>子查询的结果往往是一个集合，IN就是在这个集合中进行操作</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">WHERE</span> 表达式 <span class="token punctuation">[</span><span class="token operator">NOT</span><span class="token punctuation">]</span> <span class="token operator">IN</span> <span class="token punctuation">(</span> 子查询 <span class="token punctuation">)</span></code></pre><p>例：查询与“钟文辉”在同一个系学习的学生学号、姓名、性别、所在系<br><img src="https://i.loli.net/2020/06/10/nNycjAJB5L3RxXq.png" alt="子查询 基于集合测试"></p><h5 id="子查询-进行比较测试"><a href="#子查询-进行比较测试" class="headerlink" title="子查询 进行比较测试"></a>子查询 进行比较测试</h5><p>通过比较运算符，将一个表达式的值与子查询返回的值进行比较。</p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">WHERE</span> 列名 比较运算符 （子查询）</code></pre><p>要求子查询语句必须是返回单值的查询语句。</p><p>例：查询选了“C04”号课程且成绩高于此课程的平均成绩的学生的学号和该门课程成绩<br> <img src="https://i.loli.net/2020/06/10/hvKMOqYIRtJ6pWx.png" alt="子查询 进行比较测试"></p><h5 id="子查询-具有ANY或ALL"><a href="#子查询-具有ANY或ALL" class="headerlink" title="子查询 具有ANY或ALL"></a>子查询 具有ANY或ALL</h5><p><img src="https://i.loli.net/2020/06/10/3ZNHXEKGqjQA46C.png" alt="子查询 具有ANY或ALL"></p><p>例：查询比“C03”课程成绩都高的选了“C04”课程的学生的学号和成绩<br><img src="https://i.loli.net/2020/06/10/PX87FeoIaBN3Gui.png" alt=""></p><h5 id="子查询-具有EXISTS"><a href="#子查询-具有EXISTS" class="headerlink" title="子查询 具有EXISTS"></a>子查询 具有EXISTS</h5><p>EXISTS代表存在量词∃。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">WHERE</span> <span class="token punctuation">[</span><span class="token operator">NOT</span><span class="token punctuation">]</span> <span class="token keyword">EXISTS</span>（子查询）</code></pre><p>不返回查询的数据，只产生逻辑真值和假值。<br><strong>EXISTS</strong>：当子查询中有满足条件的数据时，返回真值，否则返回假值。<br><strong>NOT EXISTS</strong>：当子查询中有满足条件的数据时，返回假值；否则返回真值。</p><p>带EXISTS谓词的查询是先外后内，即先执行外层查询，再执行内层查询。<br>外层查询的值决定内层查询的结果；<br>内层查询的执行次数由外层查询的结果决定。<br>由于EXISTS的子查询只返回真、假值，因此在子查询中指定列名没有意义，通常都用“*”</p><p>例：查询选修了“C04”课程的学生的姓名<br><img src="https://i.loli.net/2020/06/10/nyPbG3BM7aqEClK.png" alt=""></p><p>① 无条件执行外层查询语句，在外层查询的结果集中取第一行结果，得到Sno的一个当前值。<br>② 将外层的Sno值作为已知值执行内层查询，如果在内层查询中有满足WHERE条件的记录，则EXISTS返回True，如果没有，则返回False，表示在外层查询结果集中的当前行数据不是满足要求的结果。<br>③ 顺序处理外层Student表的第2、3、… 行数据，直到处理完所有行。</p><p>例：查询至少选修了第三学期开设的全部课程的学生姓名<br><img src="https://i.loli.net/2020/06/10/DsTtZ7wH2uBGd9Y.png" alt=""></p><h4 id="查询的集合运算"><a href="#查询的集合运算" class="headerlink" title="查询的集合运算"></a>查询的集合运算</h4><p>SQL也提供了并、交、差运算的谓词<br>        1.UNION<br>        2.INTERSECT<br>        3.EXCEPT</p><p>例：查询计算机系和机电系所有学生的学号、姓名、性别和所在系<br><img src="https://i.loli.net/2020/06/10/GEDNInzmk59UliB.png" alt=""></p><p>例：查询同时选修了C03与C04号课程的学生的学号<br><img src="https://i.loli.net/2020/06/10/bXqtMSLuoIOnFKr.png" alt=""></p><p>例：查询同时选修了C01但没选C02号课程的学生的学号<br><img src="https://i.loli.net/2020/06/10/TVISpNQgqEOJ9M8.png" alt=""></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图的概述"><a href="#视图的概述" class="headerlink" title="视图的概述"></a>视图的概述</h3><p>视图是由从数据库的基本表中选取出来的数据组成的逻辑窗口，是基本表的部分行和列数据的组合。<br>视图是一个虚表。<br>数据库中只存储视图的定义，而不存储视图所包含的数据。</p><p>视图与基本表之间的关系<br><img src="https://i.loli.net/2020/06/10/cKBLFCYrUptnAhO.png" alt="视图与基本表之间的关系"></p><h4 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h4><p>简化数据查询语句<br>使用户能从多角度看待同一数据<br>提高了数据的安全性<br>提供了一定程度的逻辑独立性</p><h3 id="视图的定义及使用"><a href="#视图的定义及使用" class="headerlink" title="视图的定义及使用"></a>视图的定义及使用</h3><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">(</span>视图列名表<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">AS</span>       查询语句</code></pre><p>查询语句中通常不包含ORDER BY和DISTINCT子句。<br>在定义视图时要么指定视图的全部列名，要么全部省略不写。</p><p>例：查询创建一个包含计算机系学生的成绩单视图，包含学号、姓名、课程号、课程名和成绩<br><img src="https://i.loli.net/2020/06/10/VYnKIJdsN5t9vWO.png" alt=""></p><p>通过上一例创建的视图，计算机系学生的成绩单<br><img src="https://i.loli.net/2020/06/10/3Z5DxgC1nR6hwzS.png" alt=""></p><h3 id="视图的修改与删除"><a href="#视图的修改与删除" class="headerlink" title="视图的修改与删除"></a>视图的修改与删除</h3><h4 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span>  <span class="token operator">&lt;</span>视图名<span class="token operator">></span>   <span class="token punctuation">[</span> <span class="token punctuation">(</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">]</span> <span class="token keyword">AS</span>   <span class="token keyword">SELECT</span>语句</code></pre><p>例：修改上例中的视图，使其包含学生的年龄信息</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span> V_Grade_CS<span class="token keyword">AS</span>   <span class="token keyword">SELECT</span> S<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span> Sname<span class="token punctuation">,</span>     YEAR<span class="token punctuation">(</span>GETDATE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>YEAR<span class="token punctuation">(</span>Sbirthday<span class="token punctuation">)</span> Sage<span class="token punctuation">,</span>    C<span class="token punctuation">.</span>Cno<span class="token punctuation">,</span> Cname<span class="token punctuation">,</span> Grade  <span class="token keyword">FROM</span> Student S<span class="token punctuation">,</span> SC<span class="token punctuation">,</span> Course C  <span class="token keyword">WHERE</span> S<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> SC<span class="token punctuation">.</span>Cno<span class="token operator">=</span>C<span class="token punctuation">.</span>Cno     <span class="token operator">AND</span> Sdept<span class="token operator">=</span><span class="token string">'计算机系'</span></code></pre><p>修改后的视图中的信息<br><img src="https://i.loli.net/2020/06/10/XZfQKryvL9JAtUB.png" alt=""></p><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p>格式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span> </code></pre><p>例： 删除上个例题创建的视图V_Grade_CS。</p><pre class=" language-sq"><code class="language-sq">DROP VIEW V_Grade_CS</code></pre><h3 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h3><p>每次通过标准视图访问数据时，DBMS都会通过视图定义转换为对基本表的查询。这个过程需要花费额外时间。<br>为解决该问题，很多DBMS提供了物理保存视图数据的机制，而且DBMS能够保证当定义视图的基本表数据发生变化时，视图中的数据也随之更改。<br>称这样的视图为<strong>物化视图</strong>（materialized view，SQL Server将其称为<strong>索引视图</strong>）</p><h2 id="数据更改功能"><a href="#数据更改功能" class="headerlink" title="数据更改功能"></a>数据更改功能</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名表<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">]</span>      <span class="token keyword">VALUES</span> （值表）</code></pre><p>功能：新增一个符合表结构的数据行，将值表数据按表中列定义顺序或[列名表]顺序赋给对应列名。</p><p>值与列名按顺序对应，要求值类型与列数据类型一致。<br>对语句中无值对应的列名赋NULL。<br>如果没有指明列名表，则新插入记录的值的顺序必须与表中列的顺序一致，且每一列均有值（可为空）。</p><h4 id="单行插入"><a href="#单行插入" class="headerlink" title="单行插入"></a>单行插入</h4><p>例：向Student表中插入(050101,赵林, 男,1999-09-08,计算机系)的记录<br><img src="https://i.loli.net/2020/06/10/ywflnB2Gz54RoZm.png" alt=""></p><p>查询例上一例后Student表的记录<br><img src="https://i.loli.net/2020/06/10/9Jhwi2eqx87sIZG.png" alt=""></p><h4 id="多行插入"><a href="#多行插入" class="headerlink" title="多行插入"></a>多行插入</h4><p>多行插入数据的INSERT语句的格式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token punctuation">[</span><span class="token keyword">INTO</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名表<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token keyword">SELECT</span>语句</code></pre><p>此语句是将查询产生的结果集插入到表中。</p><p>例:用CREATE 语句建立表StudentBAK，包含(与Student 的Sno、Sname、Sdept 相同)3 个字段， 然后向StudentBAK添加Students 表中的计算机系学生的学号、姓名、所在系的信息<br><img src="https://i.loli.net/2020/06/10/CFAhnfWHaYzpbZo.png" alt=""><br><img src="https://i.loli.net/2020/06/10/q6EnRMz15fl4ASp.png" alt=""><br><img src="https://i.loli.net/2020/06/10/7AbRyeH69YQ1vWT.png" alt=""></p><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">=</span> { 表达式 <span class="token operator">|</span> <span class="token keyword">DEFAULT</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> }<span class="token punctuation">[</span><span class="token punctuation">,</span>… n<span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>条件表名<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>更新条件<span class="token operator">></span> <span class="token punctuation">]</span></code></pre><p>&lt;表名&gt; :要修改数据的表名<br>SET &lt;列名&gt;:指定要修改的列</p><h4 id="无条件更新"><a href="#无条件更新" class="headerlink" title="无条件更新"></a>无条件更新</h4><p>例：将例4.60中创建的Student_CS表中学生的年龄加1 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Student_CS <span class="token keyword">SET</span> Sage <span class="token operator">=</span> Sage <span class="token operator">+</span> <span class="token number">1</span></code></pre><p><img src="https://i.loli.net/2020/06/10/tkPpxWlvMBwn91S.png" alt=""><br><img src="https://i.loli.net/2020/06/10/3mCtzDIOohLPc75.png" alt=""></p><h4 id="有条件更新"><a href="#有条件更新" class="headerlink" title="有条件更新"></a>有条件更新</h4><p>更改表中满足条件的行中指定的列值：<br>         1.基于本表条件的更新<br>         2.基于其它表条件的更新</p><h5 id="基于本表条件更新"><a href="#基于本表条件更新" class="headerlink" title="基于本表条件更新"></a>基于本表条件更新</h5><p>例：把C04号课程的学分加1 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Course <span class="token keyword">SET</span> Credit <span class="token operator">=</span> Credit <span class="token operator">+</span> <span class="token number">1</span>  <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span>‘C04’</code></pre><h5 id="基于其他表条件更新"><a href="#基于其他表条件更新" class="headerlink" title="基于其他表条件更新"></a>基于其他表条件更新</h5><p>例：把数据库原理课程的成绩都减5分 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> SC <span class="token keyword">SET</span> Grade <span class="token operator">=</span> Grade <span class="token operator">-</span> <span class="token number">5</span>  <span class="token keyword">WHERE</span> Cno <span class="token operator">IN</span>   <span class="token punctuation">(</span> <span class="token keyword">Select</span> Cno <span class="token keyword">FROM</span> Course     <span class="token keyword">WHERE</span> Cname<span class="token operator">=</span>‘数据库原理’ <span class="token punctuation">)</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> SC <span class="token keyword">SET</span> Grade <span class="token operator">=</span> Grade <span class="token operator">-</span> <span class="token number">5</span>  <span class="token keyword">FROM</span> SC <span class="token keyword">JOIN</span> Course <span class="token keyword">ON</span> SC<span class="token punctuation">.</span>Cno<span class="token operator">=</span>Course<span class="token punctuation">.</span>Cno   <span class="token keyword">WHERE</span> Cname<span class="token operator">=</span>‘数据库原理’ <span class="token punctuation">)</span></code></pre><h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token punctuation">[</span> <span class="token keyword">FROM</span> <span class="token punctuation">]</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>条件表名<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n <span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>删除条件<span class="token operator">></span> <span class="token punctuation">]</span></code></pre><p>&lt;表名&gt;：要删除数据的表。<br>WHERE：只删除满足WHERE子句条件的记录。如果省略WHERE子句，则表示要无条件删除表中的全部记录。</p><h4 id="无条件删除"><a href="#无条件删除" class="headerlink" title="无条件删除"></a>无条件删除</h4><p>例： 删除例4.60创建的Student_CS表中的数据。</p><p>​    </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Student_CS</code></pre><h4 id="有条件删除"><a href="#有条件删除" class="headerlink" title="有条件删除"></a>有条件删除</h4><p>删除满足条件的数据行：<br>  ① 基于本表条件的删除<br>  ② 基于其他表条件的删除</p><h5 id="基于本表条件的删除"><a href="#基于本表条件的删除" class="headerlink" title="基于本表条件的删除"></a>基于本表条件的删除</h5><p>例4.78 将StudentBAK中学号为050101的学生信息删除</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> StudentBAK    <span class="token keyword">WHERE</span> Sno <span class="token operator">=</span> ‘<span class="token number">050101</span>’</code></pre><h5 id="基于其他表条件的删除"><a href="#基于其他表条件的删除" class="headerlink" title="基于其他表条件的删除"></a>基于其他表条件的删除</h5><p>1.用子查询实现</p><pre class=" language-sql"><code class="language-sql">    <span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 删除表名       <span class="token keyword">WHERE</span> 列名 <span class="token operator">IN</span>（子查询）</code></pre><p>2.用多表连接实现</p><pre class=" language-sql"><code class="language-sql">   <span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 删除表名     <span class="token keyword">FROM</span> 连接表名<span class="token number">1</span> <span class="token keyword">JOIN</span> 连接表名<span class="token number">2</span>      <span class="token keyword">ON</span> 连接条件     <span class="token keyword">WHERE</span> 删除条件</code></pre><p>例： 删除数据库原理的选课记录<br>    1.用子查询实现</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno <span class="token operator">IN</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> Cno <span class="token keyword">FROM</span> Course       <span class="token keyword">WHERE</span> Cname <span class="token operator">=</span> ‘数据库原理' <span class="token punctuation">)</span></code></pre><p>​    2.用多表连接实现</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> SC   <span class="token keyword">FROM</span> SC <span class="token keyword">JOIN</span> Course <span class="token keyword">ON</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">=</span> Course<span class="token punctuation">.</span>Sno <span class="token keyword">WHERE</span> Cname <span class="token operator">=</span> ‘数据库原理'</code></pre><h2 id="数据控制功能"><a href="#数据控制功能" class="headerlink" title="数据控制功能"></a>数据控制功能</h2><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>通过GRANT语句向其他用户授予操作该对象的某些权限 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token operator">&lt;</span>权限<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>权限<span class="token operator">></span><span class="token punctuation">]</span>…<span class="token punctuation">[</span><span class="token keyword">ON</span> <span class="token operator">&lt;</span>对象类型<span class="token operator">></span> <span class="token operator">&lt;</span>对象名<span class="token operator">></span><span class="token punctuation">]</span><span class="token keyword">TO</span> <span class="token operator">&lt;</span>用户<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>用户<span class="token operator">></span><span class="token punctuation">]</span>…<span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token keyword">AS</span> 用户 <span class="token punctuation">]</span> </code></pre><p>例：给用户Mary 和 John授予创建数据库和创建表的权限</p><pre class=" language-sql"><code class="language-sql">BRANT CRREATE <span class="token keyword">DATABASE</span><span class="token punctuation">,</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>  <span class="token keyword">TO</span> Mary <span class="token punctuation">,</span> John</code></pre><h3 id="回收授权"><a href="#回收授权" class="headerlink" title="回收授权"></a>回收授权</h3><p>例：将用户Mary 和 John创建数据库和创建表的权限回收 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">REVOKE</span> CRREATE <span class="token keyword">DATABASE</span><span class="token punctuation">,</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>  <span class="token keyword">FROM</span> Mary <span class="token punctuation">,</span> John</code></pre><h3 id="拒权"><a href="#拒权" class="headerlink" title="拒权"></a>拒权</h3><p>拒权是指拒绝为指定用户对某个数据库对象使用某种权限<br>防止该主体通过组或角色成员身份继承权限  </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DENY</span> <span class="token operator">&lt;</span>权限<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>权限<span class="token operator">></span><span class="token punctuation">]</span>…<span class="token punctuation">[</span><span class="token keyword">ON</span> <span class="token operator">&lt;</span>对象类型<span class="token operator">></span> <span class="token operator">&lt;</span>对象名<span class="token operator">></span><span class="token punctuation">]</span><span class="token keyword">TO</span> <span class="token operator">&lt;</span>用户<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>用户<span class="token operator">></span><span class="token punctuation">]</span>… </code></pre><p>例：拒绝让Mary, John拥有CREATE DATABASE 和 CREATE TABLE的权限，除非给他们显式授予权限  </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DENY</span> CRREATE <span class="token keyword">DATABASE</span><span class="token punctuation">,</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>  <span class="token keyword">TO</span> Mary <span class="token punctuation">,</span> John</code></pre><h1 id="查询处理与优化"><a href="#查询处理与优化" class="headerlink" title="查询处理与优化"></a>查询处理与优化</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>查询处理</strong>：从查询语句出发到获得最终的查询结果所进行的处理过程<br><strong>查询优化</strong>：SQL是非过程化语言，即仅表达查询要求，而不用说明查询执行过程。由DBMS来确定合理的、有效的执行策略的过程。</p><h3 id="查询优化途径"><a href="#查询优化途径" class="headerlink" title="查询优化途径"></a>查询优化途径</h3><p><strong>代数优化</strong>：通过改变查询语句的操作顺序，使查询语句执行起来更有效。<br><strong>物理优化</strong>：根据系统提供的存取路径，选择最合理的存取策略。<br><strong>规则优化</strong>：仅根据启发式规则，选择执行策略，如先做选择、投影，后做连接操作<br><strong>代价估算优化</strong>：对可供选择的执行策略执行代价估算，从中选出代价最小的策略。</p><h2 id="SQL的查询处理"><a href="#SQL的查询处理" class="headerlink" title="SQL的查询处理"></a>SQL的查询处理</h2><p><strong>查询处理的任务是把用户提交给RDBMS的查询语句转换为高效的查询执行计划</strong>。</p><h3 id="查询处理步骤"><a href="#查询处理步骤" class="headerlink" title="查询处理步骤"></a>查询处理步骤</h3><p>查询处理是将高层查询（比如SQL）转换为一个低层语义表达的正确并且有效的执行计划的过程，低层语义完成对数据库的检索和操作。</p><p>步骤<br><strong>查询分析</strong>：对查询语句进行扫描、词法分析和语法分析<br><strong>查询检查</strong>：根据数据字典对合法的查询语句进行语义检查，即检查语句中的数据库对象是否存在和是否有效<br><strong>查询优化</strong>：查询优化就是选择一个高效执行的查询处理策略<br><strong>查询执行</strong>：依据优化器得到的执行策略生成查询计划，由代码生成器生成执行这个查询计划的代码，并执行代码，返回查询结果<br><img src="https://i.loli.net/2020/06/10/FlBpqyMJ6z89Aoh.png" alt="查询处理步骤"></p><h3 id="优化的一个简单示例"><a href="#优化的一个简单示例" class="headerlink" title="优化的一个简单示例"></a>优化的一个简单示例</h3><p>查询选修了“C001”号课程的学生的姓名。<br>SQL语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sname   <span class="token keyword">FROM</span> Student S <span class="token keyword">JOIN</span> SC   <span class="token keyword">ON</span> S<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno  <span class="token keyword">WHERE</span> Cno <span class="token operator">=</span> <span class="token string">'C001'</span></code></pre><p>关系代数表达式</p><p><img src="https://i.loli.net/2020/06/10/uYz2BxSn1UdyP8q.png" alt="关系代数表达式"></p><p>  设数据库中有1000个学生记录，10000个选课记录，其中选了“C001”课程的选课记录有50个。</p><p>一般连接法<br>在内存中尽可能多地装入某个表（比如Student）的若干块，并留出一块存放另一个表（比如SC）的元组。<br>把SC中的每个元组与Student的每个元组进行连接，连接后的元组装满一块后就写到中间文件上，再从SC表中读入一块数据。<br>再和内存中的Student元组进行连接，直到SC表处理完。<br>再读入若干块Student元组，读入一块SC元组。重复上述处理过程，直到处理完Student表的所有元组。</p><p>假设<br>假设一块能装10个Student元组或100个SC表的元组。<br>设在内存中最多可存放5块Student表数据和1块SC表数据。<br>设每秒能读写20块。<br>设每块能装10个连接后的元组。<br>Q1执行过程：<br>        1.进行广义笛卡尔积操作<br>            笛卡尔积开销：<br>$$<br>读取的总块数为：<br>   1000/10 + 1000/(10×5)×10000/100 = 100 + 20×100 = 2100（块）\<br>该过程总共花费时间：<br>    2100/20 = 105秒\<br>Student和SC表连接后的元组数：<br>    1000×10000 = 10^7\<br>写出这些连接后的元组花费时间：<br>    (107/10)/20 = 5×10^4秒<br>$$<br>​        2.进行选择操作<br>​            选择开销：<br>$$<br>依次读入连接后的元组，选取满足选择条件的元组。\<br>假定忽略内存处理时间，则这一步读取存放连接结果的中间文件需花费的时间同写中间文件一样，也是5×10^4秒。\<br>由于满足条件的元组只有50个，因此均可放在内存中。<br>$$<br>​        3.进行投影操作<br>​            投影开销：<br>$$<br>对连接得到的结果再在Sname列上进行投影，得到最终结果。\<br>这个步骤由于不需要读写磁盘，因此，时间忽略不计。\<br>则Q_1的总执行时间约为：<br>    105+2×5×10^4≈10^5（秒）<br>$$<br>Q2执行过程：<br>        1.进行自然连接操作<br>            自然连接开销：<br>$$<br>总的读取块数仍为2100块，需要105秒\<br>但自然连接的结果比Q_1大大减少，为：<br>    10000 = 10^4个（即SC表元组数）\<br>因此，写出这些元组需要的时间为：(104/10)/20 = 50（秒）<br>仅为Q1执行时间的千分之一。<br>$$<br>​        2.进行选择操作<br>​            选择操作开销：<br>$$<br>读取中间文件块，同写元组一样，也是50秒。<br>$$<br>​        3.进行投影操作<br>​            投影操作开销：<br>$$<br>对第2步的结果在Sname列上进行投影，花费时间忽略不计。\则Q2的总执行时间约为：<br>    105+50+50≈205（秒）<br>$$<br>Q3执行过程：<br>        1.对SC表进行选择运算<br>            选择运算开销：<br>$$<br>只需读一遍SC表，共计100块数据，花费时间: 100/20 = 5（秒）\<br>由于满足条件的元组仅有50个，因此不必使用中间文件<br>$$<br>​        2.进行自然连接操作<br>​            自然连接开销：<br>$$<br>只需读一遍Student表，共计100块，花费时间: 100/20 = 5（秒）<br>$$<br>​        3.对连接的结果进行投影操作<br>​            投影开销：<br>$$<br>对第2步的结果在Sname列上进行投影，花费时间忽略不计。\<br>则Q3的总执行时间约为：<br>     5 + 5 ≈ 10（秒）<br>$$<br>进一步优化措施<br>对于Q3的执行过程，如果SC表的Cno列上建有索引，则第一步只需读取Cno = ‘C001’的50个元组。<br>若Student表在Sno列上也建有索引，则第二步最多涉及50个Student记录，因此也可以极大地减少读取Student表的块数。</p><h2 id="查询优化方法"><a href="#查询优化方法" class="headerlink" title="查询优化方法"></a>查询优化方法</h2><p>查询优化可分为<strong>代数优化</strong>和<strong>物理优化</strong><br><strong>代数优化</strong>指关系代数表达式的优化，即按照一定的规则，改变代数表达式中操作的次序和组合，使查询执行效率更高<br><strong>物理优化</strong>则是指存取路径和底层操作算法的选择 </p><h3 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h3><p>代数优化是对查询进行<strong>等价变换</strong>，以减少执行的开销<br>所谓等价是指变换后的关系代数表达式与变换前的关系代数表达式所得到的结果是相同的</p><h4 id="变换规则"><a href="#变换规则" class="headerlink" title="变换规则"></a>变换规则</h4><p>将一个关系代数表达式转换为另一个等价的能更有效执行的表达式。<br>最常用的变换原则是尽可能减少查询过程中产生的中间结果。<br>尽可能先做选择和投影操作，再做连接操作。<br>在连接时，先做小关系之间的连接，再做大关系的连接。</p><h5 id="多重选择（σ）"><a href="#多重选择（σ）" class="headerlink" title="多重选择（σ）"></a>多重选择（σ）</h5><p>设R是某个关系，则有：</p><p>$$<br>σ<em>{C1ΛC2Λ…ΛCn}(R)≡ σ</em>{C1}(σ<em>{C2}(…(σ</em>{Cn}(R)…))<br>$$<br>示例：<br>$$<br>σ<em>{Sdept}= ‘计算机系’Λ\ Ssex = ‘男’（Student）≡\σ</em>{Sdept}= ‘计算机系’（σ_{Ssex} = ‘男’（Student））<br>$$</p><h5 id="选择（σ）交换律"><a href="#选择（σ）交换律" class="headerlink" title="选择（σ）交换律"></a>选择（σ）交换律</h5><p>$$<br>σ<em>{C1}（σ</em>{C2}（R））≡ σ<em>{C2}（σ</em>{C1}（R））<br>$$</p><p>示例：<br>$$<br>σ<em>{Sdept} = ‘计算机系’（σ</em>{Ssex} = ‘男’（Student））≡ σ<em>{Ssex} \= ‘男’（σ</em>{Sdept} = ‘计算机系’（Student））<br>$$</p><h5 id="多重投影（∏）"><a href="#多重投影（∏）" class="headerlink" title="多重投影（∏）"></a>多重投影（∏）</h5><p>$$<br>  ∏<em>{A1}(∏</em>{A1，A2}( … ∏<em>{A1，A2,…,An}(R))) ≡ ∏</em>{A1}(R)<br>$$</p><p>示例：<br>$$<br>∏<em>{sname}（∏</em>{Sdept,Sname}（Student））≡<br>    ∏_{sname}（Student）<br>$$</p><h5 id="选择（σ）与投影（∏）交换律"><a href="#选择（σ）与投影（∏）交换律" class="headerlink" title="选择（σ）与投影（∏）交换律"></a>选择（σ）与投影（∏）交换律</h5><p>$$<br>σ<em>c（∏</em>{A1,A1,…,An}(R)) ≡∏_{A1,A1,…,An}(σ_c(R))<br>$$</p><p>示例：<br>$$<br>σ<em>{Sage&gt;=20}（∏</em>{sname,sdept,sage}(Student))≡ ∏<em>{sname,sdept,sage} (σ</em>{Sage&gt;=20} (Student))<br>$$</p><h5 id="连接和笛卡尔积（×）交换律"><a href="#连接和笛卡尔积（×）交换律" class="headerlink" title="连接和笛卡尔积（×）交换律"></a>连接和笛卡尔积（×）交换律</h5><p><img src="https://i.loli.net/2020/06/10/q8bvF7UCx5agefo.png" alt="连接和笛卡尔积（×）交换律"></p><p>示例：</p><p><img src="https://i.loli.net/2020/06/10/ygEjzBicK1MAltv.png" alt="示例"></p><h5 id="并（∪）和交（∩）运算的交换律"><a href="#并（∪）和交（∩）运算的交换律" class="headerlink" title="并（∪）和交（∩）运算的交换律"></a>并（∪）和交（∩）运算的交换律</h5><p>$$<br>R ∪ S ≡ S ∪ R\<br>R ∩ S ≡ S ∩ R<br>$$</p><h5 id="选择（σ）和连接的交换律"><a href="#选择（σ）和连接的交换律" class="headerlink" title="选择（σ）和连接的交换律"></a>选择（σ）和连接的交换律</h5><p><img src="https://i.loli.net/2020/06/10/dkAyrx6cJzEfe3N.png" alt="选择（σ）和连接的交换律"></p><p>示例:</p><p><img src="https://i.loli.net/2020/06/10/9fGIBNxsak6neSy.png" alt="示例"></p><h5 id="投影（∏）和连接的分配律"><a href="#投影（∏）和连接的分配律" class="headerlink" title="投影（∏）和连接的分配律"></a>投影（∏）和连接的分配律</h5><p>设R和S的连接属性在L1和L2中，则<br><img src="https://i.loli.net/2020/06/10/jHiJXvROd2ucWZl.png" alt="投影（∏）和连接的分配律"></p><p>示例：<br><img src="https://i.loli.net/2020/06/10/RnHckqXzZeOrDPi.png" alt="image-20200610131139282"></p><h5 id="选择与集合并、交、差运算的分配律"><a href="#选择与集合并、交、差运算的分配律" class="headerlink" title="选择与集合并、交、差运算的分配律"></a>选择与集合并、交、差运算的分配律</h5><p>设R和S有相同的属性，则：<br>$$<br>σ_c（R ∪ S）≡ σ_c（R）∪σ_c（S）\<br>σ_c（R ∩ S）≡ σ_c（R）∩σ_c（S）\<br>σ_c（R - S）≡ σ_c（R）- σ_c（S）<br>$$</p><h5 id="投影（∏）与并运算的分配律"><a href="#投影（∏）与并运算的分配律" class="headerlink" title="投影（∏）与并运算的分配律"></a>投影（∏）与并运算的分配律</h5><p>设R和S有相同的属性，则：<br>$$<br>∏_L(R ∪ S) ≡ ∏_L(R)∪ ∏_L(S)<br>$$</p><h5 id="连接和笛卡尔积的结合律"><a href="#连接和笛卡尔积的结合律" class="headerlink" title="连接和笛卡尔积的结合律"></a>连接和笛卡尔积的结合律</h5><p><img src="https://i.loli.net/2020/06/10/PhR1t6Y5ncgNap8.png" alt="连接和笛卡尔积的结合律"></p><h5 id="并（∪）和交（∩）的结合律"><a href="#并（∪）和交（∩）的结合律" class="headerlink" title="并（∪）和交（∩）的结合律"></a>并（∪）和交（∩）的结合律</h5><p>$$<br>（R∪S）∪ T ≡ R∪（S∪T）\<br>（R∩S）∩ T ≡ R∩（S∩T）<br>$$</p><h4 id="启发式规则"><a href="#启发式规则" class="headerlink" title="启发式规则"></a>启发式规则</h4><p>用于对关系代数表达式的查询树进行优化。<br>查询树也称为<strong>关系代数树</strong>，它用形象的形式来表达关系代数的执行过程。<br>查询树包括：<br>        1.叶结点：代表查询的基本输入关系。<br>        2.非叶结点：代表在关系代数表达式中应用操作的中间关系。<br>        3.根结点：代表查询的结果。<br>查询树的操作顺序为：<strong>从叶到根</strong>。</p><p><img src="https://i.loli.net/2020/06/10/ZCbu5KHEkgPJ2yf.png" alt="举例"></p><p>尽可能先做选择运算。<br>投影运算和选择运算同时进行。<br>把投影运算和其之前或之后的二元运算结合起来，以减少关系的扫描次数。<br>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算。<br>找出公共子表达式。</p><p><img src="https://i.loli.net/2020/06/10/jamLN3oyFGCcB8E.png" alt="举例"></p><p>转换为初始关系代数表达式(未优化)<br><img src="https://i.loli.net/2020/06/10/Q2jWkTLrZP9byGI.png" alt=""></p><p>利用转换规则进行优化</p><p>①用规则1将选择操作的连接操作部分分解到各个选择操作中，使尽可能先执行选择操作 。<br>$$<br>∏<em>{Sname}(σ</em>{Student.Sno=SC.Sno}(Student×(σ_{Cno=‘2’}(SC))))<br>$$<br><img src="https://i.loli.net/2020/06/10/D8MlQEd1KHhkPGy.png" alt=""></p><p>②将笛卡尔积操作替换为等值连接操作<br><img src="https://i.loli.net/2020/06/10/bPOjHh7mRYuZLS1.png" alt=""></p><p><img src="https://i.loli.net/2020/06/10/MdOs5rvYBUDxmCf.png" alt=""></p><p>③用规则4和6对Student进行投影操作<br><img src="https://i.loli.net/2020/06/10/ipS7gWLxcTKebwt.png" alt=""></p><p><img src="https://i.loli.net/2020/06/10/yupOevniG8LqF5M.png" alt=""></p><p><img src="https://i.loli.net/2020/06/10/jDeaLPwtIlFhSWf.png" alt=""><br><img src="https://i.loli.net/2020/06/10/YwyI9gdfovVnqND.png" alt=""><br><img src="https://i.loli.net/2020/06/10/FaTvBNQ5iLxdOjq.png" alt="image-20200610134824597"></p><h2 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h2><p>代数优化不涉及底层的存取路径。因此，对各种操作的执行策略无从选择，只能在操作次序和组合上根据启发式规则做一些变换和调整。<br>单纯依靠代数优化是不完善的，优化的效果也是有限的。<br>合理地选择存取路径，往往能收到显著的优化效果。<br><strong>物理优化</strong>——依赖于存取路径的优化。</p><h3 id="选择操作的优化"><a href="#选择操作的优化" class="headerlink" title="选择操作的优化"></a>选择操作的优化</h3><p>对于<strong>小关系</strong>，不必考虑其他存取路径，直接用顺序扫描。<br>如果<strong>无索引或散列</strong>等存取路径可用，或估计选择的元组数在关系中占有较大的比例（大于15％），且有关属性无聚集索引，则用顺序扫描。<br>对于<strong>主键</strong>的等值条件查询，最多只有一个元组可以满足条件，因此应优先采用主键上的索引或散列。<br>对于<strong>非主键</strong>的等值条件查询，要估计选择的元组数在关系中所占的比例。如果比例较小（小于15％），可用非聚集索引，否则用聚集索引或顺序扫描。<br>对于<strong>范围条件查询</strong>，一般先通过索引找到范围的边界，再通过索引的有序集沿相应的方向进行搜索。若选择的元组数在关系中所占的比例较大，且没有有关属性的聚集索引，则宜采用顺序扫描。<br>对于<strong>用OR连接的析取选择条件</strong>，只能按其中各个条件分别选出一个元组集，然后再计算这些元组的并集。<br>对于<strong>用AND连接的合取选择条件</strong><br>        1.若有相应的多属性索引，则应先采用多属性索引<br>        2.否则，可检查各个条件中是否有多个可用的二次索引检索的，若有，则用预查找法处理。即通过二次索引找出满足            条件的元组id集合，然后再求出这些id集合的交集。最后取出交集中id所对应的元组，并在获取这些元组的同时，            用合取条件中的其余条件检查。<br>        3.凡能满足所有其余条件的元组即为所检索的元组</p><p>有些选择操作只要访问索引就可以获得结果。<br>如查询索引属性的最大值、最小值、平均值等。<br>这种情况应优先利用索引，避免访问数据。</p><h3 id="连接操作的优化"><a href="#连接操作的优化" class="headerlink" title="连接操作的优化"></a>连接操作的优化</h3><p>连接操作是开销很大的操作，一直是查询优化研究的重点。<br>主要讨论二元连接的优化。<br>实现连接操作一般有<br>        1.嵌套循环<br>        2.利用索引和散列匹配元组<br>        3.排序归并<br>        4.散列连接</p><p>如果两个关系都已按连接属性排序，则优先选用排序归并法。如果两个关系中有一个关系已按连接属性排序，而另一个关系很小，则可考虑按连接属性排序，然后再用排序归并法进行连接。<br>如果两个关系中有一个关系在连接属性上有索引或散列，则可以另一个关系为外关系，顺序扫描，并利用内关系上的索引或散列寻找与之匹配的元组，以代替多遍扫描。<br>如果上述两个规则的条件都不具备，且两个关系都比较小，则可以用嵌套循环法。<br>如果上述规则都不适用，则可以选用散列连接法。</p><h3 id="投影操作的优化"><a href="#投影操作的优化" class="headerlink" title="投影操作的优化"></a>投影操作的优化</h3><p>投影操作一般与选择、连接等操作<strong>同时进行</strong>，不需要附加的I/O开销<br>消除重复元组是比较费时的操作<br>        1.一般需要将投影结果按其所有属性排序，使重复元组连续存放，以便于发现重复元组<br>        2.散列也是消除重复元组的一个可行的方法。</p><h1 id="数据库的存储"><a href="#数据库的存储" class="headerlink" title="数据库的存储"></a>数据库的存储</h1><h1 id="数据库安全与保护"><a href="#数据库安全与保护" class="headerlink" title="数据库安全与保护"></a>数据库安全与保护</h1><h1 id="实体关系模型（大题）"><a href="#实体关系模型（大题）" class="headerlink" title="实体关系模型（大题）"></a>实体关系模型（大题）</h1><h2 id="E-R模型的基本概念"><a href="#E-R模型的基本概念" class="headerlink" title="E-R模型的基本概念"></a>E-R模型的基本概念</h2><p>是用于数据库设计的<strong>高层概念数据模型</strong>。<br>概念数据模型用来描述数据库的结构以及有关的在数据库上的检索和更新事务，<br>独立于任何数据库管理系统和硬件平台。</p><h3 id="实体-1"><a href="#实体-1" class="headerlink" title="实体"></a>实体</h3><p>是现实世界中独立存在的、可区别于其他对象的“对象”或“事物”。<br>是关于将被收集的信息的主要数据对象。<br>具有一组属性。<br>可以是物理存在的对象：人、汽车、商品、职工等；<br>也可以是抽象存在的对象：公司、企业、工作或感兴趣信息事件</p><h4 id="实体与实例"><a href="#实体与实例" class="headerlink" title="实体与实例"></a>实体与实例</h4><p>实体（entity set，也称为实体集）是一组具有相同特征或属性的实体的集合。<br>    比如：学生<br>实例是实体中具有相同结构的可区分的对象。<br>    比如：学生“张三”、“李四”<br><img src="https://i.loli.net/2020/06/11/Yem4gitWxT9z2JU.png" alt="实体与实例示例"></p><h4 id="实体的分类"><a href="#实体的分类" class="headerlink" title="实体的分类"></a>实体的分类</h4><p>强实体（也称为强实体集）<br>    不依赖于其他实体而存在的实体。<br>    如：“职工”<br>    <strong>特点</strong>：每个实例都能被实体的主键唯一标识。<br>强实体也称为：<br>    1.父实体<br>    2.主实体<br>    3.统治实体</p><p>弱实体（也称为弱实体集）<br>    依赖于其他实体而存在的实体。<br>    如：“职工子女”<br>    <strong>特点</strong>：每个实例不能用该实体的属性唯一标识。<br>弱实体也称为：<br>    1.子实体<br>    2.依赖实体<br>    3.从实体</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>实体的特性或联系的特征都称为<strong>属性</strong>。<br>同一个实体中的实例具有相同属性。<br>    例如：“学生”实体的属性有：姓名、学号、性别等。<br>实体中的每个属性都有取值范围，属性的取值范围称为<strong>值域</strong>。</p><p>一个属性可由多个值域构成。<br>    例如：属性“生日”的值域由年、月、日的值域构成。<br>多个属性可以共享一个值域，该值域称为属性域。<br>属性域的值是一组一个或多个属性所允许的取值。<br>    例如，“工人”和“管理员”的“生日”属性可以共享一个属性域。</p><p><strong>联系的属性</strong><br>联系也可以具有属性。<br>通常，只有二元多对多联系和三元联系才具有属性，一对一联系和一对多联系没有属性。<br><img src="https://i.loli.net/2020/06/11/kUERJh5Ya94qQFO.png" alt="联系的属性示例"></p><h4 id="简单属性"><a href="#简单属性" class="headerlink" title="简单属性"></a>简单属性</h4><p>由一个独立成分构成的属性。<br>不可再分成更小的成分。<br>也称为原子属性。<br>实体“学生”中的学号、姓名、性别属性都是简单属性的例子。</p><h4 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h4><p>由多个独立存在的成分构成的属性。<br>有些属性可以划分成更小的独立成分。<br>如，设“职工”实体中有“地址”属性，该属性取值形式为“<strong>省</strong>市<strong>区</strong>街道”，则该属性可进一步分解为<br>    省、市、区、街道<br>    “街道”又可分为街道号、街道名和楼牌号三个简单属性。<br><img src="https://i.loli.net/2020/06/11/tBDjEpoIn7sHSbm.png" alt="复合属性示例"></p><h4 id="单值属性"><a href="#单值属性" class="headerlink" title="单值属性"></a>单值属性</h4><p>若某属性对特定实体中的每个实例都只取一个值，则该属性为单值属性。<br>如：“学生”实体中每个实例的“学号”属性都只有一个值，则“学号”为单值属性。<br>大多数属性都是单值属性。</p><h4 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h4><p>若某属性对特定实体中的每个实例可以取多个值，则该属性为多值属性。<br>    如“职工”的“技能”属性，一个职工可有多项技能：“总体设计”、“程序设计”、“数据库管理”…<br>可对多值属性的取值范围进行限制。<br>    如：限定“技能”的取值为1~3。<br>在E-R图中，用<strong>双线圆角矩形</strong>表示是多值属性。</p><h4 id="派生属性"><a href="#派生属性" class="headerlink" title="派生属性"></a>派生属性</h4><p>派生属性的值是由相关联的属性或属性组派生出来的，这些属性并非来自同一实体。<br>    “职工”实体的“工龄”属性的值可由该职工的“参加工作日期”和当前日期计算得到。<br>派生属性的值也可以派生于同一实体中的实例。<br>    “职工”实体的“总人数”属性的值可通过计算“职工”实体中的实例总数获得。<br>在E-R图中用<strong>虚线的圆角矩形</strong>表示是派生属性</p><h4 id="标识属性"><a href="#标识属性" class="headerlink" title="标识属性"></a>标识属性</h4><p>能够唯一标识实体中每个实例的属性或属性组。<br>用于唯一标识一个实例的属性组称为复合标识符。 如：<br>    “职工”实体中的 “职工号”<br>    “项目”实体中的 “项目号”<br>    “列车”实体中的 “车次”和“发车时间”<br>在E-R图中用<strong>下划线标识</strong>。<br>复合标识符示例：<br><img src="https://i.loli.net/2020/06/11/MygRGVvrCxInXWu.png" alt="复合标识符示例"></p><h4 id="属性综合示例"><a href="#属性综合示例" class="headerlink" title="属性综合示例"></a>属性综合示例</h4><p><img src="https://i.loli.net/2020/06/11/LUFWqMRA6ZOeJXS.png" alt="属性综合示例"></p><h3 id="联系-1"><a href="#联系-1" class="headerlink" title="联系"></a>联系</h3><p>指用户业务中相关的两个或多个实体之间的关联。<br>表示现实世界的关联关系。<br>只依赖于实体间的关联，在物理和概念上是不存在的。<br>联系的一个具体值称为联系实例。<br>联系实例是可唯一区分的关联，包括每一个参与实体的一个实例，表明特定的实体实例间是相互关联的。<br>联系也被看成是抽象对象。<br>联系通过连线将相互关联的实体连接起来。<br>相似的联系被归到一个联系（也称为联系集或联系型）中。</p><p>一个具体的联系表达了实体之间的一组有意义的关联，<br>如“学生”实体和“课程”实体之间存在一个“选课”联系，<br>如果学生（081001，张三，男）选了课程（C001，计算机网络），<br>则（081001，张三，男）和（C001，计算机网络）之间就存在一个联系实例，<br>这个联系实例可表示为（081001，C001，…）。</p><p><strong>联系的特性</strong><br>    1.联系的度<br>        指联系中相关联的实体的数量。<br>        一般有:<br>                1.递归联系或一元联系<br>                2.二元联系<br>                3.三元联系</p><p>​    2.连接性<br>​    3.存在性<br>​    4.n元联系</p><p><strong>联系的连接性</strong><br>描述联系中相关联实体间映射的约束。<br>取值为“一”或“多个”。<br>例如：实体“部门”和“职工”之间为一对多的联系，即对“职工”实体中的多个实例，在“部门”中至多有一个实例与其关联。<br>实际的连接数目称为联系连接的基数。</p><p><strong>联系的存在性</strong><br>指某个实体的存在依赖于其它实体的存在。<br>联系中实体的存在分为强制和非强制（或可选的）两种。<br>强制存在要求联系中任何一端的实体的实例都必须存在。<br>非强制存在允许实体的实例可以不存在。<br>在E-R图中，在实体和联系的连线上标○表示是非强制存在；<br>在实体和联系的连线上加一条垂直线表示强制存在；<br>如果在连线上既没有标○也没有加垂直线，则表示存在类型未知。<br><img src="https://i.loli.net/2020/06/11/5YOa8mkorsGWALJ.png" alt="联系的存在性示例"></p><h4 id="递归联系"><a href="#递归联系" class="headerlink" title="递归联系"></a>递归联系</h4><p>指同一实体的实例之间的联系。<br>即：实体中的一个实例只与同一实体中的另一个实例相互关联。<br>示例：<br><img src="https://i.loli.net/2020/06/11/WYdZINrED7Bxh4U.png" alt="递归联系示例"><br>参与联系的每一个实例都有特定的角色。<br>联系的角色名确定了每个参与者的功能。</p><h4 id="二元联系"><a href="#二元联系" class="headerlink" title="二元联系"></a>二元联系</h4><p>指两个实体之间的关联。如：<br>    1.部门和职工<br>    2.班和学生<br>    3.学生和课程<br>是最常见的联系。<br><img src="https://i.loli.net/2020/06/11/WdSiAwX45g7UZIx.png" alt="二元联系示例"></p><p>三种基本二元关系示例<br><img src="https://i.loli.net/2020/06/11/YdONjFBbcnho3w8.png" alt="三种基本二元关系示例"></p><h4 id="三元联系"><a href="#三元联系" class="headerlink" title="三元联系"></a>三元联系</h4><p>指三个实体之间的关联。<br>其联系的度为3。<br>用一个与三个实体相连接的菱形表示。<br><img src="https://i.loli.net/2020/06/11/lPMridU3efvhg4G.png" alt="三元联系示例"></p><h4 id="n-元联系"><a href="#n-元联系" class="headerlink" title="n-元联系"></a>n-元联系</h4><p>用具有n个连接的菱形表示，每个连接对应一个实体。<br><img src="https://i.loli.net/2020/06/11/8Nz67CSri4k9HAB.png" alt="n-元联系示例"></p><h4 id="联系标识符综合示例"><a href="#联系标识符综合示例" class="headerlink" title="联系标识符综合示例"></a>联系标识符综合示例</h4><p><img src="https://i.loli.net/2020/06/11/hwu4ykidxcnvm6g.png" alt="联系标识符综合示例"></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>联系通常采用特定约束来限制联系集合中的实体组合。<br>约束要反映现实世界中对联系的限定。如:<br>    “部门”要求每个部门必须有一个职工<br>    “职工”中的每个人必须有一种技能。<br>约束的主要类型：<br>    <strong>多样性约束</strong><br>    <strong>基数约束</strong><br>    <strong>参与约束</strong></p><h4 id="多样性约束"><a href="#多样性约束" class="headerlink" title="多样性约束"></a>多样性约束</h4><p><strong>多样性</strong>指一个实体所包含的每个实例都通过某种联系与另一个实体的同一实例相关联。<br>它约束了实体相关联的方式。<br>是由企业或用户确立的原则或商业规则的一种表示。</p><h4 id="基数约束"><a href="#基数约束" class="headerlink" title="基数约束"></a>基数约束</h4><p>指定了一个实体中的实例与另一个实体中的每个实例相关联的数目。<br>有<strong>最大基数约束</strong>和<strong>最小基数约束</strong>两种。<br>        最小基数约束指一个实体中的实例与另一个实体中的每个实例相关联的最小数目。<br>        最大基数约束指一个实体中的实例与另一个实体中的每个实例相关联的最大数目。<br>例，设一名职工只管理一个部门，一个部门只由一名职工管理，则“职工”和“部门”之间的基数约束都是1。</p><h4 id="联系的基数约束与参与约束示例"><a href="#联系的基数约束与参与约束示例" class="headerlink" title="联系的基数约束与参与约束示例"></a>联系的基数约束与参与约束示例</h4><p><img src="https://i.loli.net/2020/06/11/RqDwjtSLUJdHrGi.png" alt="示例"></p><h4 id="排除约束"><a href="#排除约束" class="headerlink" title="排除约束"></a>排除约束</h4><p>在排除约束中，对多个关系的通常或默认的处理是包含OR。<br>OR允许某个实体或全部实体都参与。<br>在有些情况下，排除约束（不相交或不包含OR）可能会影响多个关系，它允许在几个实体中最多只有一个实体实例参与到只有一个根实体的联系中。</p><p>排除约束示例<br><img src="https://i.loli.net/2020/06/11/zmDUo9iLkbsVCFl.png" alt="排除约束示例"><br>“工作任务”可以分配到“外部项目”中或者是“内部项目”中，但不能同时分配到这两个实体中。</p><h3 id="E-R图符号"><a href="#E-R图符号" class="headerlink" title="E-R图符号"></a>E-R图符号</h3><p><img src="https://i.loli.net/2020/06/11/sUEHIZ7PSBljh18.png" alt="E-R图符号小结"></p><h1 id="关系规范化理论（大题）"><a href="#关系规范化理论（大题）" class="headerlink" title="关系规范化理论（大题）"></a>关系规范化理论（大题）</h1><p>数据库设计是数据库应用领域中的主要研究课题，其主要任务是创建满足用户需求且性能良好的数据库模式。<br>关系数据库规范化理论是指导数据库设计的一个理论指南。</p><h2 id="关系模式设计的问题"><a href="#关系模式设计的问题" class="headerlink" title="关系模式设计的问题"></a>关系模式设计的问题</h2><p>有关系模式：<br>$$<br>S-L-C(Sno,Sname,Ssex,Sdept,SLOC,Cno,Grade)<br>$$<br>其中各属性分别为：学号、姓名、性别、学生所在系、学生所住宿舍楼、课程号和考试成绩。<br>假设每个系的学生都住在一栋楼里，（Sno,Cno）为主键<br><img src="https://i.loli.net/2020/06/11/yfNYpRv4oObV7Iq.png" alt="S-L-C数据"></p><p><strong>存在的问题</strong><br>    数据冗余问题<br>    数据更新问题<br>    数据插入问题<br>    数据删除问题</p><p><strong>结论</strong><br>S-L-C关系模式不是一个好的模式。<br>如何改造这个关系模式并克服以上种种问题是关系规范化理论要解决的问题，也是讨论函数依赖的原因。<br>解决方法:模式分解，即把一个关系模式分解成两个或多个关系模式，在分解的过程中消除那些“不良”的函数依赖，从而获得良好的关系模式</p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>定义：设有关系模式R(A1,A2,…,An)，X和Y均为{A1,A2,…,An}的子集，r是R的任一具体关系，t1、t2是r中的任意两个元组；如果由t1[X]=t2[X]可以推导出t1[Y]=t2[Y]，则称<strong>X函数决定Y</strong>，或<strong>Y函数依赖于X</strong>，记为X→Y。 </p><p>数据的语义不仅表现为完整性约束，对关系模式的设计也提出了一定的要求。<br>如何构造一个合适的关系模式，应构造几个关系模式，每个关系模式由哪些属性组成等，都是数据库设计问题，确切地讲是关系数据库的逻辑设计问题。</p><p>省=f(城市)：只要给出一个具体的城市值，就会有唯一一个省值和它对应，<br>如“武汉市”在“湖北省”，这里“城市”是自变量X，“省”是因变量或函数值Y。<br>把X函数决定Y，或Y函数依赖于X表示为：X→Y<br>如果有关系模式R(A1,A2,…,An)，X和Y为{A1,A2,…,An}的子集，则对于关系R中的任意一个X值，都只有一个Y值与之对应，则称X函数决定Y，或Y函数依赖于X。 </p><p>举例<br>例1：对学生关系模式<br>  Student（Sno, Sname, Sdept, Sage）<br>有以下依赖关系：  Sno→Sname, Sno→Sdept,  Sno→Sage<br> 例2：SC（Sno, Cno, Grade）<br>有以下依赖关系：（Sno, Cno）→Grade </p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h2 id="关系模式的分解准则"><a href="#关系模式的分解准则" class="headerlink" title="关系模式的分解准则"></a>关系模式的分解准则</h2><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 数据库原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理复习笔记</title>
      <link href="/2020/06/07/ji-suan-ji-wang-luo-yuan-li-fu-xi-bi-ji/"/>
      <url>/2020/06/07/ji-suan-ji-wang-luo-yuan-li-fu-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>第一章考小题、第五章主要考拥塞控制、第六章名词解释<br>串行通信和并行通信<br>MAC地址那块分清楚单播、广播、多播，及应用场合，什么时候封装MAC帧<br>一定要知道交换表怎么生成<br>第三章把作业弄明白<br>IP协议簇和网络中间设备的区别、IP数据报格式及首部检验和计算、分片、协议字段值的表格记下来<br>子网划分（重要）<br>例题4-4、CIDR（4-27）、ICMP记一下概念<br>第四章（比重50%）：路由转发、分片、RIP和OSPF的实现、<strong>多看看题</strong><br>路由器构成不考，看看就行<br>0压缩怎么实现、多播<br>概念题：VPN、NAT、MPLS<br>接口与网段的关系（4-55）<br>常用协议对应的端口号<br>TCP：为什么要三次握手及握手过程<br>套接字：UDP二元组<br>TCP格式以及概念的意思，可靠传输不是考点<br>填空+</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机网络定义及特点"><a href="#计算机网络定义及特点" class="headerlink" title="计算机网络定义及特点"></a>计算机网络定义及特点</h2><h3 id="网络定义"><a href="#网络定义" class="headerlink" title="网络定义"></a>网络定义</h3><p>泛指把人或物互联在一起的而形成的系统</p><p>网络的逻辑结构（拓扑结构）</p><h3 id="三大类网络"><a href="#三大类网络" class="headerlink" title="三大类网络"></a>三大类网络</h3><p><strong>电信网络</strong>：提供电话、电报及传真等服务</p><p><strong>有线电视网络</strong>：向用户传送各种电视节目</p><p><strong>计算机网络</strong>：使用户能在计算机之间传送数据文件</p><p>发展最快并起到核心作用的是计算机网络</p><p>三网融合指电信网络、有线电视网络融入计算机网络</p><h3 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h3><p>计算机网络也叫网络实体（在逻辑上可以抽象为：链路+结点）</p><p>链路：各种物理传输介质从信源到信宿之间连接的通信线路。</p><p>结点：中间结点（网络设备，如路由器）+边缘结点（端系统、主机、host）</p><p>“网关就是路由器”是错误的说法，能够充当网关的设备不止路由器一种，路由器是最常见的。</p><p>计算机网络的精确定义并未统一<br>较好的定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>多种硬件：计算机、智能手机、智能传感器</p><p>多种应用：数据、语音、视频，以及今后可能出现的各种应用</p><h3 id="计算机网络的特点"><a href="#计算机网络的特点" class="headerlink" title="计算机网络的特点"></a>计算机网络的特点</h3><p>连通性：使上网用户之间都可以交换信息（数据，以及各种音频视频）</p><p>共享：指资源共享， 资源共享的含义是多方面的。可以是信息共享、软件共享，也可以是硬件共享。</p><h2 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h2><h3 id="互联网定义"><a href="#互联网定义" class="headerlink" title="互联网定义"></a>互联网定义</h3><p>互联网，特指 Internet，它起源于美国，是由数量极大的各种计算机网络互连起来而形成的一个互连网络。它采用 TCP/IP 协议族作为通信规则，是一个覆盖全球、实现全球范围内连通性和资源共享的计算机网络。</p><p>互联：不仅可以相互连接 而且还可以实现信息的传递。协议（http，软件概念，硬件+软件）</p><p>互连：相互之间有链路连接（硬件层面）</p><p><img src="https://i.loli.net/2020/06/07/jpJXZ6y1mIVn5U4.png" alt="互联网与互连网的区别"></p><p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网 (internet)，而不是互联网 (Internet)。</p><h3 id="互联网的发展阶段"><a href="#互联网的发展阶段" class="headerlink" title="互联网的发展阶段"></a>互联网的发展阶段</h3><p>第一阶段：从单个网络 ARPANET 向互联网发展的过程</p><p>第二阶段：建成了三级结构的互联网。 三级计算机网络，分为主干网、地区网和校园网（或企业网）。</p><p>第三阶段：逐渐形成了多层次 ISP 结构的互联网，出现了互联网服务提供者 ISP (Internet Service Provider)，根据提供服务的覆盖面积大小以及所拥有的IP地址数目的不同，ISP 也分成为不同层次的 ISP：主干 ISP、地区 ISP和本地ISP。</p><h2 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h2><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><p>由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资                    源共享。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统 (end system)。端系统在功能上可能有很大的差别</p><p>端系统之间通信，即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。简称为“计算机之间通信”。 </p><h3 id="端系统之间的通信方式"><a href="#端系统之间的通信方式" class="headerlink" title="端系统之间的通信方式"></a>端系统之间的通信方式</h3><h4 id="客户-服务器方式（C-S方式）"><a href="#客户-服务器方式（C-S方式）" class="headerlink" title="客户-服务器方式（C/S方式）"></a>客户-服务器方式（C/S方式）</h4><p>即 Client/Server 方式，简称为 C/S 方式。</p><p>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</p><p>客户-服务器方式所描述的是进程之间服务和被服务的关系。</p><p>客户是服务的请求方，服务器是服务的提供方，服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><p>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</p><h4 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h4><p>即 Peer-to-Peer 方式 ，简称为 P2P 方式。</p><p>对等连接是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方，对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又是服务器。</p><p>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行平等的、对等连接通信。</p><p>双方都可以下载对方已经存储在硬盘中的共享文档。 </p><p>对等连接工作方式可支持大量对等用户（如上百万个）同时工作。</p><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</p><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是路由器 (router)。</p><p>路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p><h3 id="典型交换技术"><a href="#典型交换技术" class="headerlink" title="典型交换技术"></a>典型交换技术</h3><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><p>把收到的分组先放入缓存（暂时存储）；</p><p>查找转发表，找出到某个目的地址应从哪个端口转发；</p><p>把分组送到适当的端口转发出去。</p><p>主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组。路由器对分组进行存储转发，最后把分组交付目的主机。</p><p>路由器的每个接口连接一个网络，每个接口都有一个IP地址，所有接口的IP地址肯定是不同的，内部的路由表记录了目标网段和接口的对应关系</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>2 部电话机只需要用 1 对电线直接连接就能够互相通话。</p><p>5 部电话机两两直接相连，需 10 对电线。</p><p>N 部电话机两两直接相连，需 N(N –1)/2 对电线。这种直接连接方法所需要的电线对的数量与电话机数量的平方<br>$$<br>N^2<br>$$<br>成正比。</p><p>当电话机的数量增多时，就要使用交换机来完成全网的交换任务。每一部电话都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间可以很方便地通信。，所采用的交换方式就是电路交换 (circuit switching)。</p><p>电路交换必定是面向连接的，通信前需要事先确定通道，然后为双方预留资源，在通信过程中，该资源不能分配给其他结点，通信结束需要释放资源（释放链路） </p><h5 id="电路交换的特点"><a href="#电路交换的特点" class="headerlink" title="电路交换的特点"></a>电路交换的特点</h5><p>计算机数据具有突发性。</p><p>这导致在传送计算机数据时，通信线路的利用率很低（用来传送数据的时间往往不到 10% 甚至不到 1% ）。</p><h5 id="电路交换的三个阶段"><a href="#电路交换的三个阶段" class="headerlink" title="电路交换的三个阶段"></a>电路交换的三个阶段</h5><p>建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；</p><p>通信：主叫和被叫双方就能互相通电话；</p><p>释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>分组交换则采用存储转发技术，存储转发的对象是分组（数据包）</p><h5 id="分组交换过程"><a href="#分组交换过程" class="headerlink" title="分组交换过程"></a>分组交换过程</h5><p>在发送端，先把较长的报文划分成较短的、固定长度的数据段。</p><p>每一个数据段前面添加上首部构成分组 (packet)。 </p><p>分组交换网以“分组”作为数据传输单元。</p><p>依次把各分组发送到接收端</p><p>接收端收到分组后剥去首部还原成报文。</p><p>最后，在接收端把收到的数据恢复成为原来的报文。</p><p>即封装到解封装的过程</p><p><strong>需要注意的是</strong>：数据的重组必须在目标计算机上完成，不能在中间路由器上完成，因为只有端主机才具备五层协议栈，而路由器只有三层协议栈，不具备解封装的能力</p><h5 id="分组交换的传输单元"><a href="#分组交换的传输单元" class="headerlink" title="分组交换的传输单元"></a>分组交换的传输单元</h5><p>每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。</p><p>分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。</p><p>每个分组在互联网中独立地选择传输路径。</p><p>用这样的存储转发方式，最后分组就能到达最终目的地。</p><h5 id="分组交换的优点"><a href="#分组交换的优点" class="headerlink" title="分组交换的优点"></a>分组交换的优点</h5><table><thead><tr><th><strong>优点</strong></th><th align="center"><strong>所采用的手段</strong></th></tr></thead><tbody><tr><td><strong>高效</strong></td><td align="center">在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。</td></tr><tr><td><strong>灵活</strong></td><td align="center">为每一个分组独立地选择最合适的转发路由。</td></tr><tr><td><strong>迅速</strong></td><td align="center">以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。</td></tr><tr><td><strong>可靠</strong></td><td align="center">保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</td></tr></tbody></table><h5 id="分组交换的问题"><a href="#分组交换的问题" class="headerlink" title="分组交换的问题"></a>分组交换的问题</h5><p>分组在各结点存储转发时需要排队，这就会造成一定的时延。 </p><p>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 </p><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><h4 id="三种交换方式比较"><a href="#三种交换方式比较" class="headerlink" title="三种交换方式比较"></a>三种交换方式比较</h4><p><img src="https://i.loli.net/2020/06/07/y8Z3o4IBpHAg1TL.png" alt="三种交换方式"></p><p>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</p><p>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。</p><p>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</p><p>互联网的核心部分采用了分组交换技术。</p><h2 id="计算机网络在我国的发展（记住CNNIC）"><a href="#计算机网络在我国的发展（记住CNNIC）" class="headerlink" title="计算机网络在我国的发展（记住CNNIC）"></a>计算机网络在我国的发展（记住CNNIC）</h2><p>1980 年，铁道部开始进行计算机联网实验。<br>1989 年 11 月，我国第一个公用分组交换网 CNPAC 建成运行。<br>1994 年 4 月 20 日，我国用 64 kbit/s 专线正式连入互联网，我国被国际上正式承认为接入互联网的国家。<br>1994 年 5 月，中国科学院高能物理研究所设立了我国的第一个万维网服务器。<br>1994 年 9 月，中国公用计算机互联网 CHINANET 正式启动。</p><p>到目前为止，我国陆续建造了基于互联网技术的并能够和互联网互连的多个全国范围的公用计算机网络，其中规模最大的就是下面这五个：<br><strong>中国电信互联网 CHINANET（也就是原来的中国公用计算机互联网）</strong><br><strong>中国联通互联网 UNINET</strong><br><strong>中国移动互联网 CMNET</strong><br><strong>中国教育和科研计算机网 CERNET</strong><br><strong>中国科学技术网 CSTNET</strong></p><p>中国教育和科研计算机网 CERNET (China Education and Research NETwork) 始建于 1994 年，是我国第一个 IPv4 互联网主干网。<br>2004 年 2 月，我国的第一个下一代互联网 CNGI 的主干网 CERNET2 试验网正式开通，并提供服务。<br><strong>中国互联网络信息中心 CNNIC</strong>（记住） (ChiNa Network Information Center) 每年两次公布我国互联网的发展情况。</p><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><p>计算机网络有多种类别。</p><p>典型包括：<br>按照网络的作用范围进行分类<br>按照网络的使用者进行分类<br>用来把用户接入到互联网的网络</p><h4 id="按照网络的作用范围分类"><a href="#按照网络的作用范围分类" class="headerlink" title="按照网络的作用范围分类"></a>按照网络的作用范围分类</h4><p><strong>广域网 WAN</strong> (Wide Area Network)：作用范围通常为几十到几千公里。<br><strong>城域网 MAN</strong> (Metropolitan Area Network)：作用距离约为 5~50 公里。<br><strong>局域网 LAN</strong> (Local Area Network) ：局限在较小的范围（如 1 公里左右）。<br><strong>个人区域网 PAN</strong> (Personal Area Network) ：范围很小，大约在 10 米左右。</p><p>若中央处理机之间的距离非常近（如仅 1 米的数量级甚至更小些），则一般就称之为多处理机系统，而不称它为计算机网络。 </p><h4 id="按照网络的使用者分类"><a href="#按照网络的使用者分类" class="headerlink" title="按照网络的使用者分类"></a>按照网络的使用者分类</h4><p><strong>公用网</strong> (public network) ：按规定交纳费用的人都可以使用的网络。因此也可称为公众网。<br><strong>专用网</strong> (private network) ：为特殊业务工作的需要而建造的网络。</p><p>公用网和专用网都可以提供多种服务。如传送的是计算机数据，则分别是公用计算机网络和专用计算机网络。</p><h4 id="用来把用户接入到互联网的网络"><a href="#用来把用户接入到互联网的网络" class="headerlink" title="用来把用户接入到互联网的网络"></a>用来把用户接入到互联网的网络</h4><p><strong>接入网 AN</strong> (Access Network)，它又称为本地接入网或居民接入网。</p><p>接入网是一类比较特殊的计算机网络，用于将用户接入互联网。</p><p>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。</p><p>接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。</p><p>从覆盖的范围看，很多接入网还是属于局域网。</p><p>从作用上看，接入网只是起到让用户能够与互联网连接的“桥梁”作用。</p><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><p>计算机网络的性能一般是指它的几个重要的性能指标，主要包括：速率、带宽、吞吐率、时延、时延带宽积、往返时间 RTT、利用率</p><h4 id="速率（可能）"><a href="#速率（可能）" class="headerlink" title="速率（可能）"></a>速率（可能）</h4><p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。</p><p>比特（bit）来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。</p><p>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。<br>速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s等。 例如<br>$$<br>4x10^{10}  bit/s<br>$$<br>的数据率就记为 40 Gbit/s。</p><p>速率往往是指额定速率或标称速率，非实际运行速率。  </p><h4 id="带宽（可能）"><a href="#带宽（可能）" class="headerlink" title="带宽（可能）"></a>带宽（可能）</h4><p>两种不同意义：<br>“带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。</p><p>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。    </p><p>在“带宽”的上述两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p><h4 id="吞吐率（可能）"><a href="#吞吐率（可能）" class="headerlink" title="吞吐率（可能）"></a>吞吐率（可能）</h4><p>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量受网络的带宽或网络的额定速率的限制。  </p><h4 id="时延（小计算题）"><a href="#时延（小计算题）" class="headerlink" title="时延（小计算题）"></a>时延（小计算题）</h4><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。<br>有时也称为延迟或迟延。</p><p>数据在网络中经历的总时延就是发送时延、传播时延、处理时延和排队时延之和。<br>$$<br>总时延=发送时延+传播时延+处理时延+排队时延<br>$$<br>必须指出，在总时延中，究竟是哪一种时延占主导地位，必须具体分析。</p><p><img src="https://i.loli.net/2020/06/07/AhtOKCYaQFZ14x2.png" alt="时延从何产生"></p><p>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。<br>提高链路带宽减小了数据的发送时延。 </p><p>以下说法是错误的：<br>“在高速链路（或高带宽链路）上，比特会传送得更快些”。</p><p>网络中的时延由以下几个不同的部分组成：</p><h5 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h5><p>也称为传输时延。<br>发送数据时，数据帧从结点进入到传输媒体所需要的时间。<br>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。<br>$$<br>发送时延=\frac {数据帧长度（bit）}{发送速率（bit/s）}<br>$$</p><h5 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h5><p>电磁波在信道中需要传播一定的距离而花费的时间。<br>发送时延与传播时延有本质上的不同。<br>信号发送速率和信号在信道上的传播速率是完全不同的概念。<br>$$<br>传播时延=\frac {信道长度（米）}{信号在信道上的传播速率（米/秒）}<br>$$</p><h5 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h5><p>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</p><h5 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h5><p>分组在路由器输入输出队列中排队等待处理所经历的时延。<br>排队时延的长短往往取决于网络中当时的通信量。</p><h4 id="时延带宽积（可能）"><a href="#时延带宽积（可能）" class="headerlink" title="时延带宽积（可能）"></a>时延带宽积（可能）</h4><p>链路的时延带宽积又称为以比特为单位的链路长度。 </p><p>时延带宽积 = 传播时延 x 带宽</p><p><img src="https://i.loli.net/2020/06/07/OczWrxvR3I1ACwa.png" alt="时延带宽积"></p><h4 id="往返时间-RTT（可能）"><a href="#往返时间-RTT（可能）" class="headerlink" title="往返时间 RTT（可能）"></a>往返时间 RTT（可能）</h4><p>互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。</p><p>往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。</p><p>在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</p><p>当使用卫星通信时，往返时间 RTT 相对较长，是很重要的一个性能指标。</p><h4 id="利用率（没考过）"><a href="#利用率（没考过）" class="headerlink" title="利用率（没考过）"></a>利用率（没考过）</h4><p>分为<strong>信道利用率</strong>和<strong>网络利用率</strong>。</p><p>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。</p><p>完全空闲的信道的利用率是零。</p><p>网络利用率则是全网络的信道利用率的加权平均值。</p><p>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p><h4 id="时延与网络利用率的关系"><a href="#时延与网络利用率的关系" class="headerlink" title="时延与网络利用率的关系"></a>时延与网络利用率的关系</h4><p>根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。 </p><p>若令<br>$$<br>D_0<br>$$<br>表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0 之间的关系：<br>$$<br>D=\frac {D_0}{1-U}<br>$$<br>其中U是网络利用率，数值在0到1之间</p><p><img src="https://i.loli.net/2020/06/07/gmu8K1boPEOqRG3.png" alt="时延与信道利用率的关系"></p><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><p>开放系统互连参考模型 OSI/RM</p><p>法律上的 (de jure) 国际标准 OSI 并没有得到市场的认可。<br>非国际标准 TCP/IP 却获得了最广泛的应用。TCP/IP 常被称为事实上的 (de facto) 国际标准。</p><h3 id="网络协议-network-protocol"><a href="#网络协议-network-protocol" class="headerlink" title="网络协议 (network protocol)"></a>网络协议 (network protocol)</h3><p>简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。 </p><h4 id="网络协议的三个组成要素-（可能）"><a href="#网络协议的三个组成要素-（可能）" class="headerlink" title="网络协议的三个组成要素 （可能）"></a>网络协议的三个组成要素 （可能）</h4><p><strong>语法</strong>：数据与控制信息的结构或格式 。<br><strong>语义</strong>：需要发出何种控制信息，完成何种动作以及做出何种响应。<br><strong>同步</strong>：事件实现顺序的详细说明。 </p><p>由此可见，网络协议是计算机网络的不可缺少的组成部分。</p><h4 id="协议的两种形式"><a href="#协议的两种形式" class="headerlink" title="协议的两种形式"></a>协议的两种形式</h4><p>一种是使用便于人来阅读和理解的<strong>文字描述</strong>。<br>另一种是使用让计算机能够理解的<strong>程序代码</strong>。</p><p>这两种不同形式的协议都必须能够对网络上信息交换过程做出精确的解释。</p><p><img src="https://i.loli.net/2020/06/07/VunHAQoB1cOsvbU.png" alt="协议"></p><p><img src="https://i.loli.net/2020/06/07/YT4yCXsHWx1StBj.png" alt="协议"></p><p><img src="https://i.loli.net/2020/06/07/ixAXjdVKL6y78IU.png" alt="协议"></p><h3 id="分层的优缺点"><a href="#分层的优缺点" class="headerlink" title="分层的优缺点"></a>分层的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>各层之间是独立的</p><p>灵活性好</p><p>结构上可分割开</p><p>易于实现和维护</p><p>能促进标准化工作</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>降低效率</p><p>有些功能会在不同的层次中重复出现，因而产生了额外开销</p><h3 id="各层的功能"><a href="#各层的功能" class="headerlink" title="各层的功能"></a>各层的功能</h3><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>使相应层次对等方的通信更加可靠。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送端的发送速率必须使接收端来得及接收，不要太快。</p><h4 id="分段和重装"><a href="#分段和重装" class="headerlink" title="分段和重装"></a>分段和重装</h4><p>发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</p><h4 id="复用和分用"><a href="#复用和分用" class="headerlink" title="复用和分用"></a>复用和分用</h4><p>发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</p><h4 id="连接建立和释放"><a href="#连接建立和释放" class="headerlink" title="连接建立和释放"></a>连接建立和释放</h4><p>交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</p><h3 id="五层协议体系结构（重要）"><a href="#五层协议体系结构（重要）" class="headerlink" title="五层协议体系结构（重要）"></a>五层协议体系结构（重要）</h3><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。<br>TCP/IP 是四层体系结构：<strong>应用层、运输层、网际层和网络接口层</strong>。<br>但最下面的网络接口层并没有具体内容。<br>因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。 </p><p><strong>考试时按五层协议体系结构来</strong></p><p><img src="https://i.loli.net/2020/06/07/GoOZvNLFMy5WTSJ.png" alt="三种网络体系结构"></p><p><img src="https://i.loli.net/2020/06/07/ZAWiS4KuXRGzNIM.png" alt="发送数据的过程"></p><p><img src="https://i.loli.net/2020/06/07/wsKbVALdy857Xmg.png" alt="发送数据的过程"></p><p><img src="https://i.loli.net/2020/06/07/Niz1Bk3qvVgXyoI.png" alt="发送数据的过程"></p><p><img src="https://i.loli.net/2020/06/07/kF5CKdMSUxQgtPL.png" alt="发送数据的过程"></p><p><img src="https://i.loli.net/2020/06/07/iZQJf6rEhAqY59o.png" alt="发送数据的过程"></p><p><img src="https://i.loli.net/2020/06/07/C6g4y1kKOoBxusZ.png" alt="发送数据的过程"></p><p>到达主机2后剥去各层首部向上交付数据</p><p><img src="https://i.loli.net/2020/06/07/ut6YUOfAPnkWTs8.png" alt="发送数据的过程"></p><p>OSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDU (Protocol Data Unit)。这个名词现已被许多非 OSI 标准采用。</p><p>任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“<strong>对等层</strong>”(peer layers)之间的通信。</p><p>各层协议实际上就是在各个对等层之间传递数据时的各项规定。</p><h3 id="TCP-IP体系结构（重要）"><a href="#TCP-IP体系结构（重要）" class="headerlink" title="TCP/IP体系结构（重要）"></a>TCP/IP体系结构（重要）</h3><p><img src="https://i.loli.net/2020/06/07/FZqdXrBsSC5what.png" alt="TCP/IP体系结构"></p><p><img src="https://i.loli.net/2020/06/07/nMxKiDpHr6XAl7a.png" alt="TCP/IP体系结构"></p><p><img src="https://i.loli.net/2020/06/07/fJam9FDeVIQTuoZ.png" alt="TCP/IP体系结构"></p><p>分析过程：</p><table><thead><tr><th>三次封装</th><th>二次封装</th><th>一次封装</th><th>Data（应用层数据）</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>一次封装：主要是源端口、目标端口<br>网络层（路由检索，不提供可靠的数据传输，可靠传输是由传输层的TCP提供的）</p><p>二次封装：主要是源IP、目标IP<br>IP数据包，数据包，分组（packet）<br>数据链路层（数据单元是数据帧，frame，差错检验）</p><p>三次封装：主要是源MAC、目标MAC</p><p><strong>需要注意的是</strong>：多次重新封装时源IP和目标IP是永远不变的，而变化的是源MAC和目标MAC</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p><strong>实体</strong> (entity) 表示任何可发送或接收信息的硬件或软件进程。<br><strong>协议</strong>是控制两个对等实体进行通信的规则的集合。<br>在协议的控制下，两个对等实体间的通信使得本层<strong>能够向上一层提供服务</strong>。<br>要实现本层协议，还需要<strong>使用下层所提供的服务</strong>。 </p><p>协议的实现保证了能够向上一层提供服务。<br>本层的服务用户<strong>只能看见服务而无法看见下面的协议</strong>。即下面的协议对上面的服务用户是<strong>透明</strong>的。<br>协议是“<strong>水平的</strong>”，即协议是控制对等实体之间通信的规则。<br>服务是“<strong>垂直的</strong>”，即服务是由下层向上层通过层间接口提供的。<br>上层使用<strong>服务原语</strong>获得下层所提供的服务。</p><p>报文（message）<br>报文段（segment）：应用层数据封装了TCP协议形成的<br>数据报（Datagram）：应用层数据封装了UDP协议形成的</p><h3 id="服务访问点"><a href="#服务访问点" class="headerlink" title="服务访问点"></a>服务访问点</h3><p>同一系统相邻两层的实体进行交互的地方，称为<strong>服务访问点 SAP</strong> (Service Access Point)。<br>服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口。<br>OSI把层与层之间交换的数据的单位称为<strong>服务数据单元 SDU</strong> (Service Data Unit)。<br>SDU 可以与 PDU 不一样，例如，可以是多个 SDU 合成为一个 PDU，也可以是一个 SDU 划分为几个 PDU。<br>$$<br>PDU(N) = SDU(N - 1)\<br>SDU(N) = PDU(N + 1)<br>$$<br><img src="https://i.loli.net/2020/06/07/5KMZ1znRwkuQAtc.png" alt="服务访问点"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。<br>物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。<br>用于物理层的协议也常称为物理层规程 (procedure)。</p><p>通信的本质目的是传送<strong>消息</strong></p><h3 id="物理层的主要任务（特性）"><a href="#物理层的主要任务（特性）" class="headerlink" title="物理层的主要任务（特性）"></a>物理层的主要任务（特性）</h3><p>主要任务：确定与传输媒体的接口的一些特性。</p><p><strong>机械特性</strong> ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。<br><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围。<br><strong>功能特性</strong>：指明某条线上出现的某一电平的电压的意义。<br><strong>过程特性</strong> ：指明对于不同功能的各种可能事件的出现顺序。 </p><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信系统模型"><a href="#数据通信系统模型" class="headerlink" title="数据通信系统模型"></a>数据通信系统模型</h3><p>一个数据通信系统包括三大部分：源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。</p><p><img src="https://i.loli.net/2020/06/07/XySnEA7ambuPBrM.png" alt="数据通信系统模型"></p><h3 id="常用术语（奈氏准则）"><a href="#常用术语（奈氏准则）" class="headerlink" title="常用术语（奈氏准则）"></a>常用术语（奈氏准则）</h3><p><strong>数据</strong> (data) —— 运送消息的实体。<br><strong>信号</strong> (signal) —— 数据的电气的或电磁的表现。<br><strong>模拟信号</strong> (analogous signal) —— 代表消息的参数的取值是连续的。<br><strong>数字信号</strong> (digital signal) —— 代表消息的参数的取值是离散的。<br><strong>码元</strong> (code) —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><p>二进制码元，有两种脉冲变化形式，表示0或1，所以只能携带1bit信息</p><p>四进制码元，有四种不同的脉冲形式，能携带2bit信息</p><p>同理八进制码元可以携带3bit信息</p><p><strong>奈氏准则</strong>，理想信道下码元的最高传输速率是2wBaud，w指的是信道带宽，Baud是码元传输的速率单位。</p><p>如1Baud=1码元/秒。2wBaud具体为每赫兹带宽的理想低通道信道的码元传输的最高速率是2码元/秒。</p><p>例如信道带宽是200Hz，则每秒最多可以传输2*200=400码元，也就是400Baud。</p><p>例如，信道传输速率是64kbps，可以推算出在无干扰情况下的信道带宽是64/2=32kHz。</p><h3 id="常用编码方式（重要）"><a href="#常用编码方式（重要）" class="headerlink" title="常用编码方式（重要）"></a>常用编码方式（重要）</h3><p><strong>不归零制</strong>（NRZ）：正电平代表 1，负电平代表 0。<br><strong>归零制</strong>（RZ）：正脉冲代表 1，负脉冲代表 0。<br><strong>反向不归零编码（NRZI）</strong>：信号电平翻转表示0，信号电平不变表示1，判断信号相较于上一个状态是否反转。<br><strong>曼彻斯特编码</strong>：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。<br><strong>差分曼彻斯特编码</strong>：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。<br><strong>曼彻斯特编码缺点</strong>是：它所占的频带宽度比原始的基带信号增加了一倍。</p><p><img src="https://i.loli.net/2020/06/07/ur5TNZtQacHOhxM.png" alt="常见编码方式"></p><p>反向不归零编码表示00100010(B)，则信号波形如下图所示：</p><p><img src="https://i.loli.net/2020/06/07/gRQy496Cn3kdpzB.png" alt="NRZI编码"></p><p><strong>从信号波形中来看</strong>，曼彻斯特 (Manchester) 编码和差分曼彻斯特编码产生的信号频率比不归零制高。<br><strong>从自同步能力来看</strong>，不归零制不能从信号波形本身中提取信号时钟频率（这叫做没有自同步能力），<strong>而曼彻斯特编码和差分曼彻斯特编码具有自同步能力。</strong></p><h3 id="信道基本概念"><a href="#信道基本概念" class="headerlink" title="信道基本概念"></a>信道基本概念</h3><p>*<em>信道 *</em>—— 一般用来表示向某一个方向传送信息的媒体。</p><p><strong>单向通信</strong>（单工通信）——只能有一个方向的通信而没有反方向的交互，广播和电视<br><strong>双向交替通信</strong>（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)，HUB（集线器）<br><strong>双向同时通信</strong>（全双工通信）——通信的双方可以同时发送和接收信息。 路由器</p><p><strong>基带信号（即基本频带信号）</strong>—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。<br>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>(modulation)。 </p><p><strong>调制</strong>分为两大类：<br><strong>基带调制</strong>：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。<br><strong>带通调制</strong>：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道）。<br><strong>带通信号</strong>：经过载波调制后的信号。</p><p>最基本的<strong>二元制调制</strong>方法有以下几种：<br><strong>调幅(AM)</strong>：载波的振幅随基带数字信号而变化。<br><strong>调频(FM)</strong>：载波的频率随基带数字信号而变化。<br><strong>调相(PM)</strong> ：载波的初始相位随基带数字信号而变化。 </p><p><img src="https://i.loli.net/2020/06/07/FCQlPOLI1BXfV67.png" alt="带通调制方法"></p><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：<br><strong>信道能够通过的频率范围</strong><br><strong>信噪比</strong></p><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</p><p>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><h4 id="信噪比（香农公式，计算题）"><a href="#信噪比（香农公式，计算题）" class="headerlink" title="信噪比（香农公式，计算题）"></a>信噪比（香农公式，计算题）</h4><p>噪声存在于所有的电子设备和通信信道中。<br>噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误。<br>但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。</p><p>信噪比就是信号的平均功率和噪声的平均功率之比。常记为S/N，并用分贝 (dB) 作为度量单位。即：<br>$$<br>信噪比(dB) = 10 log_{10}(S/N ) (dB)<br>$$<br>例如，当S/N=10时，信噪比为10dB，而当S/N=1000时，信噪比为30dB。 </p><p>传统的电话线路的带宽是3.1KHz（人耳能够识别的频率范围20-16000Hz，电话线路只保留300-3400Hz范围内的声音信号就能听清）电话线路的信噪比是30dB，求传统电话线路的极限传输速率是多少？</p><p><img src="https://i.loli.net/2020/06/07/h2Uw53DeTouPIrY.png" alt="香农公式运用"></p><p>1984年，香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（<strong>香农公式</strong>）。<br>信道的极限信息传输速率 C 可表达为：<br>$$<br>C = W log_2(1+S/N)    (bit/s)<br>$$<br>其中：W 为信道的带宽（以 Hz 为单位）<br>            S 为信道内所传信号的平均功率；<br>            N 为信道内部的高斯噪声功率。 </p><p>香农公式表明：<br>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。<br>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。<br>若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。<br>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 </p><p>需要注意的是：<br>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。<br>这就是：用编码的方法让每一个码元携带更多比特的信息量。 </p><h3 id="正交振幅调制QAM（应该不考）"><a href="#正交振幅调制QAM（应该不考）" class="headerlink" title="正交振幅调制QAM（应该不考）"></a>正交振幅调制QAM（应该不考）</h3><p>正交振幅调制 QAM (Quadrature Amplitude Modulation)<br>为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。</p><p>例如：<br>可供选择的相位有 12 种，而对于每一种相位有 1 或 2 种振幅可供选择。总共有 16 种组合，即 16 个码元。<br>由于 4 bit 编码共有 16 种不同的组合，因此这 16 个点中的每个点可对应于一种 4 bit 的编码。数据传输率可提高 4 倍。</p><p>不是码元越多越好。若每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难，出错率增加。  </p><h2 id="物理层的传输媒体（考概念，区分是否导引）"><a href="#物理层的传输媒体（考概念，区分是否导引）" class="headerlink" title="物理层的传输媒体（考概念，区分是否导引）"></a>物理层的传输媒体（考概念，区分是否导引）</h2><p><strong>传输媒体也称为传输介质或传输媒介</strong>，它就是数据传输系统中在发送器和接收器之间的物理通路。<br>传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。<br><strong>在导引型传输媒体中</strong>，电磁波被导引沿着固体媒体（铜线或光纤）传播。<br><strong>非导引型传输媒体就是指自由空间</strong>。在非导引型传输媒体中，电磁波的传输常称为无线传输。</p><p><img src="https://i.loli.net/2020/06/07/1X6B5MHRuQcdaCl.png" alt="频谱图"></p><h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p>网线（RJ45）<br>电话线（RJ11）</p><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>最常用的传输媒体。<br>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。<br><strong>屏蔽双绞线 STP (Shielded Twisted Pair)</strong>：带金属屏蔽层<br>*<em>无屏蔽双绞线 UTP (Unshielded Twisted Pair) *</em></p><p><img src="https://i.loli.net/2020/06/07/Io7vhk4e6cyijqW.png" alt="双绞线示意图"></p><p>双绞线线序：</p><p>1.<strong>两端线序相同</strong>，用于不同设备，比如一端连接主机，另一端连接交换机或集线器<br>2.<strong>两端线序不同</strong>，如一端是568A，另一端是568B，用于连接两端相同类型的设备，直接将两台计算机通过网线相连</p><p>双绞线标准：（不考）</p><p>1991 年，美国电子工业协会 EIA 和电信行业协会联合发布了一个用于室内传送数据的无屏蔽双绞线和屏蔽双绞线的标准 EIA/TIA-568。<br>1995 年将布线标准更新为 EIA/TIA-568-A。<br>此标准规定了 5 个种类的 UTP 标准（从 1 类线到 5 类线）。<br>对传送数据来说，现在最常用的 UTP 是5类线（Category 5 或 CAT5）。</p><table><thead><tr><th><strong>绞合线类别</strong></th><th><strong>带宽</strong></th><th><strong>线缆特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>3</strong></td><td><strong>16 MHz</strong></td><td><strong>2 对 4 芯双绞线</strong></td><td><strong>模拟电话；曾用于传统</strong>以太网（10 Mbit/s）</td></tr><tr><td><strong>4</strong></td><td><strong>20 MHz</strong></td><td><strong>4 对 8 芯双绞线</strong></td><td><strong>曾用于令牌局域网</strong></td></tr><tr><td><strong>5</strong></td><td><strong>100MHz</strong></td><td><strong>与 4 类相比增加了绞合度</strong></td><td><strong>传输速率不超过100Mbit/s</strong> 的<strong>应用</strong></td></tr><tr><td><strong>5E</strong> (超5类)</td><td><strong>125MHz</strong></td><td><strong>与 5 类相比衰减更小</strong></td><td><strong>传输速率不超过1 Gbit/s 的应用</strong></td></tr><tr><td><strong>6</strong></td><td><strong>250MHz</strong></td><td><strong>与 5 类相比改善了串扰等性能</strong></td><td><strong>传输速率</strong>高于<strong>1</strong> <strong>Gbit</strong>/s <strong>的</strong>应用</td></tr><tr><td><strong>7</strong></td><td><strong>600MHz</strong></td><td><strong>使用屏蔽双绞线</strong></td><td><strong>传输速率高于 10 Gbit</strong>/s的<strong>应用</strong></td></tr></tbody></table><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。<br>同轴电缆的带宽取决于电缆的质量。<br><strong>50 Ω 同轴电缆 —— LAN / 数字传输常用</strong><br><strong>75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用</strong></p><p><img src="https://i.loli.net/2020/06/07/XrtWbZ613zVOl7A.png" alt="同轴电缆结构图"></p><h4 id="光缆（不重要）"><a href="#光缆（不重要）" class="headerlink" title="光缆（不重要）"></a>光缆（不重要）</h4><p>光纤是光纤通信的传输媒体。<br>由于可见光的频率非常高，约为 10^8 MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</p><p><img src="https://i.loli.net/2020/06/07/uTQMSYP715EXvO9.png" alt="光纤原理图"></p><p>当光线从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，光也就沿着光纤传输下去。</p><p><img src="https://i.loli.net/2020/06/07/Qh7bC61OZnNsjUH.png" alt="光纤原理图"></p><p>只要从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就可产生全反射。</p><p><strong>多模光纤</strong><br>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。</p><p><strong>单模光纤</strong><br>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。</p><p><img src="https://i.loli.net/2020/06/07/FXvGOV43TSQUbwE.png" alt="多模光纤与单模光纤比较"></p><p>光纤通信中使用的光波的波段：<br>常用的三个波段的中心分别位于 850 nm, 1300 nm 和 1550 nm。<br>所有这三个波段都具有 25000~30000 GHz 的带宽，可见光纤的通信容量非常大。</p><p>光纤的优点：<br>1.通信容量非常大。<br>2.传输损耗小，中继距离长。<br>3.抗雷电和电磁干扰性能好。<br>4.无串音干扰，保密性好。<br>5.体积小，重量轻。</p><h3 id="非导引型传输媒体（不重要）"><a href="#非导引型传输媒体（不重要）" class="headerlink" title="非导引型传输媒体（不重要）"></a>非导引型传输媒体（不重要）</h3><p>将自由空间称为“非导引型传输媒体”。<br>无线传输所使用的频段很广。<br>短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。<br>微波在空间主要是直线传播。</p><p>传统微波通信有两种方式：<br><strong>1.地面微波接力通信</strong><br><strong>2.卫星通信</strong></p><p><img src="https://i.loli.net/2020/06/07/V6niYzTxOWC8FLq.png" alt="无线局域网使用的ISM频段"></p><h2 id="信道复用技术（重要）"><a href="#信道复用技术（重要）" class="headerlink" title="信道复用技术（重要）"></a>信道复用技术（重要）</h2><p><strong>复用</strong> (multiplexing) 是通信技术中的基本概念。<br>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="https://i.loli.net/2020/06/07/TIhselBAmnq2X1Q.png" alt="信道复用示意图"></p><h3 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h3><p>Frequency Division Multiplexing<br>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<br><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 </p><h3 id="时分复用TDM（主要考）"><a href="#时分复用TDM（主要考）" class="headerlink" title="时分复用TDM（主要考）"></a>时分复用TDM（主要考）</h3><p>Time Division Multiplexing<br><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧</strong>（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。<br>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。<br>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。<br><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></p><p><img src="https://i.loli.net/2020/06/07/N8tTO5GzHMLvqyu.png" alt="时分复用示意图"></p><p>进行多路复用有两种标准，一种欧洲标准（即我国标准）E1，另一种是北美标准T1</p><p>E1：每一个TDM帧分为32个等长的时隙，CH0——CH31，其中CH0用于帧同步，CH16用于传输信令，所以话路就是CH1——CH15和CH17——CH31，一共30个话路，因为使用8bit编码，所以每个时隙传输8bit，所以8<em>32=256bit，又因为每一个TDM帧的周期是125us，所以每秒可以传输8000个TDM帧（求倒数），每帧有32个时隙，每个时隙都采用8bit编码，那么1秒内共传出8\</em>32*8000=2048*10^3=2.048*10^6=2.048Mbps(个二进制位)（第一代宽带ADSL为什么是2M的原因）</p><p>1M的宽带是T1标准，T1和E1用的都是电话线路，所以T1每秒也传输8000个TDM帧，但T1只有24个话路，每个话路也是8bit编码，另外增加了一个帧同步码（只有1bit），所以T1每帧8*24+1=193bit，由于每秒传输8000个TDM帧，所以1秒内共传出193*8000=1.544Mbps</p><p>时分复用可能会造成线路资源的浪费<br>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p><p><img src="https://i.loli.net/2020/06/07/wSbJBf9lZcAtmUM.png" alt="时分复用造成资源浪费"></p><h3 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h3><p>Statistic TDM，统计时分复用是一种移步时分复用，而普通的时分复用是同步时分复用<br><img src="https://i.loli.net/2020/06/07/MdvJtlY41DorL9H.png" alt="统计时分复用工作原理"></p><p>已知电话线路的最高频率是3.4KHz，采样定理要求采样频率必须是最高频率的2倍以上，也就是必须&gt;=2<em>3.4=6.8KHz，所以采用的是8KHz作为采样频率，所以采样周期就是1/8000s=125us，电话线路采用8bit编码，1路模拟信号将转换成8000/s个脉冲信号，所以信号的传输速率=8000\</em>8=64kbps</p><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>Wavelength Division Multiplexing，波分复用主要针对的是广播信号，按照波长进行复用，也称为光的频分复用，在一根光纤上传输的多路复用信号的波长是接近的<br><img src="https://i.loli.net/2020/06/07/7xSEj5PzGhHiJm4.png" alt="波分复用"></p><h3 id="码分复用CDM（必考）"><a href="#码分复用CDM（必考）" class="headerlink" title="码分复用CDM（必考）"></a>码分复用CDM（必考）</h3><p>Code Division Multiplexing<br>常用的名词是<strong>码分多址 **CDMA (Code Division Multiple Access)。<br>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br>这种系统发送的信号有很强的抗干扰能力，其频谱类似于</strong>白噪声<strong>，不易被敌人发现。<br>**白噪声</strong>：信号在各频率上的功率几乎一样的，功率密度在整个频域是个常数，所有频率具有相同的能量密度</p><h4 id="码片序列"><a href="#码片序列" class="headerlink" title="码片序列"></a>码片序列</h4><p>每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。<br>每个站被指派一个唯一的 m bit 码片序列。<br>        <strong>1.如发送比特 1，则发送自己的 m bit 码片序列。</strong><br>        <strong>2.如发送比特 0，则发送该码片序列的二进制反码。 **<br>例如，S 站的 8 bit 码片序列是 00011011。<br>        **1.发送比特 1 时，就发送序列 00011011，</strong><br>        <strong>2.发送比特 0 时，就发送序列 11100100。</strong><br>S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) </p><p><strong>考试时如果给定的是码片序列，需要转换成向量的形式，1对应+1，0对应-1</strong></p><p><em>例如：00011011=（-1，-1，-1，+1，+1，-1，+1，+1）</em></p><p><strong>要求：每个站点的码片序列不同，而且需要相互正交（向量正交）。</strong></p><p>任何一个码片向量和该码片自己做向量正交运算</p><p>接受到的永远是各个站点发送的信号总和</p><p>接收方如果想知道某个站点具体发送什么数据，就必须先要得到该站点的码片序列，然后用该站点的码片序列与信号和做内积</p><h4 id="码片序列实现扩频"><a href="#码片序列实现扩频" class="headerlink" title="码片序列实现扩频"></a>码片序列实现扩频</h4><p>假定S站要发送信息的数据率为 b bit/s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit/s，同时 S 站所占用的频带宽度也提高到原来数值的 m 倍。<br>这种通信方式是<strong>扩频</strong>(spread spectrum)通信中的一种。<br>扩频通信通常有两大类：<br>        1.一种是<strong>直接序列扩频DSSS</strong> (Direct Sequence Spread Spectrum)，如上面讲的使用码片序列就是这一类。<br>        2.另一种是<strong>跳频扩频FHSS</strong> (Frequency Hopping Spread Spectrum)。</p><h4 id="CDMA-的重要特点"><a href="#CDMA-的重要特点" class="headerlink" title="CDMA 的重要特点"></a>CDMA 的重要特点</h4><p>每个站分配的码片序列不仅<strong>必须各不相同</strong>，并且还<strong>必须互相正交</strong> (orthogonal)。<br>在实用的系统中是使用<strong>伪随机码序列</strong>。 </p><h4 id="码片序列的正交关系"><a href="#码片序列的正交关系" class="headerlink" title="码片序列的正交关系"></a>码片序列的正交关系</h4><p>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。<br>两个不同站的码片序列正交，就是向量 S 和T 的<strong>规格化内积</strong> (inner product) 等于 0： </p><p><img src="https://i.loli.net/2020/06/07/5pqav7NSJRnei68.png" alt="码片序列的正交公式"></p><p>正交关系的另一个重要特性 ：</p><p>任何一个码片向量和该码片向量自己的规格化内积都是 1 。</p><p><img src="https://i.loli.net/2020/06/07/G1mcETXKyedH4Yf.png" alt="规格化内积公式"></p><p>一个码片向量和该码片反码的向量的规格化内积值是 –1。 </p><p><img src="https://i.loli.net/2020/06/07/2QGngDXzftE1TlS.png" alt="CDMA工作原理"></p><h2 id="数字传输系统（不重要）"><a href="#数字传输系统（不重要）" class="headerlink" title="数字传输系统（不重要）"></a>数字传输系统（不重要）</h2><p>在早期电话网中，从市话局到用户电话机的用户线是采用最廉价的双绞线电缆，而长途干线采用的是频分复用 FDM 的模拟传输方式。<br><strong>与模拟通信相比，数字通信无论是在传输质量上还是经济上都有明显的优势。</strong><br>目前，长途干线大都采用时分复用 PCM 的数字传输方式。<br>*<em>脉码调制 PCM *</em>体制最初是为了在电话局之间的中继线上传送多路的电话。</p><p>由于历史上的原因，PCM 有两个互不兼容的国际标准：<br>        1.北美的 24 路 PCM（简称为 T1）<br>        2.欧洲的 30 路 PCM（简称为 E1）<br>我国采用的是欧洲的 E1 标准。<br>E1 的速率是 2.048 Mbit/s，而 T1 的速率是 1.544 Mbit/s。<br>当需要有更高的数据率时，可采用复用的方法。 </p><h4 id="旧数字传输系统的缺点"><a href="#旧数字传输系统的缺点" class="headerlink" title="旧数字传输系统的缺点"></a>旧数字传输系统的缺点</h4><p>最主要的是以下两个方面：<br><strong>速率标准不统一</strong><br>        1.如果不对高次群的数字传输速率进行标准化，国际范围的<strong>基于光纤高速数据传输就很难实现</strong>。<br><strong>不是同步传输</strong><br>        1.在过去相当长的时间，为了节约经费，各国的数字网主要采用准同步方式。<br>        2.当数据传输的速率很高时，收发双方的时钟同步就成为很大的问题。 </p><h4 id="同步光纤网-SONET"><a href="#同步光纤网-SONET" class="headerlink" title="同步光纤网 SONET"></a>同步光纤网 SONET</h4><p><strong>同步光纤网 **SONET (Synchronous Optical Network)  的各级时钟都来自一个非常精确的主时钟。<br>SONET 为光纤传输系统定义了同步传输的线路速率等级结构<br>        1.对电信信号称为第 1 级</strong>同步传送信号** STS-1 (Synchronous Transport Signal)，其传输速率是 51.84 Mbit/s。<br>        2.对光信号则称为第 1 级<strong>光载波</strong> OC-1 (OC 表示Optical Carrier)。<br>现已定义了从 51.84 Mbit/s (即OC-1) 一直到 9953.280 Mbit/s (即 OC-192/STS-192) 的标准。 </p><h4 id="同步数字系列-SDH"><a href="#同步数字系列-SDH" class="headerlink" title="同步数字系列 SDH"></a>同步数字系列 SDH</h4><p>ITU-T 以美国标准 SONET 为基础，制订出国际标准<strong>同步数字系列</strong> SDH (Synchronous Digital Hierarchy)。<br>一般可认为 SDH 与 SONET 是同义词。<br><strong>其主要不同点是</strong>:SDH的基本速率为155.52 Mbit/s,称为第 1 级<strong>同步传递模块</strong> (Synchronous Transfer Module),即 STM-1，相当于 SONET 体系中的 OC-3 速率。 </p><p><img src="https://i.loli.net/2020/06/07/9wPOKBYfE3iyVsL.png" alt="同步数字系列"></p><h4 id="SONET-SDH-标准的意义"><a href="#SONET-SDH-标准的意义" class="headerlink" title="SONET / SDH 标准的意义"></a>SONET / SDH 标准的意义</h4><p>使不同的数字传输体制在 STM-1 等级上获得了统一。<br>第一次真正实现了数字传输体制上的世界性标准。<br>已成为公认的新一代理想的传输网体制。<br>SDH 标准也适合于微波和卫星传输的技术体制。</p><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>用户要连接到互联网，必须先连接到某个ISP。<br>在互联网的发展初期，用户都是利用电话的用户线通过调制解调器连接到ISP的，电话用户线接入到互联网的速率最高仅达到56 kbit/s。<br>美国联邦通信委员会FCC原来认为只要双向速率之和超过200 kbit/s 就是宽带。但 2015 年重新定义为：<br>                                                                宽带下行速率要达到 25 Mbit/s<br>                                                                宽带上行速率要达到 3 Mbit/s</p><p>从宽带接入的媒体来看，可以划分为两大类：<br>        1.有线宽带接入<br>        2.无线宽带接入</p><h3 id="ADSL技术（记一下概念）"><a href="#ADSL技术（记一下概念）" class="headerlink" title="ADSL技术（记一下概念）"></a>ADSL技术（记一下概念）</h3><p><strong>非对称数字用户线 ADSL</strong> (Asymmetric Digital Subscriber Line) 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。<br>标准模拟电话信号的频带被限制在 300<del>3400 Hz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。<br>ADSL 技术就把 0</del>4 kHz 低端频谱留给传统电话使用，而<strong>把原来没有被利用的高端频谱留给用户上网使用</strong>。<br>DSL 就是<strong>数字用户线</strong> (Digital Subscriber Line) 的缩写。</p><h4 id="DSL-的几种类型"><a href="#DSL-的几种类型" class="headerlink" title="DSL 的几种类型"></a>DSL 的几种类型</h4><p><strong>ADSL *<em>(Asymmetric Digital Subscriber Line)：非对称数字用户线<br>*</em>HDSL</strong> (High speed DSL)：高速数字用户线<br><strong>SDSL *<em>(Single-line DSL)：1 对线的数字用户线<br>*</em>VDSL *<em>(Very high speed DSL)：甚高速数字用户线<br>*</em>DSL *<em>(Digital Subscriber Line) ：数字用户线<br>*</em>RADSL</strong> (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率）</p><h4 id="ADSL-的传输距离"><a href="#ADSL-的传输距离" class="headerlink" title="ADSL 的传输距离"></a>ADSL 的传输距离</h4><p><strong>ADSL 的传输距离</strong>取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。<br>ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。<br>例如：<br>        1.0.5 毫米线径的用户线，传输速率为 1.5~2.0 Mbit/s 时可传送5.5公里，但当传输速率提高到 6.1 Mbit/s 时，传输距离就缩短为 3.7 公里。<br>        2.如果把用户线的线径减小到 0.4 毫米，那么在 6.1 Mbit/s 的传输速率下就只能传送 2.7 公里。</p><h4 id="ADSL-的特点"><a href="#ADSL-的特点" class="headerlink" title="ADSL 的特点"></a>ADSL 的特点</h4><p>上行和下行带宽做成不对称的。<br>上行指从用户到 ISP，而下行指从 ISP 到用户。<br>ADSL 在用户线（铜线）的两端各安装一个 <strong>ADSL 调制解调器</strong>。<br>我国目前采用的方案是<strong>离散多音调 DMT **(Discrete Multi-Tone)调制技术。<br>这里的“多音调”就是“</strong>多载波<strong>”或“</strong>多子信道**”的意思。</p><h4 id="ADSL-的数据率"><a href="#ADSL-的数据率" class="headerlink" title="ADSL 的数据率"></a>ADSL 的数据率</h4><p>由于用户线的具体条件往往相差很大（距离、线径、受到相邻用户线的干扰程度等都不同），<strong>因此 ADSL 采用自适应调制技术使用户线能够传送尽可能高的数据率</strong>。<br>当 ADSL 启动时，用户线两端的 ADSL 调制解调器就测试可用的频率、各子信道受到的干扰情况，以及在每一个频率上测试信号的传输质量。<br><strong>ADSL 不能保证固定的数据率</strong>。对于质量很差的用户线甚至无法开通 ADSL。<br>通常下行数据率在32 kbit/s到6.4 Mbit/s之间，而上行数据率在 32 kbit/s 到 640 kbit/s 之间。</p><h4 id="ADSL-的组成"><a href="#ADSL-的组成" class="headerlink" title="ADSL 的组成"></a>ADSL 的组成</h4><p><img src="https://i.loli.net/2020/06/07/TfYKIh7iZpzdAUH.png" alt="ADSL组成"></p><h4 id="第二代ADSL"><a href="#第二代ADSL" class="headerlink" title="第二代ADSL"></a>第二代ADSL</h4><p>包括 ADSL2（G.992.3 和 G.992.4）和 ADSL2+（G.992.5）。<br>通过提高调制效率得到了<strong>更高的数据率</strong>。<br>        1.ADSL2 要求至少应支持下行 8 Mbit/s、上行 800 kbit/s的速率。<br>        2.ADSL2+ 则将频谱范围从 1.1 MHz 扩展至 2.2 MHz，下行速率可达 16 Mbit/s（最大传输速率可达 25 Mbit/s），而上行速率可达 800 kbit/s。<br>采用了<strong>无缝速率自适应技术</strong> SRA (Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。<br>改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义。</p><h4 id="DMT-技术"><a href="#DMT-技术" class="headerlink" title="DMT 技术"></a>DMT 技术</h4><p>DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。<br>每个子信道占据 4 kHz 带宽（严格讲是 4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</p><p>DMT 技术的频谱分布<br><img src="https://i.loli.net/2020/06/07/1keyJO8iRDuQZfT.png" alt="DMT 技术的频谱分布 "></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="光纤同轴混合网（HFC网）"><a href="#光纤同轴混合网（HFC网）" class="headerlink" title="光纤同轴混合网（HFC网）"></a>光纤同轴混合网（HFC网）</h3><p>HFC (Hybrid Fiber Coax) 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。<br>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。<br>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。<br><strong>HFC 网对 CATV 网进行了改造</strong>。 </p><p>HFC 网的主干线路采用光纤<br>HFC 网将原 CATV 网中的同轴电缆<strong>主干部分改换为光纤</strong>，并使用<strong>模拟光纤技术</strong>。<br>在模拟光纤中采用<strong>光的振幅调制AM</strong>，这比使用数字光纤更为经济。<br>模拟光纤从<strong>头端</strong>连接到<strong>光纤结点</strong> (fiber node)，即<strong>光分配结点</strong> ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。 </p><p>HFC 网采用结点体系结构<br><img src="https://i.loli.net/2020/06/07/CVc8gYaipoUIJkA.png" alt="HFC 网结构图"></p><p>HFC 网具有双向传输功能，扩展了传输频带<br><img src="https://i.loli.net/2020/06/07/M3pFVqAUJ5hisf9.png" alt="我国HFC网频谱划分"></p><p>每个家庭要安装一个用户接口盒<br><strong>用户接口盒 UIB **(User Interface Box) 要提供</strong>三种连接**，即：<br>        1.使用同轴电缆连接到机顶盒 (set-top box)，然后再连接到用户的电视机。<br>        2.使用双绞线连接到用户的电话机。<br>        3.使用电缆调制解调器连接到用户的计算机。</p><h4 id="电缆调制解调器-Cable-Modem"><a href="#电缆调制解调器-Cable-Modem" class="headerlink" title="电缆调制解调器 (Cable Modem)"></a>电缆调制解调器 (Cable Modem)</h4><p><strong>电缆调制解调器</strong>是为 HFC 网而使用的调制解调器。<br>电缆调制解调器最大的特点就是传输速率高。<br>        1.下行速率一般在 3 ~ 10 Mbit/s之间，最高可达 30 Mbit/s。<br>        2.上行速率一般为 0.2 ~ 2 Mbit/s，最高可达 10 Mbit/s。<br>电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在用户端。 </p><h3 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h3><p>FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。<br>FTTx 表示 Fiber To The…（光纤到…），例如：<br>        1.<strong>光纤到户 FTTH</strong> (Fiber To The Home)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。<br>        2.<strong>光纤到大楼 FTTB</strong> (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。<br>        3.<strong>光纤到路边 FTTC</strong> (Fiber To The Curb)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。</p><p>无源光网络 PON (Passive Optical Network) 的组成<br><img src="https://i.loli.net/2020/06/07/LYNHrbXf8Eduikj.png" alt="无源光网络 PON 的组成 "></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>在进入数据链路层之前，先复习一下计算机网络结构体系，对层次再一次梳理<br>网络中的主机、路由器等都必须实现数据链路层。<br>局域网中的主机、交换机等都必须实现数据链路层</p><p>数据链路层上是数据帧</p><p>网络层上是数据包</p><p>运输层上是报文</p><p><img src="https://i.loli.net/2020/06/07/mguObJQysa7rXK8.png" alt="计算机网络体系结构"></p><p><img src="https://i.loli.net/2020/06/07/tUA67cNLF82ErWf.png" alt="数据链路层"></p><p><img src="https://i.loli.net/2020/06/07/BVKWCtluhS8Zqy3.png" alt="数据链路层"></p><p><img src="https://i.loli.net/2020/06/07/OKsv2qxDXZWBA4U.png" alt="数据链路层作用"></p><p><img src="https://i.loli.net/2020/06/07/3kYbqocsnDxeVzO.png" alt="数据链路层作用"></p><p><img src="https://i.loli.net/2020/06/07/1cwYrVTbN6sfdKp.png" alt="数据链路层使用的信道"></p><h2 id="使用点对点通信的数据链路层"><a href="#使用点对点通信的数据链路层" class="headerlink" title="使用点对点通信的数据链路层"></a>使用点对点通信的数据链路层</h2><h3 id="数据链路与帧（概念）"><a href="#数据链路与帧（概念）" class="headerlink" title="数据链路与帧（概念）"></a>数据链路与帧（概念）</h3><p><strong>链路</strong> (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<br><strong>一条链路只是一条通路的一个组成部分。</strong><br><strong>数据链路 **(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。<br>        1.现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。<br>        2.一般的适配器都包括了数据链路层和物理层这两层的功能。<br>也有人采用另外的术语。这就是把链路分为</strong>物理链路<strong>和</strong>逻辑链路<strong>。<br>**物理链路</strong>就是上面所说的链路。<br><strong>逻辑链路</strong>就是上面的数据链路，是物理链路加上必要的通信协议。<br>早期的数据通信协议曾叫做<strong>通信规程</strong> (procedure)。因此在数据链路层，规程和协议是同义语。</p><p>数据链路层传输的是帧<br><img src="https://i.loli.net/2020/06/07/buosMpfANOhj1Ei.png" alt="数据链路层传送的是帧"></p><p>常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。<br><img src="https://i.loli.net/2020/06/07/nrHmbLhNMcCtj9F.png" alt="数据链路层传输的是帧"><br>数据链路层不必考虑物理层如何实现比特传输的细节。甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。</p><h3 id="三个基本问题（没怎么考）"><a href="#三个基本问题（没怎么考）" class="headerlink" title="三个基本问题（没怎么考）"></a>三个基本问题（没怎么考）</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br>首部和尾部的一个重要作用就是进行帧定界。<br><img src="https://i.loli.net/2020/06/07/PtKQ9DEqnvFL2OJ.png" alt="封装成帧"></p><p>用控制字符进行帧定界的方法</p><p>当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的<strong>帧定界符</strong><br>控制字符SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。<br>另一个控制字符 EOT (End Of Transmission) 表示帧的结束。<br><img src="https://i.loli.net/2020/06/07/3txMja5DbpNzWO7.png" alt="用控制字符进行帧定界的方法"></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。<br><img src="https://i.loli.net/2020/06/07/BDjZitT9PwVI6f1.png" alt="用字节填充解决透明传输"></p><p>解决透明传输问题</p><p><strong>解决方法</strong>：字节填充 (byte stuffing) 或字符填充 (character stuffing)。<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。<br>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。<br>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。<br><img src="https://i.loli.net/2020/06/07/BDjZitT9PwVI6f1.png" alt="用字节填充解决透明传输"></p><p>透明：指某一个实际存在的事物看起来却好像不存在一样。</p><p><em>“在数据链路层透明传送数据”</em>表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。</p><h4 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h4><p>在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。<br><img src="https://i.loli.net/2020/06/07/8cmCZdEQVphB1eS.png" alt="比特错的产生"></p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> BER (Bit Error Rate)。<br>误码率与信噪比有很大的关系。<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。<br>在数据链路层传送的帧中，<strong>广泛</strong>使用了*<em>循环冗余检验 CRC *</em>的检错技术。</p><h5 id="循环冗余校验原理（必考计算题）"><a href="#循环冗余校验原理（必考计算题）" class="headerlink" title="循环冗余校验原理（必考计算题）"></a>循环冗余校验原理（必考计算题）</h5><p>在发送端，先把数据划分为组。假定每组 k 个比特。<br>在每组 M 后面再添加供差错检测用的 n 位<strong>冗余码</strong>，然后一起发送出去。<br><img src="https://i.loli.net/2020/06/07/Y4xSqn85LIeO2Ni.png" alt="循环冗余校验"></p><p><img src="https://i.loli.net/2020/06/07/ZSBT7cNtVWOH5LI.png" alt="循环冗余校验原理说明"></p><h5 id="冗余码计算（必考计算题）"><a href="#冗余码计算（必考计算题）" class="headerlink" title="冗余码计算（必考计算题）"></a>冗余码计算（必考计算题）</h5><p>用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。<br>得到的 (k + n) 位的数<strong>除以</strong>事先选定好的长度为 (n + 1) 位的<strong>除数</strong> P，得出<strong>商</strong>是 Q 而<strong>余数</strong>是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。<br>将余数 R 作为<strong>冗余码</strong>拼接在数据 M 后面，一起发送出去。<br><img src="https://i.loli.net/2020/06/07/GdOXcw5K8neCQr7.png" alt="冗余码计算"></p><p>接收端对收到的每一帧进行 CRC 检验</p><p>​        1.若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。<br>​        2.若余数 R ≠ 0，则判定这个帧有差错，就丢弃。<br>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。<br>只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 </p><p>冗余码的计算举例 </p><p>现在 k = 6, M = 101001。<br>设 n = 3, 除数 P = 1101，<br>被除数是:<br>$$<br>2^nM = 101001000<br>$$<br>模 2 运算的结果是：商 Q = 110101，余数 R = 001。<br>把余数 R 作为冗余码添加在数据 M 的后面发送出去。</p><p>发送的数据是：<br>$$<br>2^nM + R<br>$$<br>即：101001001，共 (k + n) 位。 </p><h5 id="帧检验序列-FCS（必考计算题）"><a href="#帧检验序列-FCS（必考计算题）" class="headerlink" title="帧检验序列 FCS（必考计算题）"></a>帧检验序列 FCS（必考计算题）</h5><p>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。<br>循环冗余检验 CRC 和帧检验序列 FCS <strong>并不等同</strong>。<br>        1.CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。<br>        2.FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 </p><h5 id="关于CRC校验需要注意（必考计算题）"><a href="#关于CRC校验需要注意（必考计算题）" class="headerlink" title="关于CRC校验需要注意（必考计算题）"></a>关于CRC校验需要注意（必考计算题）</h5><p>仅用循环冗余检验 CRC 差错检测技术只能做到<strong>无差错接受 **(accept)。<br>“</strong>无差错接受<strong>”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<br>也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。<br>**单纯使用 CRC 差错检测技术不能实现“无差错传输”或“可靠传输”。</strong><br>应当明确，“<strong>无比特差错</strong>”与“<strong>无传输差错</strong>”是<strong>不同的</strong>概念。<br>在数据链路层使用 CRC 检验，能够实现<strong>无比特差错</strong>的传输，但这还<strong>不是可靠传输</strong>。<br>要做到“无差错传输”（即发送什么就收到什么）就必须再加上确认和重传机制。<br>本章介绍的数据链路层协议都不是可靠传输的协议。</p><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><h3 id="PPP协议的特点（考的少）"><a href="#PPP协议的特点（考的少）" class="headerlink" title="PPP协议的特点（考的少）"></a>PPP协议的特点（考的少）</h3><p>对于点对点的链路，目前使用得最广泛的数据链路层协议是<strong>点对点协议</strong> PPP (Point-to-Point Protocol)。<br>PPP 协议在 1994 年就已成为互联网的正式标准。</p><p><img src="https://i.loli.net/2020/06/07/lwejYpx3hzQ5oaU.png" alt="PPP协议的使用"></p><h4 id="PPP-协议应满足的需求"><a href="#PPP-协议应满足的需求" class="headerlink" title="PPP 协议应满足的需求"></a>PPP 协议应满足的需求</h4><p>简单 —— <strong>这是首要的要求</strong>。<br>封装成帧 —— 必须规定特殊的字符作为帧定界符。<br>透明性 —— 必须保证数据传输的透明性。<br>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。<br>多种类型链路 —— 能够在多种类型的链路上运行。<br>差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。<br>检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态。<br>最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元 MTU 的标准默认值,促进各种实现之间的互操作性。<br>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。<br>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法。</p><h4 id="PPP-协议不需要的功能"><a href="#PPP-协议不需要的功能" class="headerlink" title="PPP 协议不需要的功能"></a>PPP 协议不需要的功能</h4><p>纠错 、流量控制 、序号 、多点线路 、半双工或单工链路 </p><h4 id="PPP-协议的组成"><a href="#PPP-协议的组成" class="headerlink" title="PPP 协议的组成"></a>PPP 协议的组成</h4><p>PPP 协议有三个组成部分：<br>        1.一个将 IP 数据报封装到串行链路的方法。<br>        2.链路控制协议 LCP (Link Control Protocol)。<br>        3.网络控制协议 NCP (Network Control Protocol)。 </p><h3 id="PPP协议的帧格式（不会考）"><a href="#PPP协议的帧格式（不会考）" class="headerlink" title="PPP协议的帧格式（不会考）"></a>PPP协议的帧格式（不会考）</h3><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。<br>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。<br>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。<br>控制字段 C 通常置为 0x03。<br><strong>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</strong></p><p><img src="https://i.loli.net/2020/06/07/gPWXMezAutfjDVr.png" alt="PPP协议的帧格式"></p><h3 id="透明传输问题"><a href="#透明传输问题" class="headerlink" title="透明传输问题"></a>透明传输问题</h3><p>当 PPP 用在异步传输时，就使用一种特殊的<strong>字符填充法</strong>。<br>当 PPP 用在同步传输链路时，协议规定采用硬件来完成<strong>比特填充</strong>（和 HDLC 的做法一样）。  </p><h3 id="字符填充"><a href="#字符填充" class="headerlink" title="字符填充"></a>字符填充</h3><p>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。<br>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。<br>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 </p><p>字符填充法<br><img src="https://i.loli.net/2020/06/08/KBNX3nrIDzF7pqx.png" alt="字符填充法"></p><p>零比特填充<br>PPP 协议用在 SONET/SDH 链路时，使用同步传输（一连串的比特连续传送）。<strong>这时 PPP 协议采用零比特填充方法来实现透明传输。</strong><br>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。<br>接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。</p><p><img src="https://i.loli.net/2020/06/08/w3WrGJ2joAgMqVR.png" alt="零比特填充"></p><p> 不提供使用序号和确认的可靠传输 </p><p>PPP 协议之所以<strong>不使用</strong>序号和确认机制是出于以下的考虑：<br>        1.在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。<br>        2.在因特网环境下，PPP 的信息字段放入的数据是 IP  数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。<br>        3.帧检验序列 FCS 字段可保证无差错接受。</p><h3 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h3><p>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。<br>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。<br>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。<br>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。<br><strong>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</strong></p><p><img src="https://i.loli.net/2020/06/08/NI8laH6QOfDs3BT.png" alt="PPP协议的状态图"></p><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><p>局域网最主要的<strong>特点</strong>是：<br>        1.网络为一个单位所拥有；<br>        2.地理范围和站点数目均有限。<br>局域网具有如下<strong>主要优点</strong>：<br>        1.具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。<br>        2.便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。<br>        3.提高了系统的可靠性、可用性和残存性。</p><p>局域网拓扑结构<br><img src="https://i.loli.net/2020/06/08/TdP1snHgyZkAcij.png" alt="局域网拓扑结构"></p><p>局域网传输媒体<br><img src="https://i.loli.net/2020/06/08/e8dkIoCyuMzmWVc.png" alt="局域网传输媒体"></p><p>共享信道带来的问题<br><img src="https://i.loli.net/2020/06/08/UMH8GEDjbgcw19v.png" alt="共享信道带来的问题"></p><p>媒体共享技术<br><strong>静态划分信道</strong><br>        1.频分复用<br>        2.时分复用<br>        3.波分复用<br>        4.码分复用<br><strong>动态媒体接入控制（多点接入）</strong><br>        1.随机接入<br>        2.受控接入 ，如多点线路探询 (polling)，或轮询。      </p><p>以太网的两个标准<br><strong>DIX Ethernet V2</strong> 是世界上第一个局域网产品（以太网）的规约。<br><strong>IEEE 802.3</strong> 是第一个 IEEE 的以太网标准。<br>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。<br>严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网 。 </p><h4 id="数据链路层的两个子层（不理解）"><a href="#数据链路层的两个子层（不理解）" class="headerlink" title="数据链路层的两个子层（不理解）"></a>数据链路层的两个子层（不理解）</h4><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：<br>            1.逻辑链路控制 LLC (Logical Link Control)子层；<br>            2.媒体接入控制 MAC (Medium Access Control)子层。<br>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong><br><img src="https://i.loli.net/2020/06/08/NJjRTOlkfMSwV2E.png" alt="局域网对 LLC 子层是透明的"><br>一般不考虑 LLC 子层<br>由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了。<br>很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。 </p><p>适配器的作用<br>网络接口板又称为<strong>通信适配器</strong> (adapter) 或<strong>网络接口卡</strong> NIC (Network Interface Card)，或“<strong>网卡</strong>”。<br>适配器的重要功能：<br>        1.进行串行/并行转换。<br>        2.对数据进行缓存。<br>        3.在计算机的操作系统安装设备驱动程序。<br>        4.实现以太网协议。<br><img src="https://i.loli.net/2020/06/08/raF5YN4U7X3pf9o.png" alt="计算机通过适配器和局域网进行通信"></p><h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h3><p>最初的以太网是将许多计算机都连接到一根总线上。<strong>易于实现广播通信</strong>。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。<br><img src="https://i.loli.net/2020/06/08/HXhwvdIbLqJtEMR.png" alt="总线连接"></p><p>为了实现<strong>一对一</strong>通信，将接收站的硬件地址写入帧首部中的<strong>目的地址</strong>字段中。仅当数据帧中的目的地址与适配器的硬件地址一致时，才能接收这个数据帧。<br><img src="https://i.loli.net/2020/06/08/pkHaSm7l8926qbe.png" alt="一对一通信"></p><p>总线也有<strong>缺点</strong>。若多台计算机或多个站点同时发送时，会产生发送碰撞或冲突，导致发送失败。<br><img src="https://i.loli.net/2020/06/08/zbuC75mncySVIx8.png" alt="总线连接缺点"></p><h4 id="以太网的两种重要措施"><a href="#以太网的两种重要措施" class="headerlink" title="以太网的两种重要措施"></a>以太网的两种重要措施</h4><p>为了通信的简便，以太网采取了两种重要的措施：<br>(1) 采用较为灵活的<strong>无连接的工作方式</strong><br>            不必先建立连接就可以直接发送数据。<br>            对发送的数据帧不进行编号，也不要求对方发回确认。<br>            <strong>这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。</strong><br>(2) 以太网发送的数据都使用<strong>曼彻斯特</strong> (Manchester) 编码<br>            <strong>曼彻斯特编码缺点</strong>是：它所占的频带宽度比原始的基带信号增加了一倍。</p><h4 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h4><p><strong>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</strong><br>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。<strong>差错的纠正由高层来决定</strong>。<br>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 </p><p>如何避免同时发送产生的碰撞？ 采用 CSMA/CD</p><p><img src="https://i.loli.net/2020/06/08/9vCsDoO2p7QAMfK.png" alt="CSMA/CD协议"><br>CSMA/CD 含义：<strong>载波监听多点接入 / 碰撞检测  **(Carrier Sense Multiple Access with Collision Detection) 。<br>“</strong>多点接入<strong>”表示许多计算机以多点接入的方式连接在一根总线上。<br>“</strong>载波监听<strong>”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br>总线上并没有什么“载波”。因此， **“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号</strong>。</p><p><strong>碰撞检测</strong><br>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。<br>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。<br>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。<br><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></p><p><strong>检测到碰撞后</strong><br>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。<br><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送</strong>。</p><h4 id="CSMA-CD-协议工作流程"><a href="#CSMA-CD-协议工作流程" class="headerlink" title="CSMA/CD 协议工作流程"></a>CSMA/CD 协议工作流程</h4><p><img src="https://i.loli.net/2020/06/08/EcPsJaq47wY5DKA.png" alt="CSMA/CD 协议工作流程"></p><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="https://i.loli.net/2020/06/08/8xfdn4I5TakMBvp.png" alt="为什么要进行碰撞检测？"></p><p>争用期<br>最先发送数据帧的站，在发送数据帧后至多经过时间 ：<br>$$<br>2\tau<br>$$<br>（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。<br>以太网的端到端往返时延：<br>$$<br>2\tau<br>$$<br>称为争用期，或碰撞窗口。<br>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><h4 id="二进制指数类型退避算法-（看看）"><a href="#二进制指数类型退避算法-（看看）" class="headerlink" title="二进制指数类型退避算法 （看看）"></a><strong>二进制指数类型退避算法</strong> （看看）</h4><p>(truncated binary exponential type)<br>发生碰撞的站在停止发送数据后，要推迟（退避）一个<strong>随机时间</strong>才能再发送数据。<br>        1.<strong>基本退避时间取为争用期</strong>：<br>$$<br>2\tau<br>$$<br>​        2.从整数集合 [0, 1, … , (2k - 1)] 中<strong>随机</strong>地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。<br>​        3.参数 k 按下面的公式计算：<br>$$<br>k = Min[重传次数, 10]<br>$$<br>​        4.当 k ≤10 时，参数 k 等于重传次数。<br>​        5.当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 </p><p>例如：<br>        第 1 次冲突重传时：<br>                k = 1，r 为 {0，1} 集合中的任何一个数。<br>        第 2 次冲突重传时：<br>                k = 2，r 为 {0，1，2，3} 集合中的任何一个数。<br>        第 3 次冲突重传时：<br>                k = 3，r 为 {0，1，2，3，4，5，6，7} 集合中的任何一个数。</p><p>10 Mbit/s 以太网争用期的长度<br>10 Mbit/s 以太网取：<br>$$<br>51.2 \mu s<br>$$<br>为争用期的长度。<br>对于 10 Mbit/s 以太网，在争用期内可发送 512 bit，即 64 字节。<br><strong>这意味着：以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</strong></p><p>最短有效帧长<br>如果发生冲突，就一定是在发送的前 64 字节之内。<br>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。<br>以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的<strong>无效帧</strong>。</p><p>覆盖范围<br>在 10 Mbit/s 以太网 51.2 μs 的争用期内，信号能传输多远的距离？<br>以太网上最大的端到端单程时延必须小于争用期的一半（即 25.6 μs），这相当于以太网的最大端到端长度约为 5 km。</p><p>人为干扰信号</p><p><img src="https://i.loli.net/2020/06/08/6tJ4KX1nwHbYzpo.png" alt="人为干扰信号"><br>注意：B 也能够检测到冲突，并立即停止发送数据帧，接着就发送干扰信号。这里为了简单起见，只画出 A 发送干扰信号的情况。</p><h4 id="CSMA-CD-协议的重要特性"><a href="#CSMA-CD-协议的重要特性" class="headerlink" title="CSMA/CD 协议的重要特性"></a>CSMA/CD 协议的重要特性</h4><p>使用 CSMA/CD 协议的以太网<strong>不能进行全双工通信而只能进行双向交替通信</strong>（半双工通信）。<br>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。<br>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。 </p><p><img src="https://i.loli.net/2020/06/08/XtFjcVgrG7zhW6R.png" alt="CSMA/CD 协议的要点"></p><h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。<br>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。<br>传统以太网使用同轴电缆，采用总线形拓扑结构</p><p>使用集线器的双绞线以太网<br><img src="https://i.loli.net/2020/06/08/I6yuP9D3zZKhRNB.png" alt="使用集线器的双绞线以太网"></p><p>星形以太网 10BASE-T<br><img src="https://i.loli.net/2020/06/08/P6DbJyTKIEuvoaX.png" alt="星形以太网 10BASE-T"><br>使用无屏蔽双绞线，采用星形拓扑。<br>每个站需要用两对双绞线，分别用于发送和接收。<br>双绞线的两端使用 RJ-45 插头。<br>集线器使用了大规模集成电路芯片，因此集线器的可靠性提高。<br>10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100m。</p><p>10BASE-T 以太网在局域网中的统治地位<br>这种 10 Mbit/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 具有很高的性价比。<br>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。<br>从此以太网的拓扑就从总线形变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。 </p><h4 id="集线器（HUB）特点"><a href="#集线器（HUB）特点" class="headerlink" title="集线器（HUB）特点"></a>集线器（HUB）特点</h4><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。<br><strong>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。</strong><br>集线器很像一个多接口的转发器，<strong>工作在物理层</strong>。<br>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</p><h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><p>多个站在以太网上同时工作就可能会发生碰撞。<br>当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，<strong>以太网总的信道利用率并不能达到 100%。</strong><br>假设:<br>$$<br>\tau<br>$$<br> 是以太网单程端到端传播时延。则争用期长度为<br>$$<br>2\tau<br>$$<br>即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。<br>设帧长为 L (bit)，数据发送速率为 C (bit/s)，则帧的发送时间为  :<br>$$<br>T_0 = L/C (s)。<br>$$<br><strong>以太网信道被占用的情况</strong><br>一个站在发送帧时出现了碰撞。经过一个争用期:<br>$$<br>2\tau<br>$$<br>后，可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 T0。<br>注意到，成功发送一个帧需要占用信道的时间是<br>$$<br>T_0 + \tau<br>$$<br>比这个帧的发送时间要多一个单程端到端时延:<br>$$<br>\tau<br>$$<br>这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。<br>在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是:<br>$$<br>\tau<br>$$</p><h4 id="参数a与利用率"><a href="#参数a与利用率" class="headerlink" title="参数a与利用率"></a>参数a与利用率</h4><p>$$<br>要提高以太网的信道利用率，就必须减小\tau与 T_0 之比。<br>在以太网中定义了参数 a ，它是以太网单程端到端时延\tau与帧的发送时间 T_0 之比：<br>$$</p><p><img src="https://i.loli.net/2020/06/09/gLbpVFSjMcY16G5.png" alt="参数a与利用率"></p><p>a → 0，表示一发生碰撞就立即可以检测出来， 并立即停止发送，因而信道利用率很高。<br>a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。 </p><p>对以太网参数a的要求<br>为提高利用率，以太网的参数 a 的值应当<strong>尽可能小</strong>些。<br>对以太网参数 a 的要求是：<br>$$<br>1.当数据率一定时，以太网的连线的长度受到限制，否则\tau的数值会太大。<br>\<br>2.以太网的帧长不能太短，否则 T_0 的值会太小，使 a 值太大。<br>$$</p><h4 id="信道利用率的最大值"><a href="#信道利用率的最大值" class="headerlink" title="信道利用率的最大值"></a>信道利用率的最大值</h4><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。<br>$$<br>发送一帧占用线路的时间是 T_0 +\tau，而帧本身的发送时间是 T_0。于是，我们可计算出理想情况下的极限信道利用率 S_{max} 为：<br>$$<br><img src="https://i.loli.net/2020/06/09/xzfdKcm6YoT9hiU.png" alt="信道利用率的最大值"></p><p>只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率。<br>据统计，当以太网的利用率达到 30% 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p><h3 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h3><h4 id="MAC层的硬件地址"><a href="#MAC层的硬件地址" class="headerlink" title="MAC层的硬件地址"></a>MAC层的硬件地址</h4><p>在局域网中，<strong>硬件地址</strong>又称为<strong>物理地址</strong>，或** MAC 地址**。<br>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。<br>但鉴于大家都早已习惯了将这种 48 位的“名字”称为“地址”，所以本书也采用这种习惯用法，尽管这种说法并不太严格。</p><p>请注意，如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机或路由器就有多个“地址”。更准确些说，这种 48 位“地址”应当是某个接口的标识符。</p><h5 id="48-位的-MAC-地址"><a href="#48-位的-MAC-地址" class="headerlink" title="48 位的 MAC 地址"></a>48 位的 MAC 地址</h5><p>IEEE 802 标准规定 MAC 地址字段可采用 6 字节 ( 48位) 或 2 字节 ( 16 位) 这两种中的一种。<br>IEEE 的注册管理机构 RA 负责向厂家分配地址字段 6 个字节中的前三个字节 (即高位 24 位)，称为组织唯一标识符。<br>地址字段 6 个字节中的后三个字节 (即低位 24 位) 由厂家自行指派，称为扩展唯一标识符，必须保证生产出的适配器没有重复地址。</p><p><img src="https://i.loli.net/2020/06/09/iPeoYlDkUM8Rvcq.png" alt="48 位的 MAC 地址"></p><p>一个地址块可以生成 224 个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是 EUI-48。<br>生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM，因此，MAC 地址也叫做<strong>硬件地址</strong> (hardware address) 或<strong>物理地址</strong>。<br>“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</p><p>单站地址、组地址、广播地址<br>IEEE 规定地址字段的第一字节的最低位为 I/G 位。I/G 表示 Individual / Group。<br>当 I/G 位 = 0 时，地址字段表示一个<strong>单站地址</strong>。<br>当 I/G 位 = 1 时，表示<strong>组地址</strong>，用来进行<strong>多播</strong>（以前曾译为组播）。此时，IEEE 只分配地址字段前三个字节中的 23 位。<br>当 I/G 位分别为 0 和 1 时，一个地址块可分别生成 223 个单个站地址和 223 个组地址。<br>所有 48 位都为 1 时，为广播地址。只能作为目的地址使用。</p><p>全球管理与本地管理<br>IEEE 把地址字段第一字节的最低第 2 位规定为 G/L 位，表示 Global / Local。<br>当 G/L 位 = 0 时，是全球管理（保证在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于全球管理。<br>当 G/L 位 = 1 时， 是本地管理，这时用户可任意分配网络上的地址。</p><h5 id="适配器检查-MAC-地址"><a href="#适配器检查-MAC-地址" class="headerlink" title="适配器检查 MAC 地址"></a>适配器检查 MAC 地址</h5><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。<br>        1.如果是发往本站的帧则收下，然后再进行其他的处理。<br>        2.否则就将此帧丢弃，不再进行其他的处理。<br>“发往本站的帧”包括以下三种帧：<br>        1.单播 (unicast) 帧（一对一）<br>        2.广播 (broadcast) 帧（一对全体）<br>        3.多播 (multicast) 帧（一对多）<br>所有的适配器都至少能够识别前两种帧，即<strong>能够识别单播地址和广播地址</strong>。<br>有的适配器可用编程方法识别多播地址。<br><strong>只有目的地址才能使用广播地址和多播地址</strong>。<br>以*<em>混杂方式 *</em>(promiscuous mode) 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。</p><h4 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h4><p>常用的以太网 MAC 帧格式有两种标准：<br>        1.DIX Ethernet V2 标准<br>        2.IEEE 的 802.3 标准<br>最常用的 MAC 帧是<strong>以太网 V2 的格式</strong>。</p><h5 id="以太网V2帧格式"><a href="#以太网V2帧格式" class="headerlink" title="以太网V2帧格式"></a>以太网V2帧格式</h5><p><img src="https://i.loli.net/2020/06/09/C57bEqVlI1MJOa3.png" alt="以太网 V2 的 MAC 帧格式"></p><p><img src="https://i.loli.net/2020/06/09/BTMNI6p8ancgREq.png" alt="以太网 V2 的 MAC 帧格式"></p><p><img src="https://i.loli.net/2020/06/09/YocWNHsx2ivVb1K.png" alt="以太网 V2 的 MAC 帧格式"></p><p><img src="https://i.loli.net/2020/06/09/UfbwYvX9iG7gR2r.png" alt="以太网 V2 的 MAC 帧格式"></p><p><img src="https://i.loli.net/2020/06/09/tQN6PF12eSDlMKz.png" alt="以太网 V2 的 MAC 帧格式"></p><p><img src="https://i.loli.net/2020/06/09/lNSjhx5JU3RMsqH.png" alt="以太网 V2 的 MAC 帧格式"></p><p><img src="https://i.loli.net/2020/06/09/Ynah3IybBkd7EtX.png" alt="以太网 V2 的 MAC 帧格式"></p><p>无效的MAC帧</p><p>数据字段的长度与长度字段的值不一致<br>帧的长度不是整数个字节<br>用收到的帧检验序列 FCS 查出有差错<br>数据字段的长度不在 46 ~ 1500 字节之间<br>有效的 MAC 帧长度为 64 ~ 1518 字节之间</p><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。 </p><h5 id="IEEE-802-3-MAC-帧格式"><a href="#IEEE-802-3-MAC-帧格式" class="headerlink" title="IEEE 802.3 MAC 帧格式"></a>IEEE 802.3 MAC 帧格式</h5><p>与以太网 V2 MAC 帧格式相似，区别在于：<br>    IEEE 802.3 规定的 MAC 帧的第三个字段是“长度 / 类型”。<br>            1.当这个字段值大于 0x0600 时（相当于十进制的 1536）.就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。<br>            2.当这个字段值小于 0x0600 时才表示“长度”。<br>    当“长度/类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</p><p>现在市场上流行的都是以太网 V2 的 MAC 帧，但大家也常常把它称为 IEEE 802.3 标准的 MAC 帧。</p><h5 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h5><p>帧间最小间隔为<br>$$<br> 9.6 \mu s<br>$$<br>相当于 96 bit 的发送时间。<br>$$<br>一个站在检测到总线开始空闲后，还要等待 9.6 \mu s 才能再次发送数据。<br>$$<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 </p><p>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 </p><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><h4 id="使用光纤扩展"><a href="#使用光纤扩展" class="headerlink" title="使用光纤扩展"></a>使用光纤扩展</h4><p>主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。<br>很容易使主机和几公里以外的集线器相连接。<br><img src="https://i.loli.net/2020/06/09/J6FhYZq7PaVNpAB.png" alt="使用光纤扩展以太网"></p><h4 id="使用集线器扩展"><a href="#使用集线器扩展" class="headerlink" title="使用集线器扩展"></a>使用集线器扩展</h4><p>将多个以太网段连成更大的、多级星形结构的以太网。<br><img src="https://i.loli.net/2020/06/09/hDacBHKYwA4j2kO.png" alt="使用集线器扩展以太网"></p><p>用集线器扩展以太网优缺点<br><strong>优点</strong><br>        1.使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。<br>        2.扩大了以太网覆盖的地理范围。<br><strong>缺点</strong><br>        1.碰撞域增大了，但总的吞吐量并未提高。<br>        2.如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 </p><h4 id="碰撞域"><a href="#碰撞域" class="headerlink" title="碰撞域"></a>碰撞域</h4><p><strong>碰撞域</strong>（collision domain）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。<br>碰撞域越大，发生碰撞的概率越高。<br><img src="https://i.loli.net/2020/06/09/brpOs3zvKIQkASc.png" alt="碰撞域"></p><h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><p>扩展以太网更常用的方法是在数据链路层进行。<br>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。<br><img src="https://i.loli.net/2020/06/09/CbYtDRSvl5agjPG.png" alt="在数据链路层扩展以太网"></p><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p><strong>网桥工作在数据链路层</strong>。<br>它根据 MAC 帧的目的地址对收到的帧进行<strong>转发</strong>和<strong>过滤</strong>。<br>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 </p><h4 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h4><p>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。<br>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在数据链路层。</p><h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><p>以太网交换机实质上就是一个<strong>多接口的网桥</strong>。通常都有十几个或更多的接口。<br>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在<strong>全双工方式</strong>。<br>以太网交换机具<strong>有并行性</strong>。能同时连通多对接口，使多对主机能同时通信。<br>相互通信的主机都是独占传输媒体，无碰撞地传输数据。<br><img src="https://i.loli.net/2020/06/09/a1KfU4ZtykXLzjR.png" alt="相互通信的主机都是独占传输媒体"></p><p>以太网交换机的<strong>接口有存储器</strong>，能在输出端口繁忙时把到来的帧进行缓存。<br>以太网交换机是一种<strong>即插即用设备</strong>，其内部的帧<strong>交换表</strong>（又称为地址表）是通过<strong>自学习算法</strong>自动地逐渐建立起来的。<br>以太网交换机使用了<strong>专用的交换结构芯片</strong>，用硬件转发，其转发速率要比使用软件转发的网桥快很多。<br>以太网交换机的性能远远超过普通的集线器，而且价格并不贵。</p><h5 id="以太网交换机的优点"><a href="#以太网交换机的优点" class="headerlink" title="以太网交换机的优点"></a>以太网交换机的优点</h5><p>用户独享带宽，增加了总容量。<br><img src="https://i.loli.net/2020/06/09/zYWyaT21HUNJpRS.png" alt="用户独享带宽，增加了总容量"></p><p>从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。<br>以太网交换机一般都具有多种速率的接口，方便了各种不同情况的用户。</p><h5 id="以太网交换机的交换方式"><a href="#以太网交换机的交换方式" class="headerlink" title="以太网交换机的交换方式"></a>以太网交换机的交换方式</h5><h6 id="存储转发方式"><a href="#存储转发方式" class="headerlink" title="存储转发方式"></a>存储转发方式</h6><p>把整个数据帧先缓存后再进行处理。</p><h6 id="直通-cut-through-方式"><a href="#直通-cut-through-方式" class="headerlink" title="直通 (cut-through) 方式"></a>直通 (cut-through) 方式</h6><p>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。<br><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</p><p>在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线路速率匹配、协议转换或差错检测时。</p><h5 id="以太网交换机的自学习功能-重要"><a href="#以太网交换机的自学习功能-重要" class="headerlink" title="以太网交换机的自学习功能(重要)"></a>以太网交换机的自学习功能(重要)</h5><p>以太网交换机运行自学习算法自动维护交换表。<br><img src="https://i.loli.net/2020/06/09/ZWcrHFVjnkie8JG.png" alt="以太网交换机的自学习功能"><br><img src="https://i.loli.net/2020/06/09/LeYv6Bm4MjiAonl.png" alt="以太网交换机的自学习功能"><br><img src="https://i.loli.net/2020/06/09/ivwxAkJaU8Nb41q.png" alt="以太网交换机的自学习功能"><br><img src="https://i.loli.net/2020/06/09/GWd9NVKfsH3XrkB.png" alt="以太网交换机的自学习功能"><br><img src="https://i.loli.net/2020/06/09/3iTdSK4YvjlUgqf.png" alt="以太网交换机的自学习功能"></p><p>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</p><p>交换机自学习和转发帧的步骤归纳<br><img src="https://i.loli.net/2020/06/09/MCcygIZBko5wLPp.png" alt="交换机自学习和转发帧的步骤归纳"></p><p>理解以太网交换机的自学习功能<br><img src="https://i.loli.net/2020/06/09/N7PYwpEJdrMBU5x.png" alt="image-20200609090644860"><br><img src="https://i.loli.net/2020/06/09/FoHWMmJQqcOy925.png" alt="以太网交换机的自学习功能"></p><p>以太网交换机自学习功能要避免交换机产生回路，在交换表还是空白时，若存在回路，转发帧会一直在回路中循环，消耗网络资源。</p><p>交换机使用了生成树协议<br>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP ** (Spanning Tree Protocol)。<br>其</strong>要点<strong>是：</strong>不改变<strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是</strong>无环路的树状结构**，从而消除了兜圈子现象，解决回路问题。<br><img src="https://i.loli.net/2020/06/09/kyx6sOeZwr37Dmd.png" alt="生成树协议 STP "></p><h4 id="从总线以太网到星形以太网"><a href="#从总线以太网到星形以太网" class="headerlink" title="从总线以太网到星形以太网"></a>从总线以太网到星形以太网</h4><p>早期，以太网采用无源的总线结构。<br>现在，采用以太网交换机的星形结构成为以太网的首选拓扑。<br>总线以太网使用 CSMA/CD 协议，以半双工方式工作。<br>以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA/CD 协议，以全双工方式工作。但<strong>仍然采用以太网的帧结构</strong>。<br><img src="https://i.loli.net/2020/06/09/8t2Wj4Vrk7aeFRX.png" alt="从总线以太网到星形以太网"></p><p>局域网存在的问题<br>        1.扩展性<br>        2.安全性<br>        3.可管理性 等</p><p>总线以太网 和 10Base_T 星形以太网</p><p>所有计算机都处于同一个<strong>碰撞域</strong>（或冲突域）中和同一个<strong>广播域</strong>中。<br><img src="https://i.loli.net/2020/06/09/lnDbrCsteYLBf3p.png" alt="总线以太网 和 10Base_T 星形以太网"><br><img src="https://i.loli.net/2020/06/09/msHhCkvXWdFgtNj.png" alt="总线以太网 和 10Base_T 星形以太网"></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><p>采用以太网交换机的星形以太网</p><p>每个接口都处于一个<strong>独立的碰撞域</strong>（或冲突域）中，但所有计算机都处于<strong>同一个广播域</strong>中。<br><img src="https://i.loli.net/2020/06/09/cfZW9bgkmezNrUw.png" alt="采用以太网交换机的星形以太网"><br><img src="https://i.loli.net/2020/06/09/z5tlH8VG1uhBsCN.png" alt="采用以太网交换机的星形以太网"></p><h3 id="虚拟局域网（重要）"><a href="#虚拟局域网（重要）" class="headerlink" title="虚拟局域网（重要）"></a>虚拟局域网（重要）</h3><p>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。<br>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。<br><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong><br>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。<br><img src="https://i.loli.net/2020/06/09/DjrCNoMut8ISa1w.png" alt="虚拟局域网 VLAN"><br><img src="https://i.loli.net/2020/06/09/VlJ59KZD84aqNPr.png" alt="虚拟局域网 VLAN"><br><img src="https://i.loli.net/2020/06/09/xeaLN2DAU7mbWvo.png" alt="虚拟局域网 VLAN"><br><img src="https://i.loli.net/2020/06/09/YTZMQAuD9z8yL73.png" alt="虚拟局域网 VLAN"><br><img src="https://i.loli.net/2020/06/09/1yfmiu62qbgPxOr.png" alt="虚拟局域网 VLAN"></p><p>虚拟局域网（VLAN）技术具有以下<strong>主要优点</strong>：<br>        1.改善了性能<br>        2.简化了管理<br>        3.降低了成本<br>        4.改善了安全性</p><p>划分虚拟局域网的方法<br>        1.基于交换机端口<br>                最简单、也是最常用的方法。<br>                属于在第一层划分虚拟局域网的方法。<br>                <strong>缺点</strong>：不允许用户移动。</p><p>​        2.基于计算机网卡的MAC地址<br>​                根据用户计算机的MAC地址划分虚拟局域网。<br>​                属于在第二层划分虚拟局域网的方法。<br>​                允许用户移动。<br>​                <strong>缺点</strong>：需要输入和管理大量的MAC地址。如果用户的MAC地址改变了，则需要管理员重新配置VLAN。</p><p>​        3.基于协议类型<br>​                根据以太网帧的第三个字段“类型”字段确定该类型的协议属于哪一个虚拟局域网。<br>​                属于在第二层划分虚拟局域网的方法。</p><p>​        4.基于IP子网地址<br>​                根据以太网帧的第三个字段“类型”字段和IP分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网。<br>​                属于在第三层划分虚拟局域网的方法。</p><p>​        5.基于高层应用或服务<br>​                根据高层应用或服务、或者它们的组合划分虚拟局域网。<br>​                更加灵活，但更加复杂。</p><p>虚拟局域网使用的以太网帧格式<br>IEEE 批准了 802.3ac 标准，该标准定义了以太网的帧格式的扩展，以支持虚拟局域网。<br>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 <strong>VLAN 标记</strong> (tag)，用来指明该帧属于哪一个虚拟局域网。<br>插入VLAN标记得出的帧称为 802.1Q 帧或带标记的以太网帧。<br><img src="https://i.loli.net/2020/06/09/oFSm6i5hXZLqAtW.png" alt="虚拟局域网使用的以太网帧格式"><br><img src="https://i.loli.net/2020/06/09/njwRFLegJfVEYr8.png" alt="虚拟局域网使用的以太网帧格式"></p><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><h3 id="100BASE-T-以太网"><a href="#100BASE-T-以太网" class="headerlink" title="100BASE-T 以太网"></a>100BASE-T 以太网</h3><p><strong>速率达到或超过 100 Mbit/s 的以太网称为高速以太网</strong>。<br>100BASE-T 在双绞线上传送 100 Mbit/s 基带信号的星形拓扑以太网，仍使用 IEEE 802.3 的 CSMA/CD 协议。<br>100BASE-T 以太网又称为<strong>快速以太网</strong> (Fast Ethernet)。<br>1995 年IEEE已把 100BASE-T 的快速以太网定为正式标准，其代号为 IEEE 802.3u。</p><p>100BASE-T 以太网的特点<br>可在全双工方式下工作而无冲突发生。<strong>在全双工方式下工作时，不使用 CSMA/CD 协议</strong>。<br><strong>MAC 帧格式仍然是 802.3 标准规定的</strong>。<br><strong>保持最短帧长不变，但将一个网段的最大电缆长度减小到 100 米</strong>。<br>$$<br>帧间时间间隔从原来的 9.6 \mu s 改为现在的 0.96 \mu s<br>$$<br> 100 Mbit/s 以太网的三种不同的物理层标准<br>100BASE-TX<br>        1.使用 2 对 UTP 5 类线 或 屏蔽双绞线 STP。<br>        2.网段最大程度：100 米。<br>100BASE-T4<br>        1.使用 4 对 UTP 3 类线 或 5 类线。<br>        2.网段最大程度：100 米。<br>100BASE-FX<br>        1.使用 2 对光纤。<br>        2.网段最大程度：2000 米。</p><h3 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h3><p>允许在 1 Gbit/s 下以全双工和半双工两种方式工作。<br>使用 IEEE 802.3 协议规定的帧格式。<br><strong>在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议</strong>。<br>与 10BASE-T 和 100BASE-T 技术向后兼容。</p><p>吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中。</p><p>吉比特以太网的物理层<br>使用两种成熟的技术：一种来自现有的以太网，另一种则是美国国家标准协会 ANSI 制定的光纤通道 FC  (Fiber Channel)。<br><img src="https://i.loli.net/2020/06/09/HwBpR1bxtWGmvzf.png" alt="吉比特以太网的物理层标准"></p><p>半双工方式工作的吉比特以太网<br>吉比特以太网工作在半双工方式时，就必须进行碰撞检测。<br>为保持 64 字节最小帧长度，以及 100 米的网段的最大长度，吉比特以太网增加了两个功能：<br>        1.载波延伸 (carrier extension)<br>            使最短帧长仍为 64 字节（这样可以保持兼容性），同时将争用时间增大为 512 字节。<br>            凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到 512 字节。            接收端在收到以太网的 MAC 帧后，要将所填充的特殊字符删除后才向高层交付。<br><img src="https://i.loli.net/2020/06/09/49ZKaM2YrnPBNgV.png" alt="载波延伸"></p><p>​        2.分组突发 (packet bursting)<br>​            当很多短帧要发送时，第一个短帧要采用载波延伸方法进行填充，随后的一些短帧则可一个接一个地发送，只需留            有必要的帧间最小间隔即可。这样就形成可一串分组的突发，直到达到 1500 字节或稍多一些为止。<br><img src="https://i.loli.net/2020/06/09/52lAtKbTQDzuC13.png" alt="分组突发"></p><p>全双工方式工作的吉比特以太网<br>当吉比特以太网工作在全双工方式时（即通信双方可同时进行发送和接收数据），<strong>不使用载波延伸和分组突发</strong>。</p><h3 id="10-吉比特以太网-10GE-和更快的以太网"><a href="#10-吉比特以太网-10GE-和更快的以太网" class="headerlink" title="10 吉比特以太网 (10GE) 和更快的以太网"></a>10 吉比特以太网 (10GE) 和更快的以太网</h3><p>10 吉比特以太网（10GE）并非把吉比特以太网的速率简单地提高到 10 倍，其主要特点有：<br>        1.与 10 Mbit/s、100 Mbit/s 和 1 Gbit/s 以太网的帧格式完全相同。<br>        2.保留了 802.3 标准规定的以太网最小和最大帧长，便于升级。<br>        3.不再使用铜线而只使用光纤作为传输媒体。<br>        4.<strong>只工作在全双工方式</strong>，因此没有争用问题，也不使用 CSMA/CD 协议。 </p><p>10 吉比特以太网的物理层<br><img src="https://i.loli.net/2020/06/09/y73aotmCdbS5Tu9.png" alt="10GE物理层标准"></p><p>40GE/100GE 的物理层<br><img src="https://i.loli.net/2020/06/09/SCbEOKcwqsJP8DA.png" alt="40GE/100GE 的物理层标准"></p><p>端到端的以太网传输<br>以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而<strong>实现了端到端的以太网传输</strong>。<br>这种工作方式的好处有：<br>        1.技术成熟<br>        2.互操作性很好<br>        3.在广域网中使用以太网时价格便宜<br>        4.采用统一的以太网帧格式，简化了操作和管理。</p><h3 id="使用以太网进行宽带接入"><a href="#使用以太网进行宽带接入" class="headerlink" title="使用以太网进行宽带接入"></a>使用以太网进行宽带接入</h3><p>IEEE 在 2001 年初成立了 802.3 EFM 工作组，专门研究高速以太网的宽带接入技术问题。<br>以太网宽带接入具有以下特点：<br>        1.可以提供双向的宽带通信。<br>        2.可以根据用户对带宽的需求灵活地进行带宽升级。<br>        3.可以实现端到端的以太网传输,中间不需要再进行帧格式的转换。这就提高了数据的传输效率且降低了传输的成本。<br>        4.但是不支持用户身份鉴别。</p><p>PPPoE<br>PPPoE (PPP over Ethernet) 的意思是“在以太网上运行 PPP”，它把 PPP 协议与以太网协议结合起来 —— 将 PPP 帧再封装到以太网中来传输。<br>现在的光纤宽带接入 FTTx 都要使用 PPPoE 的方式进行接入。在 PPPoE 弹出的窗口中键入在网络运营商购买的用户名和密码，就可以进行宽带上网了。<br>利用 ADSL 进行宽带上网时，从用户个人电脑到家中的 ADSL 调制解调器之间，也是使用 RJ-45 和 5 类线（即以太网使用的网线）进行连接<br>的，并且也是使用 PPPoE 弹出的窗口进行拨号连接的。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h2 id="虚拟专用网VPN和网络地址转换NAT"><a href="#虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="虚拟专用网VPN和网络地址转换NAT"></a>虚拟专用网VPN和网络地址转换NAT</h2><h2 id="多协议标记交换MPLS"><a href="#多协议标记交换MPLS" class="headerlink" title="多协议标记交换MPLS"></a>多协议标记交换MPLS</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器OSPF动态路由配置</title>
      <link href="/2020/05/22/ji-suan-ji-wang-luo-yuan-li-shi-yan-12/"/>
      <url>/2020/05/22/ji-suan-ji-wang-luo-yuan-li-shi-yan-12/</url>
      
        <content type="html"><![CDATA[<h2 id="实验名称-路由器OSPF动态路由配置"><a href="#实验名称-路由器OSPF动态路由配置" class="headerlink" title="﻿实验名称  路由器OSPF动态路由配置"></a>﻿实验名称  路由器OSPF动态路由配置</h2><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><h3 id="1-掌握OSPF协议的配置方法"><a href="#1-掌握OSPF协议的配置方法" class="headerlink" title="1.掌握OSPF协议的配置方法"></a>1.掌握OSPF协议的配置方法</h3><h3 id="2-掌握查看通过动态路由协议OSPF学习产生的路由"><a href="#2-掌握查看通过动态路由协议OSPF学习产生的路由" class="headerlink" title="2.掌握查看通过动态路由协议OSPF学习产生的路由"></a>2.掌握查看通过动态路由协议OSPF学习产生的路由</h3><h3 id="3-熟悉广域网线缆的链接方式"><a href="#3-熟悉广域网线缆的链接方式" class="headerlink" title="3.熟悉广域网线缆的链接方式"></a>3.熟悉广域网线缆的链接方式</h3><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="1-新建packet-tracer拓扑图"><a href="#1-新建packet-tracer拓扑图" class="headerlink" title="1.新建packet tracer拓扑图"></a>1.新建packet tracer拓扑图</h3><p><img src="https://img-blog.csdnimg.cn/2020052219490176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="实验拓扑图"></p><h3 id="2-划分VLAN"><a href="#2-划分VLAN" class="headerlink" title="2.划分VLAN"></a>2.划分VLAN</h3><p>在本实验中的三层交换机上划分VLAN10和VLAN20，其中VLAN10用于连接校园网主机，VLAN20用于连接R1<br><img src="https://img-blog.csdnimg.cn/20200522194918731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="交换机划分VLAN"></p><h3 id="3-配置路由器"><a href="#3-配置路由器" class="headerlink" title="3.配置路由器"></a>3.配置路由器</h3><p>路由器之间通过V35电缆通过串口连接，DCE端连接在R1上，配置其时钟频率64000<br><img src="https://img-blog.csdnimg.cn/20200522194938834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器R1"><br><img src="https://img-blog.csdnimg.cn/20200522194953523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器R2"></p><h3 id="4-连接网络设备"><a href="#4-连接网络设备" class="headerlink" title="4.连接网络设备"></a>4.连接网络设备</h3><p>主机和交换机通过直连线，主机与路由器通过交叉线连接。<br><img src="https://img-blog.csdnimg.cn/20200522195012975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="连接网络设备"></p><h3 id="5-在S3560上配置OSPF路由协议"><a href="#5-在S3560上配置OSPF路由协议" class="headerlink" title="5.在S3560上配置OSPF路由协议"></a>5.在S3560上配置OSPF路由协议</h3><p><img src="https://img-blog.csdnimg.cn/20200522195032525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="交换机配置OSPF协议"><br><img src="https://img-blog.csdnimg.cn/20200522195049298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="交换机配置OSPF协议结果"></p><h3 id="6-在路由器R1、R2上配置OSPF路由协议"><a href="#6-在路由器R1、R2上配置OSPF路由协议" class="headerlink" title="6.在路由器R1、R2上配置OSPF路由协议"></a>6.在路由器R1、R2上配置OSPF路由协议</h3><p><img src="https://img-blog.csdnimg.cn/20200522195107905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="路由器R1配置OSPF协议"><br><img src="https://img-blog.csdnimg.cn/20200522195125340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="路由器R1配置OSPF协议结果"><br><img src="https://img-blog.csdnimg.cn/20200522195140286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="路由器R2配置OSPF协议"><br><img src="https://img-blog.csdnimg.cn/20200522195157439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="路由器R2配置OSPF协议结果"></p><h3 id="7-配置PC网关"><a href="#7-配置PC网关" class="headerlink" title="7.配置PC网关"></a>7.配置PC网关</h3><p>将PC1、PC2主机默认网关设置为与直连网路设备接口IP地址<br><img src="https://img-blog.csdnimg.cn/20200522195224337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置PC1网关"><br><img src="https://img-blog.csdnimg.cn/20200522195236556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置PC2网关"></p><h3 id="8-验证PC连通性"><a href="#8-验证PC连通性" class="headerlink" title="8.验证PC连通性"></a>8.验证PC连通性</h3><p>验证PC1、PC2主机之间可以互相通信<br><img src="https://img-blog.csdnimg.cn/20200522195306860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="验证PC1、PC2连通性"><br>经过各项配置，PC1和PC2成功互相连接通信，验证成功。</p><h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><p>实验指令分析</p><pre class=" language-bash"><code class="language-bash">PC1 //配置PC网关    IP:            192.168.1.2    Submask:        255.255.255.0    Gateway:        192.168.1.1PC2//配置PC网关    IP:            192.168.2.2    Submask:        255.255.255.0    Gateway:        192.168.2.1S3560//配置交换机信息    En                                        //进入特权模式    conf t                                    //进入全局配置模式    <span class="token function">hostname</span> S3560                            //设置主机名为S3560    vlan 10                                    //创建vlan 10    Exit                                    //退出    vlan 20                                    //创建vlan 20interface fa 0/10                            //添加端口    switchport access vlan 10                //使上面添加的端口经过vlan 10    Exit                                    //退出    int fa 0/20                                //添加端口    switchport access valn 20                //使上面添加的端口经过vlan 20    Exit                                    //退出    interface valn 10                        //选定vlan 10接口    ip address 192.168.1.1 255.255.255.0    //为接口绑定IP地址，子网掩码    no <span class="token function">shutdown</span>                                //开启端口    Exit                                    //退出    interface vlan 20                        //选定vlan 20接口    ip address 192.168.3.1 255.255.255.0    //为接口绑定IP地址，子网掩码    no <span class="token function">shutdown</span>                                //开启端口    End                                        //结束配置    show ip route                            //显示路由信息    conf t                                    //进入全局配置模式ip routing                                    //开启routing（路由三层）功能    router ospf 1                            //启动或停止OSPF    network 192.168.1.0 0.0.0.255 area 0    //宣告反掩码    network 192.168.3.0 0.0.0.255 area 0    //宣告反掩码    End                                        //结束配置    show ip route                            //显示路由信息R1     en    conf t                                    //进入全局配置模式    <span class="token function">hostname</span> R1                                //修改主机名为R1    interface fa 0/0                        //选定端口    no <span class="token function">shutdown</span>                                //开启端口    ip address 192.168.3.2 255.255.255.0    //为端口绑定IP地址，子网掩码    Exit                                    //退出    interface serial 2/0                    //选定接口    no <span class="token function">shutdown</span>                                //开启端口    clock rate 64000                        //设置端口时钟频率    ip address 192.168.4.1 255.255.255.0    //为端口绑定IP地址，子网掩码    End                                        //结束配置    show ip route                            //显示路由信息    conf t                                    //进入全局配置模式    router ospf 1                            //启动或停止OSPF    network 192.168.3.0 0.0.0.255 area 0    //宣告反掩码    network 192.168.4.0 0.0.0.255 area 0    //宣告反掩码    End                                        //结束配置    show ip route                            //显示路由信息R2//配置路由器信息，解析类比R1    en     Conft                                    //进入全局配置模式    <span class="token function">hostname</span> R2    interface fa 0/0    no <span class="token function">shutdown</span>                                //开启端口    ip address 192.168.2.1 255.255.255.0    <span class="token keyword">exit</span>    interface serial 2/0                    //选定接口    no <span class="token function">shutdown</span>                                //开启端口    ip address 192.168.4.2 255.255.255.0    End                                        //结束配置    show ip route                            //显示路由信息    conf t    router ospf 1                            //启动或停止OSPF    network 192.168.2.0 0.0.0.255 area 0    //宣告反掩码    network 192.168.4.0 0.0.0.255 area 0    //宣告反掩码    End                                        //结束配置    show ip route                            //显示路由信息</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器RIP动态路由配置</title>
      <link href="/2020/05/21/ji-suan-ji-wang-luo-yuan-li-shi-yan-11/"/>
      <url>/2020/05/21/ji-suan-ji-wang-luo-yuan-li-shi-yan-11/</url>
      
        <content type="html"><![CDATA[<h2 id="实验名称-路由器RIP动态路由配置"><a href="#实验名称-路由器RIP动态路由配置" class="headerlink" title="﻿实验名称  路由器RIP动态路由配置"></a>﻿实验名称  路由器RIP动态路由配置</h2><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><h3 id="1-掌握RIP协议的配置方法"><a href="#1-掌握RIP协议的配置方法" class="headerlink" title="1.掌握RIP协议的配置方法"></a>1.掌握RIP协议的配置方法</h3><h3 id="2-掌握查看通过动态路由协议RIP学习产生的路由"><a href="#2-掌握查看通过动态路由协议RIP学习产生的路由" class="headerlink" title="2.掌握查看通过动态路由协议RIP学习产生的路由"></a>2.掌握查看通过动态路由协议RIP学习产生的路由</h3><h3 id="3-熟悉广域网线缆的链接方式"><a href="#3-熟悉广域网线缆的链接方式" class="headerlink" title="3.熟悉广域网线缆的链接方式"></a>3.熟悉广域网线缆的链接方式</h3><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="1-建立建立packet-tracer拓扑图"><a href="#1-建立建立packet-tracer拓扑图" class="headerlink" title="1.建立建立packet tracer拓扑图"></a>1.建立建立packet tracer拓扑图</h3><p><img src="https://img-blog.csdnimg.cn/20200521194643106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="建立拓扑图"></p><h3 id="2-划分VLAN"><a href="#2-划分VLAN" class="headerlink" title="2.划分VLAN"></a>2.划分VLAN</h3><p>在三层交换机上划分VLAN10和VLAN20，其中VLAN10用于连接校园网主机，VLAN20用于连接R1。</p><p><img src="https://img-blog.csdnimg.cn/20200521194702602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="划分vlan"><br><img src="https://img-blog.csdnimg.cn/20200521194713463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="划分vlan结果"></p><h3 id="3-配置路由器"><a href="#3-配置路由器" class="headerlink" title="3.配置路由器"></a>3.配置路由器</h3><p>路由器之间通过V.35电缆通过串口连接，DCE端连接在R1上，配置其时钟频率64000。<br><img src="https://img-blog.csdnimg.cn/20200521194732880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器"><br><img src="https://img-blog.csdnimg.cn/20200521194745425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器结果"><br><img src="https://img-blog.csdnimg.cn/20200521194756920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器R2"><br><img src="https://img-blog.csdnimg.cn/20200521194811570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器R2结果"></p><h3 id="4-连接设备"><a href="#4-连接设备" class="headerlink" title="4.连接设备"></a>4.连接设备</h3><p>主机和交换机通过直连线，主机与路由器通过交叉线连接。经过前面几个步骤的配置，拓扑图中的各个网络设备已经可以互相正常通信。<br><img src="https://img-blog.csdnimg.cn/20200521194849826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="网络设备正常通信"></p><h3 id="5-在S3560上配置RIPV2路由协议。"><a href="#5-在S3560上配置RIPV2路由协议。" class="headerlink" title="5.在S3560上配置RIPV2路由协议。"></a>5.在S3560上配置RIPV2路由协议。</h3><p><img src="https://img-blog.csdnimg.cn/20200521194913783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置交换机 RIP协议"><br>配置结果如下图：<br><img src="https://img-blog.csdnimg.cn/20200521194935809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置交换机RIP协议结果"></p><h3 id="6-在路由器R1、R2上配置RIPV2路由协议。"><a href="#6-在路由器R1、R2上配置RIPV2路由协议。" class="headerlink" title="6.在路由器R1、R2上配置RIPV2路由协议。"></a>6.在路由器R1、R2上配置RIPV2路由协议。</h3><p><img src="https://img-blog.csdnimg.cn/20200521195003792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器R1 RIP协议"><br><img src="https://img-blog.csdnimg.cn/20200521195024648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置路由器R2 RIP协议"></p><h3 id="7-配置PC"><a href="#7-配置PC" class="headerlink" title="7.配置PC"></a>7.配置PC</h3><p>将PC1、PC2主机默认网关设置为与直连网路设备接口IP地址。</p><p><img src="https://img-blog.csdnimg.cn/2020052119504558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置PC默认网关和IP地址"><br><img src="https://img-blog.csdnimg.cn/20200521195132437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="配置PC默认网关和IP地址"></p><h3 id="8-验证连通性"><a href="#8-验证连通性" class="headerlink" title="8.验证连通性"></a>8.验证连通性</h3><p>验证PC1、PC2主机之间可以互相同信</p><p><img src="https://img-blog.csdnimg.cn/20200521195149356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="ping指令验证实验"><br>验证PC1 ping PC2通过，证明我们的RIP协议配置成功。</p><h2 id="四、实验数据"><a href="#四、实验数据" class="headerlink" title="四、实验数据"></a>四、实验数据</h2><h3 id="实验指令解析"><a href="#实验指令解析" class="headerlink" title="实验指令解析"></a>实验指令解析</h3><pre class=" language-bash"><code class="language-bash">PC1 //配置PC网关    IP:            192.168.1.2    Submask:        255.255.255.0    Gateway:        192.168.1.1PC2//配置PC网关    IP:            192.168.2.2    Submask:        255.255.255.0    Gateway:        192.168.2.1    S3560//配置交换机信息    en    conf t                    //进入全局配置模式    <span class="token function">hostname</span> S3560            //设置主机名为S3560    vlan 10                    //创建vlan 10    Exit                        //退出    vlan 20                    //创建vlan 20    Exit                        //退出    interface fa 0/10            //添加端口    switchport access vlan 10    //使上面添加的端口经过vlan 10    Exit                        //退出    interface fa 0/20            //添加端口    switchport access valn 20    //使上面添加的端口经过vlan 20    Exit                        //退出    End                        //结束配置    show vlan                //显示vlan配置信息    conf t                    //进入全局配置模式    interface vlan 10            //选定vlan 10接口    ip address 192.168.1.1 255.255.255.0    //为接口绑定IP地址，子网掩码    no <span class="token function">shutdown</span>                //开启端口    <span class="token keyword">exit</span>    interface vlan 20            //选定vlan 20接口    ip address 192.168.3.1 255.255.255.0    //为接口绑定IP地址，子网掩码    no <span class="token function">shutdown</span>                //开启端口    End                        //结束配置    show ip route                //显示路由信息    show running                //查看运行配置文件    conf t                    //进入全局配置模式    ip routing                    //开启routing（路由三层）功能    router rip                    //启动或停止RIP运行    network 192.168.1.0        //宣告参与RIP运算的接口    network 192.168.3.0    version 2                    //使用版本    End                        //结束配置    show ip route                //查看路由信息R1//配置路由器信息    En                        //进入特权模式    conf t                    //进入全局配置模式    <span class="token function">hostname</span> R1                //修改主机名为R1    interface fa 0/0            //选定端口    no <span class="token function">shutdown</span>                //开启端口    ip address 192.168.3.2 255.255.255.0    //为端口绑定IP地址，子网掩码    Exit                        //退出    interface serial 2/0            //选定接口    no <span class="token function">shutdown</span>                //开启端口    ip address 192.168.4.1 255.255.255.0    //为端口绑定IP地址，子网掩码    clock rate 64000            //设置端口时钟频率    End                        //结束配置    show ip route                //查看路由信息    conf t                    //进入全局配置模式    router rip                    //启动RIP    network 192.168.3.0        //设置参与RIP运算的IP    network 192.168.4.0    version 2                    //使用版本    Exit                        //退出R2//配置路由器信息，解析类比R1    en     conf t    <span class="token function">hostname</span> R2    interface fa 0/0    no <span class="token function">shutdown</span>    ip address 192.168.2.1 255.255.255.0    <span class="token keyword">exit</span>    interface serial 2/0    no <span class="token function">shutdown</span>    ip address 192.168.4.2 255.255.255.0    end    show ip route    conf t    router rip    network 192.168.2.0    netword 192.168.4.0    version 2    endPC1 Ping PC2 //验证连通性        Ping 192.168.2.2      reply    </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web自动化测试（python+selenium）</title>
      <link href="/2020/05/18/web-zi-dong-hua-ce-shi/"/>
      <url>/2020/05/18/web-zi-dong-hua-ce-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p><a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz</code></pre><h5 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h5><pre class=" language-bash"><code class="language-bash">　　　　<span class="token function">tar</span> xf Python-3.7.1.tar.xz　　　　<span class="token function">cd</span> Python-3.7.1　　　　yum -y <span class="token function">install</span> gcc-* openssl-* libffi-devel sqlite-devel　　　　./configure --enable-optimizations --with-openssl<span class="token operator">=</span>/usr/bin/openssl　　　　<span class="token function">make</span> -j4　　　　<span class="token function">make</span> <span class="token function">install</span>　　　　默认安装路径：/usr/local/lib/python3.7</code></pre><h5 id="更改安装源"><a href="#更改安装源" class="headerlink" title="更改安装源"></a>更改安装源</h5><pre class=" language-bash"><code class="language-bash">pip3 config <span class="token keyword">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><h5 id="升级pip"><a href="#升级pip" class="headerlink" title="升级pip"></a>升级pip</h5><pre class=" language-bash"><code class="language-bash">pip3 <span class="token function">install</span> --upgrade pip</code></pre><h5 id="安装虚拟环境工具"><a href="#安装虚拟环境工具" class="headerlink" title="安装虚拟环境工具"></a>安装虚拟环境工具</h5><pre class=" language-bash"><code class="language-bash">pip3 <span class="token function">install</span> virtualenv</code></pre><h5 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h5><pre class=" language-bash"><code class="language-bash">virtualenv web01</code></pre><h5 id="切换到虚拟环境"><a href="#切换到虚拟环境" class="headerlink" title="切换到虚拟环境"></a>切换到虚拟环境</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> web01/bin/activate</code></pre><h5 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h5><pre class=" language-bash"><code class="language-bash">　　　deactivate</code></pre><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><p>打开dos窗口输入：</p><pre class=" language-bash"><code class="language-bash">pip</code></pre><p>正常应显示以下内容：</p><pre class=" language-bash"><code class="language-bash">Usage:  pip <span class="token operator">&lt;</span>command<span class="token operator">></span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span>Commands:  <span class="token function">install</span>                     Install packages.  download                    Download packages.  uninstall                   Uninstall packages.  freeze                      Output installed packages <span class="token keyword">in</span> requirements format.  list                        List installed packages.  show                        Show information about installed packages.  check                       Verify installed packages have compatible dependencies.  config                      Manage local and global configuration.  search                      Search PyPI <span class="token keyword">for</span> packages.  wheel                       Build wheels from your requirements.  <span class="token function">hash</span>                        Compute hashes of package archives.  completion                  A helper <span class="token function">command</span> used <span class="token keyword">for</span> <span class="token function">command</span> completion.  <span class="token function">help</span>                        Show <span class="token function">help</span> <span class="token keyword">for</span> commands.General Options:  -h, --help                  Show help.  --isolated                  Run pip <span class="token keyword">in</span> an isolated mode, ignoring environment variables and user configuration.  -v, --verbose               Give <span class="token function">more</span> output. Option is additive, and can be used up to 3 times.  -V, --version               Show version and exit.  -q, --quiet                 Give <span class="token function">less</span> output. Option is additive, and can be used up to 3 <span class="token function">times</span> <span class="token punctuation">(</span>corresponding to                              WARNING, ERROR, and CRITICAL logging levels<span class="token punctuation">)</span>.  --log <span class="token operator">&lt;</span>path<span class="token operator">></span>                Path to a verbose appending log.  --proxy <span class="token operator">&lt;</span>proxy<span class="token operator">></span>             Specify a proxy <span class="token keyword">in</span> the form <span class="token punctuation">[</span>user:passwd@<span class="token punctuation">]</span>proxy.server:port.  --retries <span class="token operator">&lt;</span>retries<span class="token operator">></span>         Maximum number of retries each connection should attempt <span class="token punctuation">(</span>default 5 times<span class="token punctuation">)</span>.  --timeout <span class="token operator">&lt;</span>sec<span class="token operator">></span>             Set the socket <span class="token function">timeout</span> <span class="token punctuation">(</span>default 15 seconds<span class="token punctuation">)</span>.  --exists-action <span class="token operator">&lt;</span>action<span class="token operator">></span>    Default action when a path already exists: <span class="token punctuation">(</span>s<span class="token punctuation">)</span>witch, <span class="token punctuation">(</span>i<span class="token punctuation">)</span>gnore, <span class="token punctuation">(</span>w<span class="token punctuation">)</span>ipe, <span class="token punctuation">(</span>b<span class="token punctuation">)</span>ackup,                              <span class="token punctuation">(</span>a<span class="token punctuation">)</span>bort<span class="token punctuation">)</span>.  --trusted-host <span class="token operator">&lt;</span>hostname<span class="token operator">></span>   Mark this host as trusted, even though it does not have valid or any HTTPS.  --cert <span class="token operator">&lt;</span>path<span class="token operator">></span>               Path to alternate CA bundle.  --client-cert <span class="token operator">&lt;</span>path<span class="token operator">></span>        Path to SSL client certificate, a single <span class="token function">file</span> containing the private key and the                              certificate <span class="token keyword">in</span> PEM format.  --cache-dir <span class="token operator">&lt;</span>dir<span class="token operator">></span>           Store the cache data <span class="token keyword">in</span> <span class="token operator">&lt;</span>dir<span class="token operator">></span>.  --no-cache-dir              Disable the cache.  --disable-pip-version-check                              Don't periodically check PyPI to determine whether a new version of pip is available <span class="token keyword">for</span>                              download. Implied with --no-index.  --no-color                  Suppress colored output</code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>dos输入在线安装selenium指令：</p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> selenium<span class="token operator">==</span>2.53.6</code></pre><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p>确保已经安装Firefox/Chrome/Ie浏览器中的一个</p><p>以Firefox为例（Firefox请安装46以下的版本），打开dos窗口输入指令：</p><pre class=" language-bash"><code class="language-bash">pythonfrom selenium <span class="token function">import</span> webdriverwebdriver.Firefox<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>如果Firefox浏览器被调用启动，则表示selenium安装成功，其他浏览器请查阅“浏览器驱动”</p><h4 id="浏览器驱动"><a href="#浏览器驱动" class="headerlink" title="浏览器驱动"></a>浏览器驱动</h4><h5 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h5><p>请勿安装47以上的版本（selenium2不兼容47以上版本）</p><p>firefox历年版本的官方镜像地址：<br><a href="https://download-installer.cdn.mozilla.net/pub/firefox/releases/" target="_blank" rel="noopener">https://download-installer.cdn.mozilla.net/pub/firefox/releases/</a> </p><h5 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h5><p>selenium启动Chrome浏览器需要安装驱动包，不同的Chrome浏览器版本号对应的驱动文件版本号也不同，若不匹配，则无法启动。</p><p>查看Chrome版本号？</p><p>浏览器内：设置-&gt;关于-&gt;版本号</p><p>浏览器外：打开Chrome安装文件夹</p><p>Chrome浏览器chromedriver各版本驱动大全，下载地址：<br><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p><p>下载驱动成功后，确保chromedriver.exe文件放置于path路径下，我之前将环境变量配置到了python根目录，所以一般将chromedriver.exe放置于python安装的根目录。</p><h5 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h5><p>IE浏览器的IEdriver各版本驱动大全，下载地址：<br><a href="http://selenium-release.storage.googleapis.com/index.html" target="_blank" rel="noopener">http://selenium-release.storage.googleapis.com/index.html</a></p><h2 id="selenium之webdriver框架"><a href="#selenium之webdriver框架" class="headerlink" title="selenium之webdriver框架"></a>selenium之webdriver框架</h2><h3 id="webdriver-API"><a href="#webdriver-API" class="headerlink" title="webdriver API"></a>webdriver API</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 导入webdriver模块</span><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token comment" spellcheck="true"># 导入计时器模块</span><span class="token keyword">import</span> time<span class="token comment" spellcheck="true"># 打开Chrome浏览器</span><span class="token comment" spellcheck="true"># 其他浏览器替换浏览器名即可</span>driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用webdriver模块api导入网址</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://auntyang.tk"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计时器6s等待时间，一些异常报错可能就是因为没有在语句下设置等待时间</span><span class="token comment" spellcheck="true"># time模块的单位是s（秒），参数可以是小数也可以是整数</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 截屏保存到指定目录，参数格式：保存路径+文件名称+后缀</span>driver<span class="token punctuation">.</span>get_screenshot_as_file<span class="token punctuation">(</span><span class="token string">"D:\\test.jgp"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置指定浏览器窗口尺寸</span>driver<span class="token punctuation">.</span>set_window_size<span class="token punctuation">(</span><span class="token number">540</span><span class="token punctuation">,</span> <span class="token number">960</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置浏览器窗口最大化</span>driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 上一页，相当于浏览器左上角的左箭头按钮</span>driver<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 下一页，相当于浏览器左上角的右箭头按钮</span>driver<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用webdriver模块api进行刷新</span><span class="token comment" spellcheck="true"># 相当于浏览器输入框后面的刷新按钮</span>driver<span class="token punctuation">.</span>refresh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 结束浏览器进程</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 关闭当前窗口</span>driver<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><p>webdriver框架提供了18种元素定位方法，前8种通过元素属性定位，后10种通过xpan和css定位</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#id定位：</span>find_element_by_id<span class="token punctuation">(</span>self<span class="token punctuation">,</span> id_<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#name定位：</span>find_element_by_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#class定位：</span>find_element_by_class_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tag定位：</span>find_element_by_tag_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#link定位：</span>find_element_by_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> link_text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#partial_link定位</span>find_element_by_partial_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> link_text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#xpath定位：</span>find_element_by_xpath<span class="token punctuation">(</span>self<span class="token punctuation">,</span> xpath<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#css定位：</span>find_element_by_css_selector<span class="token punctuation">(</span>self<span class="token punctuation">,</span> css_selector）</code></pre><p>复数形式：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#id复数定位</span>find_elements_by_id<span class="token punctuation">(</span>self<span class="token punctuation">,</span> id_<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#name复数定位</span>find_elements_by_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#class复数定位</span>find_elements_by_class_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tag复数定位</span>find_elements_by_tag_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#link复数定位</span>find_elements_by_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#partial_link复数定位</span>find_elements_by_partial_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> link_text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#xpath复数定位</span>find_elements_by_xpath<span class="token punctuation">(</span>self<span class="token punctuation">,</span> xpath<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#css复数定位</span>find_elements_by_css_selector<span class="token punctuation">(</span>self<span class="token punctuation">,</span> css_selector<span class="token punctuation">)</span></code></pre><p>参数化方法：</p><pre class=" language-python"><code class="language-python">find_element<span class="token punctuation">(</span>self<span class="token punctuation">,</span> by<span class="token operator">=</span><span class="token string">'id'</span><span class="token punctuation">,</span> value<span class="token operator">=</span>None<span class="token punctuation">)</span>find_elements<span class="token punctuation">(</span>self<span class="token punctuation">,</span> by<span class="token operator">=</span><span class="token string">'id'</span><span class="token punctuation">,</span> value<span class="token operator">=</span>None<span class="token punctuation">)</span></code></pre><h3 id="xpath定位"><a href="#xpath定位" class="headerlink" title="xpath定位"></a>xpath定位</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>1.有时候同一个属性，同名的比较多，这时候可以通过标签筛选下，定位更准一点<br>2.如果不想制定标签名称，可以用*号表示任意标签<br>3.如果想制定具体某个标签，就可以直接写标签名称</p><h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><p>1.当某个元素属性不明显，无法直接定位时，可以先找其父元素</p><p>2.找到父元素后，向下一个层级就能定位到该元素</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>1.某元素标签和另一元素标签一样，且无法通过层级定位时，属于同父元素</p><p>2.同父元素的元素存在顺序，用索引定位</p><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>1.xpath可以对多个属性进行逻辑运算，支持与（and）、或（or）、非（not）</p><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p>1.xpath可以对元素进行模糊匹配</p><h4 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h4><p>编写脚本，打开百度首页，输入关键字“robotframework”，点击搜索</p><p>结果如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200523164846936.gif" alt="Web自动化测试"></p><h3 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 自动化测试 </tag>
            
            <tag> python </tag>
            
            <tag> selenium库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux根目录详解</title>
      <link href="/2020/05/17/linux-gen-mu-lu-xiang-jie/"/>
      <url>/2020/05/17/linux-gen-mu-lu-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>﻿使用Linux需要弄清楚其文件目录，尤其是根目录的各项文件的作用，进一步可以了解Linux系统的内核原理。<br><img src="https://img-blog.csdnimg.cn/20200516173152753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Linux根目录文件"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> Linux文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用网络协议分析仪Wireshark</title>
      <link href="/2020/05/16/ji-suan-ji-wang-luo-yuan-li-shi-yan-1/"/>
      <url>/2020/05/16/ji-suan-ji-wang-luo-yuan-li-shi-yan-1/</url>
      
        <content type="html"><![CDATA[<h2 id="实验名称-使用网络协议分析仪Wireshark"><a href="#实验名称-使用网络协议分析仪Wireshark" class="headerlink" title="﻿实验名称  使用网络协议分析仪Wireshark"></a>﻿实验名称  使用网络协议分析仪Wireshark</h2><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><pre><code> 1. 掌握安装和配置网络协议分析仪Wireshark的方法； 2. 熟悉使用Wireshark工具分析网络协议的基本方法，加深对协议格式、协议层次和协议交互过程的理解。</code></pre><h2 id="实验内容和要求"><a href="#实验内容和要求" class="headerlink" title="实验内容和要求"></a>实验内容和要求</h2><p>​    1. 安装和配置网络协议分析仪Wireshark（<a href="http://www.wireshark.org）；" target="_blank" rel="noopener">http://www.wireshark.org）；</a><br>​    2. 使用并熟悉Wireshark分析协议的界面环境（菜单、工具条和各种窗口等）。<br>​    3. 学会使用Wireshark捕捉协议包。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>​    1.运行Windows 10专业版操作系统的PC机一台<br>​    2.PC具有以太网卡一块，通过双绞线与局域网相连<br>​    3.已安装Wireshark与Cisco Packet Tracer程序</p><h2 id="操作方法与实验步骤"><a href="#操作方法与实验步骤" class="headerlink" title="操作方法与实验步骤"></a>操作方法与实验步骤</h2><h3 id="1-安装网络协议分析仪"><a href="#1-安装网络协议分析仪" class="headerlink" title="1.安装网络协议分析仪"></a>1.安装网络协议分析仪</h3><p><img src="https://img-blog.csdnimg.cn/20200516174918965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark首页"><br>安装成功并运行，进入主界面如图，（可以点击图片跳转Wireshark官网下载）我这里安装的版本是3.0.9，进入自动为中文界面，Wireshark进入后界面如上图没有任何本地接口，检查后发现未安装Winpacp，安装Winpacp后重启Wireshark，正常运行。</p><h3 id="2-使用Wireshark分析协议"><a href="#2-使用Wireshark分析协议" class="headerlink" title="2.使用Wireshark分析协议"></a>2.使用Wireshark分析协议</h3><h4 id="（1）点击Wireshark启动程序，正常运行如图"><a href="#（1）点击Wireshark启动程序，正常运行如图" class="headerlink" title="（1）点击Wireshark启动程序，正常运行如图"></a>（1）点击Wireshark启动程序，正常运行如图</h4><p><img src="https://img-blog.csdnimg.cn/20200516175003774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark首页"><br>其中捕获和分析是最重要的功能</p><h4 id="（2）分组捕获"><a href="#（2）分组捕获" class="headerlink" title="（2）分组捕获"></a>（2）分组捕获</h4><p><img src="https://img-blog.csdnimg.cn/20200516191047640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark捕获接口"><br>开始分组捕获之前选择捕获接口，我所使用的网络是网线接入电脑的有线网，所以我选择的是捕获接口是以太网。</p><h4 id="（3）协议分析。"><a href="#（3）协议分析。" class="headerlink" title="（3）协议分析。"></a>（3）协议分析。</h4><p><img src="https://img-blog.csdnimg.cn/20200516191115617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark以太网监听"><br>监听以太网接口得到的报文信息，如上图，其中有一条黑色底色的TCP报文信息*。<br><img src="https://img-blog.csdnimg.cn/20200516191158370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark以太网监听"><br>选择序号为191的一条报文信息进行分析，从蓝框可知该报文的发送源地址为223.166.151.88，目标地址为192.168.31.97，而目标地址192。168.31.97为我的专用网地址（路由器分配给笔记本的内网IP），源地址经查询地址为上海市，是一个公网IP，很明显该报文由外部网络发送至我的内网。<br>该报文的协议为OICQ，起初并不知道这个协议，但在中间信息框中发现该报文信息中包含了我的QQ号，由此推断OICQ为QQ通信协议，经过查询，OICQ为QQ的通讯协议，OICQ用户到OICQ服务器的通讯协议。<br><img src="https://img-blog.csdnimg.cn/20200516191237382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark以太网监听"><br>进入191号报文信息具体页，可看到报文具体信息和十六进制和ASCI码形式的报文内容。<br>这一帧包包含一下四种信息：<br>Frame: 物理层的数据帧情况。<br>Ethernet II , Src: 数据链路层以太网帧头部信息。<br>Internet Protocol Version 4, Src: 互联网层IP包头信息。<br>Internet Control Message Protocol: 互联网控制信息协议。ping 小包所使用的协议。<br>前三层基本上都是一样的，第四层开始就可以出现TCP, UDP 协议，第五层就可能有HTTP 应用层协议等等。<br><img src="https://img-blog.csdnimg.cn/20200516191313947.png" alt="帧结构"><br>由该栏信息可知，该报文源地址服务器端口为8000，目标端口为4004，报文长度为127，总和校验码（Checksum）为0xe51f。<br><img src="https://img-blog.csdnimg.cn/20200516191327952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="帧结构"><br>协议层信息，协议为OICQ（即时通讯软件协议）包含目标、版本、数据等信息。</p><h4 id="（4）保存分组捕获信息"><a href="#（4）保存分组捕获信息" class="headerlink" title="（4）保存分组捕获信息"></a>（4）保存分组捕获信息</h4><h2 id="实验数据记录和结果分析"><a href="#实验数据记录和结果分析" class="headerlink" title="实验数据记录和结果分析"></a>实验数据记录和结果分析</h2><p>实验数据与结果分析：</p><pre class=" language-bash"><code class="language-bash">Frame 191: 161 bytes on wire <span class="token punctuation">(</span>1288 bits<span class="token punctuation">)</span>, 161 bytes captured <span class="token punctuation">(</span>1288 bits<span class="token punctuation">)</span> on interface 0//第191帧，由161个字节在线，共1288位，实际捕获到161个字节在0接口    Interface id: 0 <span class="token punctuation">(</span>\Device\NPF_<span class="token punctuation">{</span>7E2C33C0-0623-46BB-9126-813FB633578B<span class="token punctuation">}</span><span class="token punctuation">)</span>//接口ID：0        Interface name: \Device\NPF_<span class="token punctuation">{</span>7E2C33C0-0623-46BB-9126-813FB633578B<span class="token punctuation">}</span>        Interface description: \344\273\245\345\244\252\347\275\221    Encapsulation type: Ethernet <span class="token punctuation">(</span>1<span class="token punctuation">)</span>//封装类型    Arrival Time: Mar 13, 2020 15:22:45.526314000 中国标准时间//到达时间    <span class="token punctuation">[</span>Time <span class="token function">shift</span> <span class="token keyword">for</span> this packet: 0.000000000 seconds<span class="token punctuation">]</span>//包偏移时间    Epoch Time: 1584084165.526314000 seconds//不理解    <span class="token punctuation">[</span>Time delta from previous captured frame: 0.027360000 seconds<span class="token punctuation">]</span>//两帧之间的时间间隔    <span class="token punctuation">[</span>Time delta from previous displayed frame: 0.027360000 seconds<span class="token punctuation">]</span>//捕获到显示的间隔时间    <span class="token punctuation">[</span>Time since reference or first frame: 3.969859000 seconds<span class="token punctuation">]</span>//此包和第一帧的时间间隔    Frame Number: 191//帧号    Frame Length: 161 bytes <span class="token punctuation">(</span>1288 bits<span class="token punctuation">)</span>//帧长度    Capture Length: 161 bytes <span class="token punctuation">(</span>1288 bits<span class="token punctuation">)</span>//捕获的帧长度    <span class="token punctuation">[</span>Frame is marked: False<span class="token punctuation">]</span>//帧显著标志    <span class="token punctuation">[</span>Frame is ignored: False<span class="token punctuation">]</span>//帧忽略标志    <span class="token punctuation">[</span>Protocols <span class="token keyword">in</span> frame: eth:ethertype:ip:udp:oicq<span class="token punctuation">]</span>//帧内封装的协议层次结构    <span class="token punctuation">[</span>Coloring Rule Name: UDP<span class="token punctuation">]</span>//着色标记的协议    <span class="token punctuation">[</span>Coloring Rule String: udp<span class="token punctuation">]</span>//着色规则显示的字符串Ethernet II, Src: XiaomiEl_ee:46:6f <span class="token punctuation">(</span>40:31:3c:ee:46:6f<span class="token punctuation">)</span>, Dst: LcfcHefe_c2:10:c2 <span class="token punctuation">(</span>e8:6a:64:c2:10:c2<span class="token punctuation">)</span>    Destination: LcfcHefe_c2:10:c2 <span class="token punctuation">(</span>e8:6a:64:c2:10:c2<span class="token punctuation">)</span>        Address: LcfcHefe_c2:10:c2 <span class="token punctuation">(</span>e8:6a:64:c2:10:c2<span class="token punctuation">)</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>0. <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> LG bit: Globally unique address <span class="token punctuation">(</span>factory default<span class="token punctuation">)</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>.0 <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> IG bit: Individual address <span class="token punctuation">(</span>unicast<span class="token punctuation">)</span>    Source: XiaomiEl_ee:46:6f <span class="token punctuation">(</span>40:31:3c:ee:46:6f<span class="token punctuation">)</span>        Address: XiaomiEl_ee:46:6f <span class="token punctuation">(</span>40:31:3c:ee:46:6f<span class="token punctuation">)</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>0. <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> LG bit: Globally unique address <span class="token punctuation">(</span>factory default<span class="token punctuation">)</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>.0 <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> IG bit: Individual address <span class="token punctuation">(</span>unicast<span class="token punctuation">)</span>    Type: IPv4 <span class="token punctuation">(</span>0x0800<span class="token punctuation">)</span>Internet Protocol Version 4, Src: 223.166.151.88, Dst: 192.168.31.97    0100 <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> Version: 4    <span class="token punctuation">..</span><span class="token punctuation">..</span> 0101 <span class="token operator">=</span> Header Length: 20 bytes <span class="token punctuation">(</span>5<span class="token punctuation">)</span>    Differentiated Services Field: 0x00 <span class="token punctuation">(</span>DSCP: CS0, ECN: Not-ECT<span class="token punctuation">)</span>        0000 00<span class="token punctuation">..</span> <span class="token operator">=</span> Differentiated Services Codepoint: Default <span class="token punctuation">(</span>0<span class="token punctuation">)</span>        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>00 <span class="token operator">=</span> Explicit Congestion Notification: Not ECN-Capable Transport <span class="token punctuation">(</span>0<span class="token punctuation">)</span>    Total Length: 147    Identification: 0x8fa2 <span class="token punctuation">(</span>36770<span class="token punctuation">)</span>    Flags: 0x4000, Don<span class="token string">'t fragment        0... .... .... .... = Reserved bit: Not set        .1.. .... .... .... = Don'</span>t fragment: Set        <span class="token punctuation">..</span>0. <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> More fragments: Not <span class="token keyword">set</span>    <span class="token punctuation">..</span>.0 0000 0000 0000 <span class="token operator">=</span> Fragment offset: 0    Time to live: 52    Protocol: UDP <span class="token punctuation">(</span>17<span class="token punctuation">)</span>    Header checksum: 0x5faf <span class="token punctuation">[</span>validation disabled<span class="token punctuation">]</span>    <span class="token punctuation">[</span>Header checksum status: Unverified<span class="token punctuation">]</span>    Source: 223.166.151.88    Destination: 192.168.31.97User Datagram Protocol, Src Port: 8000, Dst Port: 4004    Source Port: 8000//源IP    Destination Port: 4004//目标IP    Length: 127//长度    Checksum: 0xe51f <span class="token punctuation">[</span>unverified<span class="token punctuation">]</span>//和校验    <span class="token punctuation">[</span>Checksum Status: Unverified<span class="token punctuation">]</span>//和校验状态    <span class="token punctuation">[</span>Stream index: 0<span class="token punctuation">]</span>    <span class="token punctuation">[</span>Timestamps<span class="token punctuation">]</span>        <span class="token punctuation">[</span>Time since first frame: 3.969859000 seconds<span class="token punctuation">]</span>        <span class="token punctuation">[</span>Time since previous frame: 0.031141000 seconds<span class="token punctuation">]</span>OICQ - IM software, popular <span class="token keyword">in</span> China//因特网控制信息协议    Flag: Oicq packet <span class="token punctuation">(</span>0x02<span class="token punctuation">)</span>    Version: 0x3859//版本信息    Command: Heart Message <span class="token punctuation">(</span>2<span class="token punctuation">)</span>    Sequence: 17154    Data<span class="token punctuation">(</span>OICQ Number,if sender is client<span class="token punctuation">)</span>: 1026651458    Data:         <span class="token punctuation">[</span>Expert Info <span class="token punctuation">(</span>Warning/Undecoded<span class="token punctuation">)</span>: Trailing stray characters<span class="token punctuation">]</span>            <span class="token punctuation">[</span>Trailing stray characters<span class="token punctuation">]</span>            <span class="token punctuation">[</span>Severity level: Warning<span class="token punctuation">]</span>            <span class="token punctuation">[</span>Group: Undecoded<span class="token punctuation">]</span></code></pre><pre><code></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础入门</title>
      <link href="/2020/05/16/python-ji-chu/"/>
      <url>/2020/05/16/python-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>﻿ 编程语言很多，但大多是大同小异的，所以掌握编程思维、设计模式和学习方法才能更好的适应一门新的编程语言，我习惯于用思维导图的方式开始一门新的学习。<br><img src="https://img-blog.csdnimg.cn/20200516172628898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Python基础学习框架"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用初级命令</title>
      <link href="/2020/05/16/git-chang-yong-ming-ling/"/>
      <url>/2020/05/16/git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>﻿<img src="https://img-blog.csdnimg.cn/20200516172139305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Git常用命令"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git命令 </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/16/hello-world/"/>
      <url>/2020/05/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器静态路由配置实验</title>
      <link href="/2020/05/14/ji-suan-ji-wang-luo-yuan-li-shi-yan-10/"/>
      <url>/2020/05/14/ji-suan-ji-wang-luo-yuan-li-shi-yan-10/</url>
      
        <content type="html"><![CDATA[<h2 id="实验名称-路由器静态路由配置"><a href="#实验名称-路由器静态路由配置" class="headerlink" title="实验名称  路由器静态路由配置"></a>实验名称  路由器静态路由配置</h2><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>1.掌握静态路由的配置方法和技巧；<br>2.掌握通过静态路由方式实现网络的连通性；<br>3.熟悉广域网线缆的链接方式；</p><h2 id="实验内容和要求"><a href="#实验内容和要求" class="headerlink" title="实验内容和要求"></a>实验内容和要求</h2><p>1.建拓扑图，配置网络设备信息，使各个网络设备正常运行，操作结果如下图：<br><img src="https://img-blog.csdnimg.cn/20200515220304823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200515220418346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br>2.配置两路由器R1、R2上配置接口的IP地址后，单边路由器和PC连接运行正常，操作结果如下图：<br><img src="https://img-blog.csdnimg.cn/2020051522044059.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200515220448666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/2020051522050363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""></p><p>3.继续配置R1串口时钟频率，继续配置R1、R2使两边正常连接运行，操作结果如下图：<br><img src="https://img-blog.csdnimg.cn/20200515220512833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200515220523176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br>两边正常连接<br><img src="https://img-blog.csdnimg.cn/20200515220533448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""></p><p>4.在R1、R2上配置静态路由<br><img src="https://img-blog.csdnimg.cn/20200515220543163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br>查看R1路由器静态路由表证明以上操作成功：<br><img src="https://img-blog.csdnimg.cn/20200515220547504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200515220553161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br>查看R2路由器静态路由表证明以上操作成功：<br><img src="https://img-blog.csdnimg.cn/20200515220558836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br>5.验证配置是否生效，即验证PC0与PC1是否可以相互通信，操作结果如下图：<br><img src="https://img-blog.csdnimg.cn/20200515220603789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt=""><br>Ping命令结果表明，建立过静态路由后，两不同局域网的设备成功相互通信，至此试验结束。</p><h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><p>配置中各操作命令解析：</p><pre class=" language-bash"><code class="language-bash">PC0 //配置PC0的路由和IP地址    IP:         192.168.1.2    Submask:        255.255.255.0    Gateway:        192.168.1.1PC1//配置PC1的路由和IP地址    IP:         192.168.2.2    Submask:        255.255.255.0    Gateway:        192.168.2.1     PC1 <span class="token function">ping</span> PC2 //验证在未配置静态路由前PC0和PC1是否连通 Ping 192.168.2.2   R1//配置R1路由的接口和IP地址    en    conf t    <span class="token function">hostname</span> R1    int fa 1/0    no shut//设置当前接口为管理性打开    ip address 192.168.1.1 255.255.255.0//设置当前接口IP地址    <span class="token keyword">exit</span>    int serial 2/0  //配置serial 2/0接口    ip address 192.168.3.1 255.255.255.0//配置serial 2/0接口IP地址    clock rate 64000（必须配置时钟才可通信）//设置接口时钟频率    no shut    endR2//与上面R1的配置相同    en    conf t    <span class="token function">hostname</span> R2    int fa 1/0      ip address 192.168.2.1 255.255.255.0    no shut    <span class="token keyword">exit</span>    int serial 2/0    ip address 192.168.3.2 255.255.255.0    no shut    endR1//配置R1路由器的静态路由    en    conf t    ip route 192.168.2.0 255.255.255.0 192.168.3.2//配置静态路由    end    show ip route//展示路由表R2//与上面配置R1静态路由相同    en    conf t    ip route 192.168.1.0 255.255.255.0 192.168.3.1    end    show ip routePC1 Ping PC2//验证路由器静态路由是否配置成功，即验证两PC间连通性             Ping 192.168.2.2      reply</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
